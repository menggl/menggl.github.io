<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[BIO-NIO-AIO-Netty实例解析]]></title>
    <url>%2F2018%2F08%2F21%2F2018-08-21BIO-NIO-AIO-Netty%E5%AE%9E%E4%BE%8B%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[同步异步、阻塞非阻塞的概念 同步异步（本地客户端是否主动找代理人处理） 描述的是访问数据的机制，由于IO资源服务器端的原因，本地客户端主动选择的处理方案 同步：是指客户端根据IO资源端的处理时间太长，自己选择等待IO操作完成的一种机制 异步：是指客户端根据IO资源端的处理时间太久，自己选择不等待IO操作完成，去处理别的事务之后再来处理这些数据 阻塞和非阻塞（IO资源服务端是否把客户端给锁住了） 描述的是进程在请求IO资源时，由于IO资源服务器端的原因，本地客户端不得不被动处理的方案 阻塞：一直等待数据资源返回完成（服务端不偷懒） 非阻塞：调用的资源服务端立刻返回响应结果，不会等IO资源准备结束才返回结果（服务端偷懒） 老王烧开水Demo 普通水壶烧水：老王被壶锁住了，不得不站在附近（阻塞），主动的去盯着水是否烧开（同步） 普通水壶烧水：老王没有被壶锁住（非阻塞），但每次都得主动的去观察水有没有烧开（同步） 普通水壶烧水：老王被壶锁住了，不得不站在附近（阻塞），老王给壶安了一个响哨，水开了就告诉他（异步） 普通水壶烧水：老王没被壶锁足（非阻塞），老王还是给壶安了一个响哨，水开了就告诉他（异步） 传统BIO模型传统BIO模型是通过ServerSocket和Socket实现的同步阻塞IO模型 下面直接上demo代码 BIO的Server端代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.io.OutputStreamWriter;import java.io.PrintWriter;import java.net.ServerSocket;import java.net.Socket;public class BioServer &#123; public static void main(String[] args) &#123; int port = 8080; ServerSocket serverSocket = null; try &#123; serverSocket = new ServerSocket(port); System.out.println("启动了服务，端口号为：" + port); while (true) &#123; // 等待客户端的连接请求（阻塞） Socket socket = serverSocket.accept(); System.out.println("服务器端接收到一个连接请求！"); new Thread() &#123; public void run() &#123; BufferedReader reader = null; PrintWriter writer = null; try &#123; // 自己去亲自拿数据（同步） reader = new BufferedReader(new InputStreamReader(socket.getInputStream())); // 自己去亲自响应数据（同步） writer = new PrintWriter(new OutputStreamWriter(socket.getOutputStream())); System.out.println("服务器端开始接收数据！"); while (true) &#123; String line = reader.readLine(); System.out.println("服务器端接收到请求数据：============= " + line); String rlt = "您好，" + line; writer.println(rlt); writer.flush(); System.out.println("服务器端响应请求数据： ============= " + rlt); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; reader.close(); writer.close(); socket.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;; &#125;.start(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if (serverSocket != null) &#123; System.out.println("关闭了服务！"); try &#123; serverSocket.close(); serverSocket = null; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; BIO的Client端代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.io.OutputStreamWriter;import java.io.PrintWriter;import java.net.Socket;import java.util.Scanner;public class BioClient &#123; public static void main(String[] args) throws Exception &#123; String ip = "127.0.0.1"; int port = 8080; Socket socket = null; try &#123; // 必须等服务端连接成功才能离开（阻塞） socket = new Socket(ip, port); socket.setSoTimeout(100000); Scanner sc = new Scanner(System.in); BufferedReader reader = null; PrintWriter writer = null; try &#123; // 自己亲自去获取数据 reader = new BufferedReader(new InputStreamReader(socket.getInputStream())); // 自己亲自去发送数据 writer = new PrintWriter(new OutputStreamWriter(socket.getOutputStream())); while (true) &#123; String line = sc.nextLine(); writer.println(line); writer.flush(); System.out.println("客户端发送请求数据：============= " + line); String rlt = reader.readLine(); System.out.println("客户端接收响应数据： ============= " + rlt); &#125; &#125; finally &#123; sc.close(); reader.close(); writer.close(); &#125; &#125; finally &#123; if (socket != null) &#123; try &#123; socket.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 总结同步阻塞IO就是，自己被IO操作缠住，自己必须亲自去收发信息 伪异步IO模型自己还是被绑起来，但是自己可以通过一个线程池（专门负责收发信息的机构）去收发信息，但是线程池收发信息时自己也得亲自去操作啊，就相当于找了个外包公司去干活，但是活还是一样多，占用人的资源还是一样多。 NIO模型NIO的Server端123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114import java.net.InetSocketAddress;import java.nio.ByteBuffer;import java.nio.channels.SelectableChannel;import java.nio.channels.SelectionKey;import java.nio.channels.Selector;import java.nio.channels.ServerSocketChannel;import java.nio.channels.SocketChannel;import java.util.HashMap;import java.util.Iterator;import java.util.Map;public class NioServers &#123; public static void main(String[] args) throws Exception &#123; int port = 8080; // 创建server通道实例，相当于Bio中的ServerSockets，不过这个可以绑定事件监听 ServerSocketChannel serverChannel = ServerSocketChannel.open(); // 设置这个通道为异步IO，也就是有数据过来，异步进行处理 serverChannel.configureBlocking(false); // 设置socket连接的端口号 serverChannel.bind(new InetSocketAddress(port)); // 创建一个多路服务器，用于通知请求数据到达 Selector selector = Selector.open(); // 将这个通道注册到多路复用监听器上面，监听动作是请求socket连接 serverChannel.register(selector, SelectionKey.OP_ACCEPT); System.out.println("连接通道已经注册了监听事件，服务启动完成！"); // 一个Socket连接拥有同一个SelectionKey，只不过在不同时间段，这个SelectionKey的状态位是不一样的 Map&lt;SelectionKey, String&gt; msgMap = new HashMap&lt;SelectionKey, String&gt;(); ByteBuffer readBuffer = ByteBuffer.allocate(1024); ByteBuffer writeBuffer = ByteBuffer.allocate(1024); // 开始处理连接请求 dowork: while (true) &#123; // 看看有没有连接请求进来 int eventCount = selector.select(); if (eventCount &lt;= 0) &#123;// 这里会一直消耗CPU资源，如果没有连接消息传递的话 continue; &#125; // 拿到所有的连接请求事件句柄 Iterator&lt;SelectionKey&gt; it = selector.selectedKeys().iterator(); while (it.hasNext()) &#123; SelectionKey key = null; // 这里的try_catch是为了防止连接中断 try &#123; // 拿到这个事件句柄就可以干任何事情了 key = it.next(); // 如果事件句柄有效 if (key.isValid()) &#123; // 如果事件句柄状态是接收连接请求 if (key.isAcceptable()) &#123; // 对这个channel操作跟对ServerSocket操作是相似的 ServerSocketChannel serverChannel1 = (ServerSocketChannel) key.channel(); SocketChannel clientChannel = serverChannel1.accept(); // 这个客户端socket也设置成非阻塞的，这样就能绑定到多路复用监听器上了 clientChannel.configureBlocking(false); // 监听客户端socket发送请求数据 clientChannel.register(selector, SelectionKey.OP_READ); &#125; // 如果事件句柄状态是读取数据 else if (key.isReadable()) &#123; readBuffer.clear(); SocketChannel clientChannel = (SocketChannel) key.channel(); int len = clientChannel.read(readBuffer); if (len &gt; 0) &#123; readBuffer.flip(); byte[] bytes = new byte[readBuffer.remaining()]; readBuffer.get(bytes); String requestData = new String(bytes, "UTF-8"); System.out.println("服务器端获取到的数据是：&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; " + requestData); // 将信息和Socket进行绑定保存 msgMap.put(key, requestData); // 然后绑定一个Socket响应事件,接收完请求数据后就可以写数据了 clientChannel.register(selector, SelectionKey.OP_WRITE); &#125; &#125; // 如果事件句柄状态是写出数据 else if (key.isWritable()) &#123; // 如果没有请求数据，就不会响应数据 if (!msgMap.containsKey(key)) &#123; return; &#125; SocketChannel clientChannel = (SocketChannel) key.channel(); writeBuffer.clear(); String responseStr = "你好，" + msgMap.get(key); System.out.println("服务器端返回的数据是：&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; " + responseStr); writeBuffer.put(responseStr.getBytes("UTF-8")); // clear()方法是重置这个缓冲区，使他可以以最大容量接收数据，position-&gt;0,limit-&gt;capacity // flip()是将写入缓冲区数据状态改成读取缓冲区数据状态，position-&gt;0,limit-&gt;原position writeBuffer.flip(); clientChannel.write(writeBuffer); // 重新将channel绑定上读取数据的事件 clientChannel.register(selector, SelectionKey.OP_READ); &#125; &#125; &#125; catch (Exception e) &#123; // 如果socket连接断掉，就必须将socket关闭，否则有可能一直会有socket读事件被加载到事件触发队列里面 System.out.println("远程Socket连接中断！"); if (key != null &amp;&amp; key.isValid()) &#123; SelectableChannel channel = key.channel(); if (channel instanceof ServerSocketChannel) &#123; break dowork; &#125; else if (channel instanceof SocketChannel) &#123; SocketChannel clientChannel = (SocketChannel) channel; clientChannel.close();// 这个地方很重要，关闭客户端连接 &#125; &#125; &#125; finally &#123; it.remove();// 这个地方很重要，移除事件 &#125; &#125; &#125; &#125;&#125; NIO的client端123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990import java.net.InetSocketAddress;import java.net.StandardSocketOptions;import java.nio.ByteBuffer;import java.nio.channels.SelectionKey;import java.nio.channels.Selector;import java.nio.channels.SocketChannel;import java.util.Iterator;import java.util.Scanner;public class NioClients &#123; // 相对于服务器端，客户端就不需要多路复用器了吧，如果想用也可以，那么我们就来实现客户端的多路复用器Nio public static void main(String[] args) throws Exception &#123; String ip = "127.0.0.1"; int port = 8080; SocketChannel clientChannel = SocketChannel.open(); Selector selector = Selector.open(); // 也设置成异步IO，必须在connect之前执行 clientChannel.configureBlocking(false); // 保持长连接 clientChannel.setOption(StandardSocketOptions.SO_KEEPALIVE, true); clientChannel.setOption(StandardSocketOptions.SO_RCVBUF, 128 * 1024); clientChannel.setOption(StandardSocketOptions.SO_SNDBUF, 128 * 1024); boolean connected = clientChannel.connect(new InetSocketAddress(ip, port)); // 如果已经连接上了 if (connected) &#123; clientChannel.finishConnect(); clientChannel.register(selector, SelectionKey.OP_WRITE); &#125; else &#123; // 如果还没有连接成功，向多路复用监听器注册Connect状态 clientChannel.register(selector, SelectionKey.OP_CONNECT); &#125; ByteBuffer readBuffer = ByteBuffer.allocate(1024); ByteBuffer writeBuffer = ByteBuffer.allocate(1024); Scanner sc = new Scanner(System.in); while (true) &#123; int eventCount = selector.select(); if (eventCount &lt;= 0) &#123;// 这里会一直消耗CPU资源，如果没有连接消息传递的话 continue; &#125; Iterator&lt;SelectionKey&gt; it = selector.selectedKeys().iterator(); while (it.hasNext()) &#123; SelectionKey key = it.next(); if (key.isValid()) &#123; // 如果channel处于待连接状态，下面就执行连接动作，直到完成连接 if (key.isConnectable()) &#123; if (clientChannel.finishConnect()) &#123; System.out.println("客户端连接成功！"); clientChannel.register(selector, SelectionKey.OP_WRITE); &#125; else &#123; System.exit(1); &#125; &#125; // 如果是从服务器端接收响应数据事件 else if (key.isReadable()) &#123; readBuffer.clear(); SocketChannel clientChannel1 = (SocketChannel) key.channel(); int len = clientChannel1.read(readBuffer); if (len &gt; 0) &#123; readBuffer.flip(); byte[] bytes = new byte[readBuffer.remaining()]; readBuffer.get(bytes); String responseData = new String(bytes, "UTF-8"); System.out.println("响应信息：" + responseData); clientChannel1.register(selector, SelectionKey.OP_WRITE); &#125; &#125; // 如果客户端可以写数据了，那这个可以写是怎么触发的呢，接收完服务端的数据就触发么？试试吧，看看能用不 else if (key.isWritable()) &#123; writeBuffer.clear(); String line = sc.nextLine(); writeBuffer.put(line.getBytes("UTF-8")); writeBuffer.flip(); SocketChannel clientChannel1 = (SocketChannel) key.channel(); clientChannel1.write(writeBuffer); clientChannel1.register(selector, SelectionKey.OP_READ); &#125; else &#123; // 一直都没有发现别的类型的事件，也就是说OP_CONNECT不会捕捉到？ System.out.println(key.readyOps()); &#125; &#125; else &#123; // 一直都没有发现有无效的key System.out.println(key); &#125; it.remove();// 这个地方很重要 &#125; &#125; &#125;&#125; 总结同步非阻塞IO，终于没有把自己给绑起来了，自己可以去处理别的事情了，但是还得自己去亲自去看看有没有数据准备好，这个定期去看看的频率不好控制，要是看的频繁了会消耗体力消耗CPU，唉，还是愁人 AIO模型AIO的Server端代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158import java.io.IOException;import java.io.UnsupportedEncodingException;import java.net.InetSocketAddress;import java.net.StandardSocketOptions;import java.nio.ByteBuffer;import java.nio.channels.AsynchronousServerSocketChannel;import java.nio.channels.AsynchronousSocketChannel;import java.nio.channels.CompletionHandler;import java.util.concurrent.CountDownLatch;public class AioServer &#123; private static ServerSocketAcceptHandler serverHandler = new ServerSocketAcceptHandler(); private static ClientSocketReadHander clientReadHandler = new ClientSocketReadHander(); private static ClientSocketWriteHandler clientWriteHandler = new ClientSocketWriteHandler(); public static void main(String[] args) &#123; try (AsynchronousServerSocketChannel serverSocketChannel = AsynchronousServerSocketChannel.open().bind(new InetSocketAddress("127.0.0.1", 8080))) &#123; if (serverSocketChannel.isOpen()) &#123; // 设置TCP套接字处于TIME_WAIT状态下的socket，可以重复绑定端口使用，其使用场景是在重启服务的时候，操作系统并不会立刻把端口释放掉，会导致绑定端口失败的情况 serverSocketChannel.setOption(StandardSocketOptions.SO_REUSEADDR, true); // 只需要将接收连接请求的事件处理类注册上就可以了 serverSocketChannel.accept(serverSocketChannel, serverHandler); System.out.println("服务端启动成功！"); // 下面功能就是保持主线程不关闭 CountDownLatch latch = new CountDownLatch(1); latch.await(); &#125; &#125; catch (Exception e) &#123; System.out.println("服务启动异常！" + e.getMessage()); &#125; &#125; // 服务器端接收到连接请求处理逻辑 public static class ServerSocketAcceptHandler implements CompletionHandler&lt;AsynchronousSocketChannel, AsynchronousServerSocketChannel&gt; &#123; @Override public void completed(AsynchronousSocketChannel socketChannel, AsynchronousServerSocketChannel serverSocketChannel) &#123; // 这个地方很重要，接收到socket连接后，要继续绑定监听器，以便继续接受socket连接 serverSocketChannel.accept(serverSocketChannel, serverHandler); System.out.println("当前Socket连接的处理线程是：" + Thread.currentThread().getName()); // 包装一个attachment ReadWriteChannelHandler clientSocketChannelAttachment = new ReadWriteChannelHandler(ByteBuffer.allocate(1024), ByteBuffer.allocate(1024), socketChannel); // 注册一个处理read事件的handler socketChannel.read(clientSocketChannelAttachment.getReadBuffer(), clientSocketChannelAttachment, clientReadHandler); &#125; @Override public void failed(Throwable exc, AsynchronousServerSocketChannel serverSocketChannel) &#123; System.out.println("ServerSocketAcceptHandler failed!"); try &#123; serverSocketChannel.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; // Socket连接处理读取数据的处理逻辑 public static class ClientSocketReadHander implements CompletionHandler&lt;Integer, ReadWriteChannelHandler&gt; &#123; @Override public void completed(Integer len, ReadWriteChannelHandler handler) &#123; System.out.println("当前Socket写入的处理线程是：" + Thread.currentThread().getName()); try &#123; if (len &gt; 0) &#123; // 将接收客户端的请求数据转换成字符串 ByteBuffer readBuffer = handler.getReadBuffer(); readBuffer.flip(); byte[] bytes = new byte[readBuffer.remaining()]; readBuffer.get(bytes); String requestData = new String(bytes, "UTF-8"); System.out.println("请求的数据为：&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; " + requestData); ByteBuffer writeBuffer = handler.getWriteBuffer(); String responseData = new String("你好，") + requestData; System.out.println("请求响应数据为：&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; " + responseData); // 将响应数据返回给客户端 writeBuffer.clear(); writeBuffer.put(responseData.getBytes("UTF-8")); writeBuffer.flip(); AsynchronousSocketChannel socketChannel = handler.getSocketChannel(); socketChannel.write(writeBuffer, handler, clientWriteHandler); &#125; &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; &#125; @Override public void failed(Throwable exc, ReadWriteChannelHandler handler) &#123; System.out.println("ClientSocketReadHander failed!"); AsynchronousSocketChannel socketChannel = handler.getSocketChannel(); try &#123; if (socketChannel != null) &#123; socketChannel.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; // Socket连接处理写入数据的逻辑处理 public static class ClientSocketWriteHandler implements CompletionHandler&lt;Integer, ReadWriteChannelHandler&gt; &#123; @Override public void completed(Integer len, ReadWriteChannelHandler handler) &#123; System.out.println("当前Socket写出的处理线程是：" + Thread.currentThread().getName()); ByteBuffer writeBuffer = handler.getWriteBuffer(); AsynchronousSocketChannel socketChannel = handler.getSocketChannel(); if (writeBuffer.hasRemaining()) &#123; // 如果还有数据没有写完，继续写完 socketChannel.write(writeBuffer, handler, clientWriteHandler); &#125; else &#123; // 如果响应数据发送完成，继续读取客户端的请求数据 ByteBuffer readBuffer = handler.getReadBuffer(); readBuffer.clear(); socketChannel.read(readBuffer, handler, clientReadHandler); &#125; &#125; @Override public void failed(Throwable exc, ReadWriteChannelHandler handler) &#123; System.out.println("ClientSocketWriteHandler failed!"); AsynchronousSocketChannel socketChannel = handler.getSocketChannel(); try &#123; if (socketChannel != null) &#123; socketChannel.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; public static class ReadWriteChannelHandler &#123; private ByteBuffer readBuffer; private ByteBuffer writeBuffer; private AsynchronousSocketChannel socketChannel; public ReadWriteChannelHandler(ByteBuffer readBuffer, ByteBuffer writeBuffer, AsynchronousSocketChannel socketChannel) &#123; this.readBuffer = readBuffer; this.writeBuffer = writeBuffer; this.socketChannel = socketChannel; &#125; public ByteBuffer getReadBuffer() &#123; return readBuffer; &#125; public void setReadBuffer(ByteBuffer readBuffer) &#123; this.readBuffer = readBuffer; &#125; public ByteBuffer getWriteBuffer() &#123; return writeBuffer; &#125; public void setWriteBuffer(ByteBuffer writeBuffer) &#123; this.writeBuffer = writeBuffer; &#125; public AsynchronousSocketChannel getSocketChannel() &#123; return socketChannel; &#125; public void setSocketChannel(AsynchronousSocketChannel socketChannel) &#123; this.socketChannel = socketChannel; &#125; &#125;&#125; AIO的Client端123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138import java.io.IOException;import java.io.UnsupportedEncodingException;import java.net.InetSocketAddress;import java.net.StandardSocketOptions;import java.nio.ByteBuffer;import java.nio.channels.AsynchronousSocketChannel;import java.nio.channels.CompletionHandler;import java.util.Scanner;import java.util.concurrent.CountDownLatch;public class AioClient &#123; private static ClientSocketReadHander clientReadHandler = new ClientSocketReadHander(); private static ClientSocketWriteHandler clientWriteHandler = new ClientSocketWriteHandler(); private static Scanner sc = new Scanner(System.in); public static void main(String[] args) &#123; try (AsynchronousSocketChannel clientChannel = AsynchronousSocketChannel.open()) &#123; clientChannel.connect(new InetSocketAddress("127.0.0.1", 8080)).get(); clientChannel.setOption(StandardSocketOptions.SO_KEEPALIVE, true); // 发送数据消息给服务器 ReadWriteChannelHandler handler = new ReadWriteChannelHandler(ByteBuffer.allocate(1024), ByteBuffer.allocate(1024), clientChannel); String line = sc.nextLine(); ByteBuffer writeBuffer = handler.getWriteBuffer(); writeBuffer.clear(); writeBuffer.put(line.getBytes()); writeBuffer.flip(); clientChannel.write(writeBuffer, handler, clientWriteHandler); // 下面的代码是为了维持main线程持续运行 CountDownLatch cdl = new CountDownLatch(1); cdl.await(); &#125; catch (Exception e) &#123; System.out.println("客户端Socket连接异常！"); &#125; &#125; // Socket连接处理读取数据的处理逻辑 public static class ClientSocketReadHander implements CompletionHandler&lt;Integer, ReadWriteChannelHandler&gt; &#123; @Override public void completed(Integer len, ReadWriteChannelHandler handler) &#123; System.out.println("当前Socket写入的处理线程是：" + Thread.currentThread().getName()); try &#123; if (len &gt; 0) &#123; // 接收服务器端返回的响应数据 ByteBuffer readBuffer = handler.getReadBuffer(); readBuffer.flip(); byte[] bytes = new byte[readBuffer.remaining()]; readBuffer.get(bytes); String responseData = new String(bytes, "UTF-8"); System.out.println("客户端收到响应数据为：&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; " + responseData); // 接收到服务器端的响应数据，继续发送请求数据 String line = sc.nextLine(); ByteBuffer writeBuffer = handler.getWriteBuffer(); writeBuffer.clear(); writeBuffer.put(line.getBytes("UTF-8")); writeBuffer.flip(); AsynchronousSocketChannel socketChannel = handler.getSocketChannel(); socketChannel.write(writeBuffer, handler, clientWriteHandler); &#125; &#125; catch (UnsupportedEncodingException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; @Override public void failed(Throwable exc, ReadWriteChannelHandler handler) &#123; System.out.println("ClientSocketReadHander failed!"); AsynchronousSocketChannel socketChannel = handler.getSocketChannel(); try &#123; if (socketChannel != null) &#123; socketChannel.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; // Socket连接处理写入数据的逻辑处理 public static class ClientSocketWriteHandler implements CompletionHandler&lt;Integer, ReadWriteChannelHandler&gt; &#123; @Override public void completed(Integer len, ReadWriteChannelHandler handler) &#123; System.out.println("当前Socket写出的处理线程是：" + Thread.currentThread().getName()); ByteBuffer writeBuffer = handler.getWriteBuffer(); AsynchronousSocketChannel socketChannel = handler.getSocketChannel(); if (writeBuffer.hasRemaining()) &#123; // 如果还有数据没有写完，继续写完 socketChannel.write(writeBuffer, handler, clientWriteHandler); &#125; else &#123; // 发送请求数据完成，开始等待服务器端的响应数据 ByteBuffer readBuffer = handler.getReadBuffer(); readBuffer.clear(); socketChannel.read(readBuffer, handler, clientReadHandler); &#125; &#125; @Override public void failed(Throwable exc, ReadWriteChannelHandler handler) &#123; System.out.println("ClientSocketWriteHandler failed!"); AsynchronousSocketChannel socketChannel = handler.getSocketChannel(); try &#123; if (socketChannel != null) &#123; socketChannel.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; public static class ReadWriteChannelHandler &#123; private ByteBuffer readBuffer; private ByteBuffer writeBuffer; private AsynchronousSocketChannel socketChannel; public ReadWriteChannelHandler(ByteBuffer readBuffer, ByteBuffer writeBuffer, AsynchronousSocketChannel socketChannel) &#123; this.readBuffer = readBuffer; this.writeBuffer = writeBuffer; this.socketChannel = socketChannel; &#125; public ByteBuffer getReadBuffer() &#123; return readBuffer; &#125; public void setReadBuffer(ByteBuffer readBuffer) &#123; this.readBuffer = readBuffer; &#125; public ByteBuffer getWriteBuffer() &#123; return writeBuffer; &#125; public void setWriteBuffer(ByteBuffer writeBuffer) &#123; this.writeBuffer = writeBuffer; &#125; public AsynchronousSocketChannel getSocketChannel() &#123; return socketChannel; &#125; public void setSocketChannel(AsynchronousSocketChannel socketChannel) &#123; this.socketChannel = socketChannel; &#125; &#125;&#125; 总结自己终于不用被锁住了，而且有任务来了直接去通知小弟去处理了，自己就啥都不用操心了，管理好小弟去接收任务和处理任务就可以了，这就是管理的终极目的，资源有效分配 Buffer缓冲区知识Buffer缓冲区，顾名思义就是一个容器，一个连续的数组，有容量大小，就相当于一个码头里的一个仓库,仓库可以存放的集装箱是有限制的 Channel就相当于火车、轮船等运输工具。 首先码头里的仓库需要准备好商品（数据），准备好之后通知火车轮船(Channel)通过固定的线路将仓库(Buffer)里准备好的集装箱(数据)运送到另一个地方码头的仓库(Buffer)里 下面是buffer的三个属性 capacity： buffer的整个容量，一直都是固定的，仓库的容量大小 position： 当前读写的指针位置，当前正在摆放或者正在提取货物的位置 limit： 当前读写的限制位置，能提取或摆放货物到哪里为止的位置 往buffer中写数据的两种方法：12int size = channel.read(buffer);// 从channel中读取数据写入缓冲区buffer.put(bytes);// 将byte数组里的数据写入缓冲区 从buffer中读取数据的三种方式:1234int size = channel.write(buffer);// 将缓冲区里的数据写入channel中byte bt = buffer.get(); // 从buffer中读取一个bytebyte[] bytes = new byte[1024];buffer.get(bytes); Buffer缓冲区切换状态的方法： flip() 写-&gt;读 将写入buffer模式转换成读取buffer模式 调用之前：0—————–&gt;position————&gt;capacity/limit 调用之后：position———-&gt;limit—————&gt;capacity rewind() 读-&gt;读 调用之前：0—————-&gt;position–&gt;limit——-&gt;capacity 调用之后：position———————&gt;limit——-&gt;capacity clear() 读-&gt;写 不会将数据真的清除 调用之前：0————–&gt;position—&gt;limit———-&gt;capacity 调用之后：position————————————-&gt;capacity/limit compact() 读-&gt;写 将所有未读取的数据拷贝到buffer起始处，将position设置到最后一个未读元素之后 调用之前：0————–&gt;position—&gt;limit———–&gt;capacity 调用之后：0—&gt;position——————————-&gt;capacity/limit mark() 读-&gt;读 标记某个重要的下标 调用之前：0————-&gt;position————-&gt;limit————&gt;capacity 调用之后：0————-&gt;position/mark——–&gt;limit———–&gt;capacity reset() 读-&gt;读 返回重要的下标重新读 调用之前：0————-&gt;mark—-&gt;position—-&gt;limit———–&gt;capacity 调用之后：0————-&gt;position/mark——–&gt;limit———–&gt;capacity Nettynetty是java的开源框架，提供异步的、事件驱动的网络应用程序框架和工具，用以快速开发高性能、高可靠性的网络服务器和客户端程序 netty是一个NIO客户端，服务端框架，可以快速简单的开发稳定的网络应用程序，例如服务端和客户端的协议，它简化了网络编程规范 下面是一个netty测试实例 server端代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071import io.netty.bootstrap.ServerBootstrap;import io.netty.buffer.ByteBuf;import io.netty.buffer.Unpooled;import io.netty.channel.ChannelHandlerContext;import io.netty.channel.ChannelInboundHandlerAdapter;import io.netty.channel.ChannelInitializer;import io.netty.channel.ChannelOption;import io.netty.channel.EventLoopGroup;import io.netty.channel.nio.NioEventLoopGroup;import io.netty.channel.socket.SocketChannel;import io.netty.channel.socket.nio.NioServerSocketChannel;import io.netty.handler.codec.LineBasedFrameDecoder;import io.netty.handler.codec.string.StringDecoder;import java.util.Date;public class NettyServer &#123; public static void main(String[] args) throws InterruptedException &#123; // 分发任务的Boss线程 EventLoopGroup bossGroup = new NioEventLoopGroup(); // 执行上面boss分发的任务的工作线程 EventLoopGroup workerGroup = new NioEventLoopGroup(); try &#123; // server启动器 ServerBootstrap serverBootstrap = new ServerBootstrap(); // 设置NIO的分发线程和工作线程 serverBootstrap.group(bossGroup, workerGroup); // 设置为NIOchannel serverBootstrap.channel(NioServerSocketChannel.class); // 设置重用地址 // serverBootstrap.option(ChannelOption.SO_REUSEADDR, true); // 设置传输的大小 serverBootstrap.option(ChannelOption.SO_BACKLOG, 2048); serverBootstrap.childOption(ChannelOption.SO_KEEPALIVE, true); // 设置数据传输过来之后的处理Handler serverBootstrap.childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123; @Override protected void initChannel(SocketChannel socketChannel) throws Exception &#123; socketChannel.pipeline().addLast(new NettyServerInChannel()); &#125; &#125;); System.out.println("服务器已经启动，端口号：" + 8080); serverBootstrap.bind(8080).channel().closeFuture().sync();// 阻塞主线程 &#125; finally &#123; workerGroup.shutdownGracefully(); bossGroup.shutdownGracefully(); &#125; &#125; public static class NettyServerInChannel extends ChannelInboundHandlerAdapter &#123;// ChannelHandlerAdapter @Override public void channelActive(ChannelHandlerContext ctx) throws Exception &#123; super.channelActive(ctx); &#125; @Override public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123; ByteBuf buffer = (ByteBuf) msg; byte[] msgBytes = new byte[buffer.readableBytes()]; buffer.readBytes(msgBytes); buffer.release(); String msgStr = new String(msgBytes); System.out.println(Thread.currentThread().toString()+"，服务器接收到请求："+msgStr); String response = new Date().toString(); ByteBuf responseBuf = Unpooled.copiedBuffer(response.getBytes("utf-8")); ctx.writeAndFlush(responseBuf); &#125; @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123; ctx.close(); &#125; &#125;&#125; client端代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869import java.util.Scanner;import io.netty.bootstrap.Bootstrap;import io.netty.buffer.ByteBuf;import io.netty.buffer.Unpooled;import io.netty.channel.ChannelHandlerContext;import io.netty.channel.ChannelInboundHandlerAdapter;import io.netty.channel.ChannelInitializer;import io.netty.channel.ChannelOption;import io.netty.channel.EventLoopGroup;import io.netty.channel.nio.NioEventLoopGroup;import io.netty.channel.socket.SocketChannel;import io.netty.channel.socket.nio.NioSocketChannel;import io.netty.handler.codec.LineBasedFrameDecoder;import io.netty.handler.codec.string.StringDecoder;public class NettyClient &#123; public static void main(String[] args) &#123; EventLoopGroup workerGroup = new NioEventLoopGroup(); try &#123; Bootstrap bootstrap = new Bootstrap(); bootstrap.group(workerGroup); bootstrap.channel(NioSocketChannel.class); bootstrap.option(ChannelOption.SO_KEEPALIVE, true); bootstrap.handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123; @Override protected void initChannel(SocketChannel socketChannel) throws Exception &#123; socketChannel.pipeline().addLast(new ClientHandler()); &#125; &#125;); bootstrap.connect("127.0.0.1", 8080).channel().closeFuture().sync(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; workerGroup.shutdownGracefully(); &#125; &#125; public static class ClientHandler extends ChannelInboundHandlerAdapter &#123; private Scanner sc = null; public ClientHandler() &#123; sc = new Scanner(System.in); &#125; @Override public void channelActive(ChannelHandlerContext ctx) throws Exception &#123; byte[] requestBytes = "QUERY SERVER TIME".getBytes(); ByteBuf buf = Unpooled.buffer(requestBytes.length); buf.writeBytes(requestBytes); ctx.writeAndFlush(buf); &#125; @Override public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123; ByteBuf buf = (ByteBuf) msg; byte[] bytes = new byte[buf.readableBytes()]; buf.readBytes(bytes); buf.release(); String responseStr = new String(bytes, "utf-8"); System.out.println("RECEIVE SERVER TIME：" + responseStr); Thread.sleep(1000); String line = "QUERY SERVER TIME\n"; ByteBuf writeBuf = Unpooled.copiedBuffer(line.getBytes("utf-8")); ctx.writeAndFlush(writeBuf); &#125; @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123; ctx.close(); &#125; &#125;&#125; 粘包/拆包 因为netty使用的是socket进行字节数据的传输，多个请求同时发送过来的时候就不能确定哪些字节是第一个请求的，哪些字节是第二个请求的，这就导致了粘包的情况发生，要解决这个问题，就需要使用不同的方案进行拆包了 换行拆包，在服务端和客户端代码的Channel初始化方法中将LineBasedFrameDecoder拆包方案配置上，可以实现按回车换行符进行拆包1234567bootstrap.handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123; @Override protected void initChannel(SocketChannel socketChannel) throws Exception &#123; socketChannel.pipeline().addLast(new LineBasedFrameDecoder(1024));// 按换行符进行拆包 socketChannel.pipeline().addLast(new ClientHandler()); &#125;&#125;); 传送数据的时候就需要在发送的字符串数据后面添加上回车换行符了1String response = new Date().toString()+System.getProperty("line.separator"); 字节转字符串，在服务端和客户端代码的Channel初始化方法中将StringDecoder拆包方案配置上，可以实现将字节数据转换成字符串数据12345678serverBootstrap.childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123; @Override protected void initChannel(SocketChannel socketChannel) throws Exception &#123; socketChannel.pipeline().addLast(new LineBasedFrameDecoder(1024));// 按换行符进行拆包 socketChannel.pipeline().addLast(new StringDecoder());// 将byte转换成String socketChannel.pipeline().addLast(new NettyServerInChannel()); &#125;&#125;); 在handler处理类中就可以直接将Object msg强转成String类型的了123456789@Overridepublic void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123; String msgStr = (String)msg; System.out.println(Thread.currentThread().toString()+"，服务器接收到请求："+msgStr); String response = new Date().toString()+System.getProperty("line.separator"); ByteBuf responseBuf = Unpooled.copiedBuffer(response.getBytes("utf-8")); ctx.writeAndFlush(responseBuf);&#125; 自定义拆包分隔符123456789serverBootstrap.childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123; @Override protected void initChannel(SocketChannel socketChannel) throws Exception &#123; ByteBuf delimiter = Unpooled.copiedBuffer("$_$".getBytes()); socketChannel.pipeline().addLast(new DelimiterBasedFrameDecoder(1024,delimiter)); socketChannel.pipeline().addLast(new StringDecoder());// 将byte转换成String socketChannel.pipeline().addLast(new NettyServerInChannel()); &#125;&#125;); 发送信息的时候需要在信息末尾添加上拆包分隔符12345678910@Overridepublic void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123; String request = (String)msg; System.out.println("RECEIVE SERVER TIME：" + request); Thread.sleep(1000); String line = "QUERY SERVER TIME$_$"; // 这里需要添加上拆包分隔符 ByteBuf writeBuf = Unpooled.copiedBuffer(line.getBytes("utf-8")); ctx.writeAndFlush(writeBuf);&#125; IO多路复用又叫事件驱动，当IO事件放生时才会去做相应的处理，IO没有事件发生，则不会进行任何处理。IO有没有事件发生是由操作系统判断提供的 操作系统的这个功能通过select/poll/epoll/kqueue之类的系统调用函数来使用，这些调用函数可以监视多个文件描述符的读写就绪状态，这样多个文件描述符 Reactor反应堆线程模型 单线程模型 与Nio的模型一样 一个线程在处理客户端的接入（acceptor），以及对接收到的字节数据进行处理（handler），都是一个线程在处理 多线程模型 一个线程负责客户端的接入（acceptor），一个线程池负责对接收到的字节数据进行处理（handler） 主从Reactor多线程模型 一个线程池负责客户端的接入（acceptor），另一个线程池负责对接收到的字节数据进行处理（handler） 零拷贝 第一种 Unpooled.directBuffer(2048); Netty接收和发送都采用的DirectBuffer，使用堆外内存进行socket读写，不需要进行字节缓存区的二次拷贝如果使用的是传统的堆内存（HEAP BUFFERS）进行Socket读写，JVM会将堆内存拷贝一份到直接内存，然后才写入Socket中，这样的话，消息在发送过程中就多了一份缓冲区的拷贝 第二种 CompositeByteBuf，它可以将多个ByteBuf封装成一个ByteBuf，对外提供同一封装后的ByteBuf接口 第三种 文件传输领拷贝，Netty使用传输类DefaultFileRegion通过transferTo方法将文件发送到目标Channel中。可以将文件缓冲区中的内容直接发送到目标Channel，不需要我们读取文件然后再发送到Channel中了 内存池就跟线程池似的，netty使用了内存池的机制来优化内存的分配和回收的，与非内存池在性能上有很大的提升 使用方法1ByteBuf buf = PooledByteBufAllocator.DEFAULT.directBuffer(1024); 测试demo123456789101112131415161718192021222324import io.netty.buffer.ByteBuf;import io.netty.buffer.PooledByteBufAllocator;import io.netty.buffer.Unpooled;public class PooledByteBufDemo &#123; public static void main(String[] args) &#123; byte[] bytes = "测试缓冲池".getBytes(); long start = System.currentTimeMillis(); ByteBuf byteBuf; for (int i = 0; i &lt; 10000; i++) &#123; byteBuf = Unpooled.buffer(1024); byteBuf.writeBytes(bytes); byteBuf.release(); &#125; long time = System.currentTimeMillis(); for (int i = 0; i &lt; 10000; i++) &#123; byteBuf = PooledByteBufAllocator.DEFAULT.buffer(1024); byteBuf.writeBytes(bytes); byteBuf.release(); &#125; long end = System.currentTimeMillis(); System.out.println("UnpooledByteBuf use time:"+(time-start)); System.out.println("PooledByteBuf use time:"+(end-time)); &#125;&#125; 测试结果：12UnpooledByteBuf use time:1313PooledByteBuf use time:68 协程一种协作式的用户态概念 单线程进行业务处理 遇到IO阻塞的时候就将线程资源让出来（yield掉），记录当前栈上的数据 IO资源准备好后再找一个线程恢复栈并把阻塞结果放到这个线程上跑 看上去和同步代码没有任何差别 整个流程可以称为coroutine，而跑在coroutine负责调度的线程称之为fiber 所有的一切都是发生在用户态上，没有发生在内核态上，也就没有线程间的上下文切换的开销]]></content>
      <categories>
        <category>经典</category>
      </categories>
      <tags>
        <tag>BIO</tag>
        <tag>AIO</tag>
        <tag>NIO</tag>
        <tag>Netty</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AKKA的使用及原理剖析]]></title>
    <url>%2F2018%2F08%2F17%2F2018-08-17AKKA%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90%2F</url>
    <content type="text"><![CDATA[AKKA是一个在JVM上构建高并发、分布式、有弹性的消息驱动应用的工具集，AKKA中“Actor”只是AKKA工具集中的一部分，它能让我们在编写并发代码时，不用关系低层级的线程和锁。AKKA中其它的工具还包括AKKA Streams和Akka http。尽管AKKA是使用Scala语言编写的，但是它也有Java API 在AKKA中，Actor是最基本的工作单元。Actor是状态和行为的一个容器，它可以创建和监管子Actor。Actor之间都是通过异步进行相互的通讯。这个模型可以有效的保护Actor的内部状态，使其能够实现线程安全，该模型还实现了事件驱动的行为，从而不会阻塞其它的Actor。 类似收发短信，我们需要使用消息来调用Actor，消息发送之后就不可更改。不同的actor所能接收的消息类型是不一样的。actor接收到消息，然后以各种方式对其作出相应，并且还可以发送其它消息，修改自己的状态或行为、创建其它的actor AKKA使用方式 可以将jar包放入Web应用中 可以以微内核的形式使用 使用AKKA的五大好处 易于构建并行和分布式应用，AKKA在设计的时候就采用了异步通讯和分布式架构，并对上层进行了抽象，如Actors，Futures，STM等 可靠性，系统具备自愈能力，在本地和远程都有监护 高性能，在单机情况下，每秒能发送50000000个消息，内存占用小，1GB内存就可以保存2500000个Actors 弹性，无中心，自适应的负载均衡，路由，分区，配置 可扩展，可以使用AKKA扩展包进行扩展 我们看看如何使用 Tell方式调用 创建一个Actor，MessageHandler.java 1234567891011public static class MessageHandler extends AbstractActor &#123; public MessageHandler()&#123; super.getContext().setReceiveTimeout(Duration.create(10, TimeUnit.SECONDS)); &#125; @Override public AbstractActor.Receive createReceive() &#123; return super.receiveBuilder().match(Message.class,message -&gt; &#123; System.out.println("name="+message.getName()+",date="+message.getDate()); &#125;).build(); &#125;&#125; 传递的消息类型定义 12345678910111213141516public static class Message &#123; private String name; private Date date; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Date getDate() &#123; return date; &#125; public void setDate(Date date) &#123; this.date = date; &#125;&#125; main调用示例 123456789101112131415161718public static void main(String[] args) &#123; ActorSystem actorSystem = ActorSystem.create("simple1"); ActorRef counter = actorSystem.actorOf(Props.create(MessageHandler.class, new Creator&lt;MessageHandler&gt;() &#123; @Override public MessageHandler create() throws Exception &#123; return new MessageHandler(); &#125; &#125;), "Counter"); Message msg = new Message(); msg.setName("张三来电话了"); msg.setDate(new Date()); counter.tell(msg,ActorRef.noSender()); try &#123; Thread.sleep(10000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;&#125; 上面这个是tell的使用方式，没有返回的消息 Ask方式调用下面是使用ask调用，可以得到返回消息信息 MessageHandler对象变更如下 12345678910111213public static class MessageHandler extends AbstractActor &#123; public MessageHandler()&#123; super.getContext().setReceiveTimeout(Duration.create(10, TimeUnit.SECONDS)); &#125; @Override public AbstractActor.Receive createReceive() &#123; return super.receiveBuilder().match(Message.class,this::onMessage).build(); &#125; private void onMessage(Message msg)&#123; System.out.println("name="+msg.getName()+",date="+msg.getDate()); this.sender().tell("success",ActorRef.noSender()); &#125;&#125; main调用变更如下 123456789101112131415161718192021public static void main(String[] args) &#123; try &#123; ActorSystem actorSystem = ActorSystem.create("simple1"); ActorRef counter = actorSystem.actorOf(Props.create(MessageHandler.class, new Creator&lt;MessageHandler&gt;() &#123; @Override public MessageHandler create() throws Exception &#123; return new MessageHandler(); &#125; &#125;), "Counter"); Message msg = new Message(); msg.setName("张三来电话了"); msg.setDate(new Date()); Timeout timeout = new Timeout(5,TimeUnit.SECONDS); Future&lt;Object&gt; future = Patterns.ask(counter,msg,timeout); String result = (String)Await.result(future,timeout.duration()); System.out.println("result="+result); Thread.sleep(10000); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; 与spring集成 在spring的配置文件中配置如下bean定义 123&lt;bean id="actorSystem" class="akka.actor.ActorSystem" factory-method="create" scope="singleton"&gt; &lt;constructor-arg value="mgl-actor-system" /&gt;&lt;/bean&gt; 创建SpringExt.java，Actor的Props的提供者，其需要一个可以创建Actor的生产者（SpringActorProducer） 123456789101112131415161718import akka.actor.Extension;import akka.actor.Props;import org.springframework.beans.BeansException;import org.springframework.context.ApplicationContext;import org.springframework.context.ApplicationContextAware;import org.springframework.stereotype.Component;@Component("springExt")public class SpringExt implements Extension,ApplicationContextAware &#123; private ApplicationContext applicationContext; @Override public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123; this.applicationContext = applicationContext; &#125; public Props props(String actorBeanName, Object... args)&#123; return Props.create(SpringActorProducer.class,applicationContext,actorBeanName,args); &#125;&#125; 创建SpringActorProducer.java，Actor实例的生产者 1234567891011121314151617181920212223import org.springframework.context.ApplicationContext;import akka.actor.Actor;import akka.actor.IndirectActorProducer;public class SpringActorProducer implements IndirectActorProducer&#123; private final ApplicationContext applicationContext; private final String actorBeanName; private final Object[] args; public SpringActorProducer(ApplicationContext applicationContext,String actorBeanName,Object... args)&#123; this.applicationContext = applicationContext; this.actorBeanName = actorBeanName; this.args = args; &#125; @SuppressWarnings("unchecked") @Override public Class&lt;? extends Actor&gt; actorClass() &#123; return (Class&lt;? extends Actor&gt;)applicationContext.getType(this.actorBeanName); &#125; @Override public Actor produce() &#123; return (Actor)applicationContext.getBean(actorBeanName,args); &#125;&#125; 定义处理消息的Actor对象 1234567891011121314151617181920212223import akka.actor.AbstractActor;import akka.actor.ActorRef;import org.springframework.context.annotation.Scope;import org.springframework.stereotype.Component;import scala.concurrent.duration.Duration;import java.util.concurrent.TimeUnit;@Component("messageService")@Scope("prototype")public class MessageService extends AbstractActor &#123; public MessageService()&#123; getContext().setReceiveTimeout(Duration.create(10, TimeUnit.SECONDS)); &#125; @Override public Receive createReceive() &#123; return receiveBuilder().match(String.class, message -&gt; &#123; onReceive(message); &#125;).build(); &#125; private void onReceive(String message) &#123; System.out.println("message=="+message); &#125;&#125; 调用方法如下 12345678910111213141516171819202122232425import akka.actor.ActorRef;import akka.actor.ActorSystem;import com.mgl.demo.akka.SpringExt;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;@Controller@RequestMapping("/akka")public class TestController &#123; @Autowired private SpringExt springExt; @Autowired private ActorSystem actorSystem; @RequestMapping("/test") @ResponseBody public String test()&#123; ActorRef actor = actorSystem.actorOf(this.springExt.props("messageService"),"MessageService"+System.nanoTime()); actor.tell("hello zhangsan",ActorRef.noSender()); return "success"; &#125;&#125; 配置扫描器将上面的类都注入到spring容器中 1&lt;context:component-scan base-package="com.mgl.demo" /&gt;]]></content>
      <categories>
        <category>经典</category>
      </categories>
      <tags>
        <tag>AKKA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入剖析ReentrantLock加解锁中CAS和AQS的使用]]></title>
    <url>%2F2018%2F08%2F16%2F2018-08-16%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90ReentrantLock%E5%8A%A0%E8%A7%A3%E9%94%81%E4%B8%ADCAS%E5%92%8CAQS%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[我们在解决同一台服务器多线程按顺序处理同一资源时，通常需要加锁，一般我们会使用Synchronized或者ReentrantLock等加锁手段，下面我们来剖析一下ReentrantLock的加锁解锁的实现原理 ReentrantLock加锁的逻辑通常情况下都会以ReentrantLock.lock()来获取到锁123public void lock() &#123; sync.lock();&#125; ReentrantLock中会有一个NonfairSync非公平锁和FairSync公平锁的实现，下面我们先来讲解非公平锁的实现 非公平锁sync.lock会调用到非公平锁中的lock方法， 首先比较当前锁有没有被占用，没被占用就直接拿到锁 被占用了就会进入acquire(1)方法中去获取锁 1234567891011121314151617181920212223242526272829303132333435363738static final class NonfairSync extends Sync &#123; // ReentrantLock中的 private static final long serialVersionUID = 7316153563782823691L; final void lock() &#123; // 如果compareAndSetState成功了，说明当前线程拿到了锁，将当前线程设置到锁的占用线程字段上 if (compareAndSetState(0, 1)) setExclusiveOwnerThread(Thread.currentThread()); else acquire(1);// 如果锁一直被占用，则需要去排队，这个是非公平锁 &#125; // 去尝试加非公平锁，这里的acquires=1 protected final boolean tryAcquire(int acquires) &#123; // 这个是Sync中的方法 return nonfairTryAcquire(acquires); &#125;&#125;// 这个就是Sync中加非公平锁的逻辑，很简单，就是用CAS改当前ReentrantLock-Node的一个状态final boolean nonfairTryAcquire(int acquires) &#123; // ReentrantLock中的 final Thread current = Thread.currentThread(); int c = getState(); if (c == 0) &#123;// 如果当前ReentrantLock状态是0，就可以去尝试获取锁（非公平锁） if (compareAndSetState(0, acquires)) &#123; setExclusiveOwnerThread(current); return true; &#125; &#125; // 如果状态不为0，表示有线程在占用这把锁，看看占用的线程和当前线程是不是一样，如果一样，说明是重入锁 else if (current == getExclusiveOwnerThread()) &#123; int nextc = c + acquires; if (nextc &lt; 0) // overflow throw new Error("Maximum lock count exceeded"); setState(nextc); return true; &#125; return false;&#125;protected final boolean compareAndSetState(int expect, int update) &#123; // AQS中 return unsafe.compareAndSwapInt(this, stateOffset, expect, update);&#125; 这个方法中还是先去获取锁，如果获取不成功去加入到等到队列中，这个队列是个双向队列 12345public final void acquire(int arg) &#123; // AQS中的方法 if (!tryAcquire(arg) // 这个时候就去竞争锁了，肯定是非公平锁，NonfairSync类中的方法 &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt();&#125; 下面是加入到等待队列中的逻辑 1234567891011121314151617181920212223242526272829private Node addWaiter(Node mode) &#123; // AQS中的方法 // 这个mode是null，创建一个当前线程的Node Node node = new Node(Thread.currentThread(), mode); Node pred = tail; // 这个字段是public abstract class AbstractQueuedSynchronizer extends AbstractOwnableSynchronizer 中的属性 if (pred != null) &#123; // 如果当前节点不是第一个排队的节点 node.prev = pred; // 将当前节点挂到上一个排队节点上去 if (compareAndSetTail(pred, node)) &#123; // 尝试将当前节点设置成末尾节点，如果设置成功就返回当前节点，如果并发情况设置不成功，下面的enq会不断重复设置当前节点为末尾节点 pred.next = node; // 设置上一个末尾节点的下一个节点是当前节点 return node; &#125; &#125; enq(node); // 继续尝试将当前线程节点设置成末尾节点，其实完全可以将上面if那套逻辑去掉，跟下面这套逻辑重复 return node;&#125;private Node enq(final Node node) &#123; // AQS中的方法 for (;;) &#123; Node t = tail; if (t == null) &#123; if (compareAndSetHead(new Node())) // 如果没有在排队的，设置一个head tail = head; // tail=head &#125; else &#123; node.prev = t; // 和上面的addWaiter某些逻辑一样 if (compareAndSetTail(t, node)) &#123; t.next = node; return t; &#125; &#125; &#125;&#125; 加入到等待队列后就走到了acquireQueued逻辑，就需要park掉当前的线程，直到线程被unpark唤醒 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566final boolean acquireQueued(final Node node, int arg) &#123; // AQS中的方法 boolean failed = true; try &#123; boolean interrupted = false; for (;;) &#123; // 在这里一直循环，直到最终拿到锁 final Node p = node.predecessor(); // 获取当前线程节点的上一个节点 if (p == head &amp;&amp; tryAcquire(arg)) &#123;// 如果当前节点的上一个节点是head，那就说明当前节点可以去获取锁了 setHead(node);// 将当前节点设置成head，并且当前节点的prev为null，线程为null p.next = null; // 以前的头节点的next为null，以便于内存回收 failed = false; // 设置加锁成功变量 return interrupted; // 返回结果，线程没有被中断 &#125; // 如果当前节点的上一个节点不是头节点，就去下一步处理 if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) interrupted = true; &#125; &#125; finally &#123; if (failed) // 如果加锁失败 cancelAcquire(node); &#125;&#125;private void setHead(Node node) &#123; // AQS中的 head = node; node.thread = null; node.prev = null;&#125;// 取消加锁private void cancelAcquire(Node node) &#123; // AQS中的 if (node == null) return; node.thread = null; Node pred = node.prev; // 拿到当前节点的上一个节点 while (pred.waitStatus &gt; 0) // 找到一个状态&lt;=0的线程等待节点 node.prev = pred = pred.prev; Node predNext = pred.next; node.waitStatus = Node.CANCELLED; // 置为取消获取锁的状态，这个状态是唯一的大于0的状态 if (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123; // 当前节点是尾节点处理 compareAndSetNext(pred, predNext, null);// 设置pred的next节点为null &#125; else &#123; // 当前节点是中间节点处理 int ws; if (pred != head &amp;&amp; ((ws = pred.waitStatus) == Node.SIGNAL || (ws &lt;= 0 &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp; pred.thread != null) &#123;// 如果上一个节点不是头结点并且是正常等待线程节点 Node next = node.next; if (next != null &amp;&amp; next.waitStatus &lt;= 0) compareAndSetNext(pred, predNext, next);// 设置上一个节点的下一节点是当前节点的下一个节点，当前节点的下一个节点的prev没有设置？ &#125; else &#123;// 当前节点是头节点，或者上一节点已经加锁完成并释放掉了锁 unparkSuccessor(node); // 踢醒下一个等待加锁的线程 &#125; node.next = node; // help GC &#125;&#125;private void unparkSuccessor(Node node) &#123; // AQS中的 int ws = node.waitStatus; if (ws &lt; 0) compareAndSetWaitStatus(node, ws, 0); Node s = node.next; if (s == null || s.waitStatus &gt; 0) &#123; s = null; for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev) if (t.waitStatus &lt;= 0) s = t; &#125; if (s != null) LockSupport.unpark(s.thread);&#125; park之前还需要再尝试获取锁一下，如果当前线程是第一个排队的线程就去再尝试获取一下锁，如果还获取不到，就只能park掉等待unpark了 123456789101112131415private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) &#123; // AQS中的 // 上一个节点的等待状态值 0：线程已取消 -1：线程需要卸载 -2：线程正在条件下等待 -3：指示下一个获取共享应该无条件传播 int ws = pred.waitStatus; if (ws == Node.SIGNAL)// 后续需要卸载的状态，上个节点的状态是-1，那就是需要等待 return true; if (ws &gt; 0) &#123; do &#123; node.prev = pred = pred.prev; &#125; while (pred.waitStatus &gt; 0); pred.next = node; &#125; else &#123; compareAndSetWaitStatus(pred, ws, Node.SIGNAL);// 快轮到了，给一次机会去获取锁，改完状态成-1后就只能去被park掉了 &#125; return false;&#125; 这是要真正的去park掉线程了 1234567891011121314151617private final boolean parkAndCheckInterrupt() &#123; // AQS中的 LockSupport.park(this);// 将线程park掉，一直等到unpark(thread)才能继续往下走 return Thread.interrupted();&#125;public static void park(Object blocker) &#123; // LockSupport中的 Thread t = Thread.currentThread(); // 将当前的锁ReentrantLock放到到线程中 setBlocker(t, blocker); // 第一个参数，时间是绝对的还是相对的，当为true，绝对时间间隔时，等待后面的多长时间就结束，如果是false时，就一直等待直到被调用unpark(thread)方法 UNSAFE.park(false, 0L); setBlocker(t, null);&#125;private static void setBlocker(Thread t, Object arg) &#123; // LockSupport中的 // 每个线程中都会有一个parkBlocker属性，获取这个属性在线程中的偏移量parkBlockerOffset = UNSAFE.objectFieldOffset(tk.getDeclaredField("parkBlocker")); // 设置线程中的parkBlocker对象为当前的ReentrantLock UNSAFE.putObject(t, parkBlockerOffset, arg);&#125; 下面这个Node节点是AQS中定义的类，可以保存当前ReentrantLock中排队的各个线程的节点及节点当前的状态 123456789101112131415161718192021222324252627282930313233static final class Node &#123; // AQS中的 static final Node SHARED = new Node(); static final Node EXCLUSIVE = null; static final int CANCELLED = 1; static final int SIGNAL = -1; static final int CONDITION = -2; static final int PROPAGATE = -3; volatile int waitStatus; volatile Node prev; volatile Node next; volatile Thread thread; Node nextWaiter; final boolean isShared() &#123; return nextWaiter == SHARED; &#125; final Node predecessor() throws NullPointerException &#123; Node p = prev; if (p == null) throw new NullPointerException(); else return p; &#125; Node() &#123; // Used to establish initial head or SHARED marker &#125; Node(Thread thread, Node mode) &#123; // Used by addWaiter this.nextWaiter = mode; this.thread = thread; &#125; Node(Thread thread, int waitStatus) &#123; // Used by Condition this.waitStatus = waitStatus; this.thread = thread; &#125;&#125; 释放锁的逻辑释放锁的逻辑就很简单了，修改当前锁的状态标志位（AQS提供的），unpark排队队列中的第一个线程123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public void unlock() &#123; // ReentrantLock中的 sync.release(1);&#125;public final boolean release(int arg) &#123; // ReentrantLock中的 if (tryRelease(arg)) &#123; // 如果刚好释放锁成功，就踢醒等待队列中的线程去获取锁 Node h = head; if (h != null &amp;&amp; h.waitStatus != 0) // 如果队列中没有线程在排队，直接返回true了，如果队列中有线程在排队获取锁，那就踢醒第一个等待线程 unparkSuccessor(h); return true; &#125; return false;&#125;// 这个是ReentrantLock实现的AQS的抽象方法protected final boolean tryRelease(int releases) &#123; // ReentrantLock中的 int c = getState() - releases; // 现在getState()返回值肯定是1了,c=0 if (Thread.currentThread() != getExclusiveOwnerThread()) throw new IllegalMonitorStateException(); boolean free = false; if (c == 0) &#123; free = true; setExclusiveOwnerThread(null); // 设置占有锁的线程为null &#125; setState(c); // 设置锁的状态为0 return free; // 返回是否释放成功&#125;private void unparkSuccessor(Node node) &#123; // AQS中的 int ws = node.waitStatus; if (ws &lt; 0) // 等待队列的头节点一般都是-1，是0的情况就是刚进入这个方法，另一个线程就来排队获取锁了，还没来得及将waitStatus设置成-1的那一片段时间 compareAndSetWaitStatus(node, ws, 0);// 将头节点的等待状态设置为0 Node s = node.next; if (s == null || s.waitStatus &gt; 0) &#123; s = null; // 从末尾往前找等待节点，看看还有没有&lt;=0状态的线程节点，找到排在最前面的第一个节点 for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev) if (t.waitStatus &lt;= 0) s = t; &#125; if (s != null) LockSupport.unpark(s.thread);&#125;private static final boolean compareAndSetWaitStatus(Node node,int expect,int update) &#123; // AQS中的 return unsafe.compareAndSwapInt(node, waitStatusOffset,expect, update);&#125;// 将线程激活public static void unpark(Thread thread) &#123; // LockSupport中的 if (thread != null) UNSAFE.unpark(thread);// 踢醒当前线程去获取锁&#125; 公平锁如果想创建一个公平锁，可以使用下面的方法1ReentrantLock lock = new ReentrantLock(true);// true:公平锁，false:非公平锁 同样的，公平锁在ReentrantLock中也有一个实现类，FairSync 它也拥有一个lock()的方法123final void lock() &#123; acquire(1);&#125; 这个是AQS中的方法12345public final void acquire(int arg) &#123; // ReentrantLock中的 if (!tryAcquire(arg) &amp;&amp; //没有拿到锁，就去添加到等待队列了 acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt();&#125; 这里的tryAcquire方法就是FairSync中的实现方法了, 而不是NonfairSync中的方法了123456789101112131415161718192021222324252627protected final boolean tryAcquire(int acquires) &#123;// ReentrantLock中的 final Thread current = Thread.currentThread(); int c = getState(); if (c == 0) &#123; if (!hasQueuedPredecessors() &amp;&amp; // 先去判断队列中有没有等待的线程，如果没有等待的线程，可以去拿锁了 compareAndSetState(0, acquires)) &#123;// 看看能不能直接拿到锁 setExclusiveOwnerThread(current); return true; &#125; &#125; else if (current == getExclusiveOwnerThread()) &#123; // 如果锁不是在空闲状态，判断当前线程有没有持有锁 int nextc = c + acquires; if (nextc &lt; 0) throw new Error("Maximum lock count exceeded"); setState(nextc); return true; &#125; return false;&#125;// 判断队列中是否有线程public final boolean hasQueuedPredecessors() &#123; // ReentrantLock中的 Node t = tail; Node h = head; Node s; return h != t &amp;&amp; // 如果队列头不等于队列尾部，说明有线程 ((s = h.next) == null || s.thread != Thread.currentThread());// 如果队列头的next为空（还没初始化完成）或者第一个等待线程不是当前线程，说明队列里面也有线程&#125; 跟NonfairSync中用的tryAcquire方法比较一下，只是多了一个!hasQueuedPredecessors()判断语句，如果排到你了，你才能去拿锁，否则去队列排队 总结，在ReentrantLock的加锁解锁中ReentrantLock的作用如下： 实现AQS的tryAcquire方法逻辑（AQS提供的抽象方法） 提供解锁的tryRelease实现逻辑（AQS提供的抽象方法） 提供是否公平加锁的逻辑（sync = fair ? new FairSync() : new NonfairSync();） 提供修改AQS中的state状态来判断是否获取到锁的逻辑（if (getState() == 0)） 提供改AQS的state状态标志位的逻辑（if (compareAndSetState(0, acquires))） 提供保存获取到当前锁的线程的逻辑（setExclusiveOwnerThread(current)） AQS的作用如下： 提供一个Node对象定义，该节点持有当前竞争锁的线程，可以当做等待队列中的节点挂到队列中，Node对象有prevNode，nextNode可以创建双向链表，Node对象有waitStatus可以保存当前等待锁队列中各个节点线程的状态 提供维护队列的逻辑，将线程往队列里添加、取消线程的排队（addWaiter、cancelAcquire） 提供线程获取锁的总流程逻辑（acquire） 提供遍历线程队列，尝试给线程加锁的逻辑（acquireQueued） 提供将线程park掉和unpark线程的逻辑（parkAndCheckInterrupt、unparkSuccessor） CAS的作用如下： 多线程竞争条件下的乐观锁 多线程下修改锁的状态位的功能（compareAndSetState(0, 1)） 多线程下修改队列头节点的功能（compareAndSetHead(new Node())） 多线程下修改队列尾节点的功能（compareAndSetTail(node, pred)） 多线程下修改某个节点的下一节点的功能（compareAndSetNext(pred, predNext, next)） 多线程下修改某个线程节点的状态值的功能（compareAndSetWaitStatus(node, ws, 0)） LockSupport的作用如下： park掉线程的功能（LockSupport.park(this)） unpark线程的功能（LockSupport.unpark(s.thread)） UNSAFE的作用如下： 乐观锁修改某个对象的某个字段的作用（unsafe.compareAndSwapInt(this, stateOffset, expect, update)） 条件变量Condition的使用condition解决了不能唤醒指定的锁等待的功能，下面我们深入剖析一下源码是如何实现的 我们可以通过lock.newCondition()创建N多个条件变量，给各个线程使用 比如线程1调用lock()完成拿到锁后，有些条件达不到我们的要求，我们就得等到资源就位后再继续工作，那么就用到了condition1.await()功能，等资源就位后，调用condition1.signal()方法就可以让线程1继续往下执行了 await方法我们来看一下await()到底做了一些什么操作1234567891011121314151617181920212223242526272829303132333435363738394041public final void await() throws InterruptedException &#123; // ConditionObject中的 if (Thread.interrupted()) // 如果线程被中断了，抛出异常 throw new InterruptedException(); Node node = addConditionWaiter(); // 这里很重要，将当前线程节点放入到ConditionObject的waiter队列中去 int savedState = fullyRelease(node); // 这里返回的savedState就是1 int interruptMode = 0; while (!isOnSyncQueue(node)) &#123; // 判断这个节点是不是在在同步队列里面，这个节点为什么会进入同步队列里面？ LockSupport.park(this);// 不在同步队列里面就应该park掉当前线程，不让当前线程继续运行了，直到别的线程获取到锁之后unpark该线程，这里就表示await阻塞到这里了 if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)// 如果没有中断 break; &#125; // 被敲醒之后，这个节点就可以去拿锁去了 if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE) interruptMode = REINTERRUPT; if (node.nextWaiter != null) // clean up if cancelled unlinkCancelledWaiters(); if (interruptMode != 0) reportInterruptAfterWait(interruptMode);&#125;private Node addConditionWaiter() &#123; // ConditionObject中的 Node t = lastWaiter; // 拿到最后一个等待线程对象 // If lastWaiter is cancelled, clean out. if (t != null &amp;&amp; t.waitStatus != Node.CONDITION) &#123; unlinkCancelledWaiters(); t = lastWaiter; &#125; Node node = new Node(Thread.currentThread(), Node.CONDITION);// 创建当前线程的一个节点，节点状态是CONDITION=-2 if (t == null) firstWaiter = node;// 因为加锁才能操作，只能一个一个线程的调用await()方法，所以这里不用考虑并发的情况 else t.nextWaiter = node; lastWaiter = node; return node;&#125;final boolean isOnSyncQueue(Node node) &#123; if (node.waitStatus == Node.CONDITION || node.prev == null) // 不在同步队列里面 return false; if (node.next != null) // 如果next为null，表示肯定在同步队列里面 return true; return findNodeFromTail(node);// 从尾节点一个一个去判断吧&#125; 将线程的状态状态全部重置12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152final int fullyRelease(Node node) &#123; // AQS中的 boolean failed = true; try &#123; int savedState = getState();// 当前锁的状态肯定是1 if (release(savedState)) &#123; // 如果重置成功 failed = false; return savedState; &#125; else &#123; throw new IllegalMonitorStateException(); &#125; &#125; finally &#123; if (failed) // 如果重置状态位失败，设置这个节点的waitStatus为CANCELLED node.waitStatus = Node.CANCELLED; &#125;&#125;public final boolean release(int arg) &#123;// AQS中的 if (tryRelease(arg)) &#123;// 重置成功 Node h = head; // 找到AQS的队列头节点 if (h != null &amp;&amp; h.waitStatus != 0) unparkSuccessor(h);// 将等待获取锁的队列中的第一个节点的线程unpark掉，这样第一个等待线程就会 return true; &#125; return false;&#125;// 重置当前锁的状态位和占用线程字段protected final boolean tryRelease(int releases) &#123;// ReentrantLock中的 int c = getState() - releases; if (Thread.currentThread() != getExclusiveOwnerThread()) throw new IllegalMonitorStateException(); boolean free = false; if (c == 0) &#123; free = true; setExclusiveOwnerThread(null);// 设置当前锁的占用线程为null &#125; setState(c);// 设置当前锁的state=0 return free;&#125;private void unparkSuccessor(Node node) &#123; int ws = node.waitStatus; if (ws &lt; 0) compareAndSetWaitStatus(node, ws, 0); Node s = node.next; if (s == null || s.waitStatus &gt; 0) &#123; s = null; for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev) if (t.waitStatus &lt;= 0) s = t; &#125; if (s != null) LockSupport.unpark(s.thread);&#125; 我们看看当前在waiter队列里的线程被敲醒之后会如何处理，现在这个线程节点已经被signal()方法从waiter队列里移出来了 这个线程就去正常的竞争锁去了 跟lock()中的获取锁的逻辑一样123456789101112131415161718192021final boolean acquireQueued(final Node node, int arg) &#123; boolean failed = true; try &#123; boolean interrupted = false; for (;;) &#123; final Node p = node.predecessor(); if (p == head &amp;&amp; tryAcquire(arg)) &#123; setHead(node); p.next = null; // help GC failed = false; return interrupted; &#125; if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) interrupted = true; &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125;&#125; signal方法我们来看看signal()方法123456789101112131415public final void signal() &#123; if (!isHeldExclusively())// 想执行signal，自己必须得拿到锁才行 throw new IllegalMonitorStateException(); Node first = firstWaiter; // 拿到waiter队列中第一个节点 if (first != null) // 这里说明如果先调用signal()方法，是不行的，必须先调用await()才行 doSignal(first);&#125;private void doSignal(Node first) &#123; // ConditionObject中的 do &#123; if ( (firstWaiter = first.nextWaiter) == null) // 从waiter队列中移除第一个节点 lastWaiter = null; first.nextWaiter = null;// 清空第一个节点的下一个节点，这里应该是单向链表 &#125; while (!transferForSignal(first) &amp;&amp; (first = firstWaiter) != null);&#125; 传递信号并unparkwaiter队列中的第一个线程12345678910111213final boolean transferForSignal(Node node) &#123;// AQS 中的 if (!compareAndSetWaitStatus(node, Node.CONDITION, 0))// 转换第一个节点的状态位为0失败的时候就返回false return false; Node p = enq(node); // 这个地方很重要，将ConditionObject中的等待队列中的第一个重新放入AQS中的待获取锁队列中去 int ws = p.waitStatus; if (ws &gt; 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL)) LockSupport.unpark(node.thread); return true;&#125;// 从0状态转换成-1状态private static final boolean compareAndSetWaitStatus(Node node,int expect,int update) &#123; return unsafe.compareAndSwapInt(node, waitStatusOffset, expect, update);&#125; 这个调用很重要，将waiter队列中的第一个线程放入AQS等待获取锁的队列中123456789101112131415private Node enq(final Node node) &#123; // AQS中的 for (;;) &#123; Node t = tail; if (t == null) &#123; // Must initialize if (compareAndSetHead(new Node())) tail = head; &#125; else &#123; node.prev = t; if (compareAndSetTail(t, node)) &#123; t.next = node; return t; &#125; &#125; &#125;&#125; 总结一下：await()方法的作用 将当前线程放到ConditionObject中的waiter队列里去 然后当前线程就被park掉 经过下面的notify()方法的unpark操作，线程被唤醒，继续尝试着去获取锁（acquireQueued(node, savedState)），获取不到锁就继续阻塞park，获取到锁就可以继续进行业务逻辑操作了 notify()方法的作用 将waiter队列中的第一个线程节点拿出来，修改好状态，并将该节点放入AQS的等待获取锁的队列中 uppark第一个线程节点 三个线程按顺序轮流执行demo123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990import java.util.concurrent.CountDownLatch;import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.ReentrantLock;public class TestDemo &#123; public static void main(String[] args)&#123; ReentrantLock lock = new ReentrantLock(); final Condition c1 = lock.newCondition(); final Condition c2 = lock.newCondition(); final Condition c3 = lock.newCondition(); CountDownLatch cdl = new CountDownLatch(3); new Thread()&#123; @Override public void run() &#123; try&#123; lock.lock(); cdl.countDown(); System.out.println("线程1获取到锁，并去等待挨踢"); for(;;)&#123; c1.await(); System.out.println("线程1开始快乐的玩耍！"); Thread.sleep(1000); System.out.println("线程1踢了线程2一下！"); c2.signal(); &#125; &#125;catch (InterruptedException e) &#123; e.printStackTrace(); &#125;finally &#123; lock.unlock(); &#125; &#125; &#125;.start(); new Thread()&#123; @Override public void run() &#123; try&#123; lock.lock(); cdl.countDown(); System.out.println("线程2获取到锁，并去等待挨踢"); for(;;)&#123; c2.await(); System.out.println("线程2开始快乐的玩耍！"); Thread.sleep(1000); System.out.println("线程2踢了线程3一下！"); c3.signal(); &#125; &#125;catch (InterruptedException e) &#123; e.printStackTrace(); &#125;finally &#123; lock.unlock(); &#125; &#125; &#125;.start(); new Thread()&#123; @Override public void run() &#123; try&#123; lock.lock(); cdl.countDown(); System.out.println("线程3获取到锁，并去等待挨踢"); for(;;)&#123; c3.await(); System.out.println("线程3开始快乐的玩耍！"); Thread.sleep(1000); System.out.println("线程3踢了线程1一下！"); c1.signal(); &#125; &#125;catch (InterruptedException e) &#123; e.printStackTrace(); &#125;finally &#123; lock.unlock(); &#125; &#125; &#125;.start(); try &#123; try&#123; cdl.await(); lock.lock(); System.out.println("主线程看到三个线程都准备好挨踢了"); System.out.println("主线程踢了线程1一下"); c1.signal(); &#125;finally &#123; lock.unlock(); &#125; System.out.println("主线程释放掉锁，睡着了！"); Thread.sleep(1000000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 一个线程生产两个线程消费demo12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879import java.util.ArrayList;import java.util.List;import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.ReentrantLock;public class TestDemo &#123; public static void main(String[] args)&#123; ReentrantLock lock = new ReentrantLock(); List&lt;String&gt; products = new ArrayList&lt;&gt;(); final Condition c1 = lock.newCondition(); final Condition c2 = lock.newCondition(); new Thread()&#123; @Override public void run() &#123; try &#123; lock.lock(); for(;;)&#123; if(products.size() &gt;= 10)&#123; c2.signal(); c1.await(); &#125;else&#123; Thread.sleep(1000); String p = System.nanoTime()+""; products.add(p); System.out.println("线程1生产了产品："+p+",size="+products.size()); &#125; &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;finally &#123; lock.unlock(); &#125; &#125; &#125;.start(); new Thread()&#123; @Override public void run() &#123; try &#123; lock.lock(); for(;;)&#123; if(products.size() &lt;= 0 )&#123; c1.signal(); c2.await(); &#125;else&#123; Thread.sleep(1000); String p = products.remove(0); System.out.println("线程2消费了一个产品："+p+",size="+products.size()); &#125; &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;finally &#123; lock.unlock(); &#125; &#125; &#125;.start(); new Thread()&#123; @Override public void run() &#123; try &#123; lock.lock(); for(;;)&#123; if(products.size() &lt;= 0 )&#123; c1.signal(); c2.await(); &#125;else&#123; Thread.sleep(1000); String p = products.remove(0); System.out.println("线程3消费了一个产品："+p+",size="+products.size()); &#125; &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;finally &#123; lock.unlock(); &#125; &#125; &#125;.start(); &#125;&#125;]]></content>
      <categories>
        <category>经典</category>
      </categories>
      <tags>
        <tag>ReentrantLock</tag>
        <tag>CAS</tag>
        <tag>AQS</tag>
        <tag>LockSupport</tag>
        <tag>unsafe</tag>
        <tag>park</tag>
        <tag>unpark</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深度替换JavaBean属性的空值]]></title>
    <url>%2F2018%2F08%2F15%2F2018-08-15%E6%B7%B1%E5%BA%A6%E6%9B%BF%E6%8D%A2JavaBean%E5%B1%9E%E6%80%A7%E7%9A%84%E7%A9%BA%E5%80%BC%2F</url>
    <content type="text"><![CDATA[很多时候我们在提供给第三方调用的接口返回值中经常出现null值，有什么办法可以一次性的将返回对象中所有的null值替换成固定的值呢，这就用到了java中的反射，下面我们来实现一个可以深度替换我们返回JavaBean中值为null的字段为我们给定的值的方法 下面这个PropertyUtil工具类就可以解决深度替换的问题 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125import com.fasterxml.jackson.annotation.JsonIgnore;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.util.ClassUtils;import org.springframework.util.ReflectionUtils;import java.lang.annotation.Annotation;import java.lang.reflect.Field;import java.lang.reflect.Method;import java.lang.reflect.Modifier;import java.util.Arrays;import java.util.Iterator;import java.util.Map;import java.util.Optional;public class PropertyUtil &#123; private static final Logger logger = LoggerFactory.getLogger(PropertyUtil.class); public static &lt;T&gt; void transferNullVal(Object obj, Class&lt;T&gt; clazz, T value) &#123; try &#123; if (obj == null || obj.getClass().isPrimitive() || clazz.isPrimitive()) &#123; return; &#125; if(obj.getClass().isArray())&#123; Object[] objs = (Object[])obj; Optional.ofNullable(objs).map(os-&gt;&#123; Arrays.asList(os).stream().forEach(o-&gt;&#123; transferNullVal(o, clazz, value); &#125;); return os; &#125;); return; &#125;else if(Iterable.class.isAssignableFrom(obj.getClass()))&#123; Iterable&lt;?&gt; iterable = (Iterable&lt;?&gt;)obj; Optional.ofNullable(iterable).map(itr-&gt;&#123; Iterator&lt;?&gt; it = itr.iterator(); while(it.hasNext())&#123; Object ob = it.next(); Optional.ofNullable(ob).map(o-&gt;&#123; transferNullVal(o, clazz, value); return o; &#125;); &#125; return itr; &#125;); return; &#125;else if(Map.class.isAssignableFrom(obj.getClass()))&#123; Map&lt;?,?&gt; map = (Map&lt;?,?&gt;)obj; Optional.ofNullable(map).map(os-&gt;&#123; Optional.ofNullable(os.values()).map(mapVals-&gt;&#123; mapVals.stream().forEach(o-&gt;&#123; transferNullVal(o, clazz, value); &#125;); return mapVals; &#125;); return os; &#125;); return; &#125;else if(ClassUtils.isVisible(obj.getClass(), ClassUtils.getDefaultClassLoader().getParent()))&#123; return; &#125; Field[] fields = obj.getClass().getDeclaredFields(); if (fields == null || fields.length == 0) &#123; return; &#125; for (Field f : fields) &#123; if (f.getType() == clazz) &#123; if (!nullValue(f, obj)) &#123; continue; &#125; if (checkIgnore(f) || checkStaticField(f) || !checkGetMethodPublic(f, obj.getClass())) &#123; continue; &#125; boolean isAccess = f.isAccessible(); ReflectionUtils.makeAccessible(f); ReflectionUtils.setField(f, obj, value); f.setAccessible(isAccess); &#125; else &#123; boolean s = f.isAccessible(); ReflectionUtils.makeAccessible(f); Object val = ReflectionUtils.getField(f, obj); transferNullVal(val, clazz, value); f.setAccessible(s); &#125; &#125; &#125; catch (Exception e) &#123; logger.error("对象属性转换失败！", e); &#125; &#125; private static boolean nullValue(Field f, Object obj) &#123; boolean isAccess = f.isAccessible(); ReflectionUtils.makeAccessible(f); Object val = ReflectionUtils.getField(f, obj); f.setAccessible(isAccess); return val == null; &#125; private static boolean checkIgnore(Field f) &#123; Annotation anno = f.getAnnotation(JsonIgnore.class); return anno != null; &#125; private static boolean checkStaticField(Field f) &#123; return Modifier.isStatic(f.getModifiers()); &#125; private static boolean checkGetMethodPublic(Field f, Class&lt;? extends Object&gt; clazz) &#123; if (f == null) &#123; return false; &#125; String pro = f.getName(); String fuPro = String.valueOf(pro.charAt(0)).toUpperCase() + pro.substring(1); boolean isBool = f.getType() == boolean.class; try &#123; if (!isBool) &#123; String getMethodName = "get" + fuPro; Method getMethod = clazz.getMethod(getMethodName, (Class[]) null); return Modifier.isPublic(getMethod.getModifiers()); &#125; else &#123; String isMethodName = "is" + fuPro; Method isMethod = clazz.getMethod(isMethodName, (Class[]) null); return Modifier.isPublic(isMethod.getModifiers()); &#125; &#125; catch (NoSuchMethodException e) &#123; return false; &#125; &#125;&#125; 测试Demo12345678910111213141516171819202122232425import com.google.gson.Gson;public class Test &#123; public static void main(String[] args) &#123; Person p = new Person(); p.setName("张三"); PropertyUtil.transferNullVal(p, Integer.class, 28); System.out.println(new Gson().toJson(p)); &#125; public static class Person &#123; private String name; private Integer age; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; &#125;&#125; 打印结果如下： {“name”:”张三”,”age”:28}]]></content>
      <categories>
        <category>小工具</category>
      </categories>
      <tags>
        <tag>类加载器</tag>
        <tag>深度替换</tag>
        <tag>属性为空</tag>
        <tag>字段为空</tag>
        <tag>Java反射</tag>
        <tag>ClassUtils</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用注解配置Controller的拦截器]]></title>
    <url>%2F2018%2F08%2F15%2F2018-08-15%E4%BD%BF%E7%94%A8%E6%B3%A8%E8%A7%A3%E9%85%8D%E7%BD%AEController%E7%9A%84%E6%8B%A6%E6%88%AA%E5%99%A8%2F</url>
    <content type="text"><![CDATA[上篇文章我们解决了怎么使用spring的扫描注入功能将指定包下面的拦截器注入到容器中，这篇文章我们将要解决如何更细粒度的配置请求对应的拦截器，那么我们首先想到了注解，基于注解配置可以让不同的业务请求对应到不同的拦截器调用链，好了，正文开始 我们知道要定义一个拦截器需要继承HandlerInterceptorAdapter抽象类，那么我么可以在定义一个抽象类来继承这个HandlerInterceptorAdapter，其它拦截器来继承这个抽象类拦截器，以达到拦截器调用的统一控制 第一步，创建AbstractHandlerInterceptor.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166import java.lang.annotation.Annotation;import javax.annotation.PostConstruct;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.web.method.HandlerMethod;import org.springframework.web.servlet.ModelAndView;import org.springframework.web.servlet.handler.HandlerInterceptorAdapter;public abstract class AbstractHandlerInterceptor extends HandlerInterceptorAdapter &#123; private static Logger logger = LoggerFactory.getLogger(AbstractHandlerInterceptor.class); /** * 覆写afterCompletion，首先判断是否通过注解校验，通过后才执行相应的拦截器逻辑 */ @Override public final void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; if (isForAction(handler)) &#123; afterView(request, response, handler, ex); &#125; &#125; /** * 子类可以实现该方法，该方法替代原HandlerInterceptorAdapter中的afterCompletion函数 * * @param request * @param response * @param handler * @param ex * @throws Exception */ protected abstract void afterView(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception; @Override public final void afterConcurrentHandlingStarted(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; // TODO Auto-generated method stub super.afterConcurrentHandlingStarted(request, response, handler); &#125; /** * 覆写postHandle，首先判断是否通过注解校验，通过后才执行相应的拦截器逻辑 */ @Override public final void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; if (isForAction(handler)) &#123; afterHandle(request, response, handler, modelAndView); &#125; &#125; /** * 子类可以实现该方法，该方法替代原HandlerInterceptorAdapter中的postHandle函数 * * @param request * @param response * @param handler * @param modelAndView * @throws Exception */ protected abstract void afterHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception; /** * 覆写preHandle */ @Override public final boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; logger.debug("interceptor className==&#123;&#125;", this.getClass().getName()); if (!isForAction(handler)) &#123; return true; &#125; return beforeHandle(request, response, handler); &#125; /** * 子类需要重新实现该方法,设置该拦截器为RequiredAnnotation类型 * * @return */ protected abstract Class&lt;? extends Annotation&gt; getRequiredAnnotationClass(); /** * 子类需要重新实现该方法，设置该拦截器为DenyAnnotation类型 * * @return */ protected abstract Class&lt;? extends Annotation&gt; getDenyAnnotationClass(); /** * 子类可以实现该方法，该方法替代原HandlerInterceptorAdapter中的preHandle函数 * * @param request * @param response * @param handler * @return * @throws Exception */ public abstract boolean beforeHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception; /** * 判断该请求是否需要走这个拦截器校验 * * @param handler * @return */ public final boolean isForAction(Object handler) &#123; // 如果该拦截器是RequiredAnnotaion类型，那么Controller中必须有该配置才会走这个拦截器校验 if (!checkRequiredAnnotations(handler)) &#123; return false; &#125; // 如果该拦截器是DenyAnnotation类型，那么Controller中必须有该配置才会不走这个拦截器校验 if (checkDenyAnnotations(handler)) &#123; return false; &#125; return true; &#125; /** * 判断Controller中有没有RequiredAnnotation的注解 * * @param handler * @return */ private boolean checkRequiredAnnotations(Object handler) &#123; Class&lt;? extends Annotation&gt; requiredAnnotation = getRequiredAnnotationClass(); if (requiredAnnotation == null) &#123; return true; &#125; HandlerMethod handlerMethod = (HandlerMethod) handler; Class&lt;?&gt; controllerClazz = handlerMethod.getBeanType(); if (handlerMethod.getMethodAnnotation(requiredAnnotation) != null || controllerClazz.getAnnotation(requiredAnnotation) != null) &#123; return true; &#125; return false; &#125; /** * 判断Controller中有没有DenyAnnotation的注解 * * @param handler * @return */ private boolean checkDenyAnnotations(Object handler) &#123; Class&lt;? extends Annotation&gt; denyAnnotation = getDenyAnnotationClass(); if (denyAnnotation == null) &#123; return false; &#125; HandlerMethod handlerMethod = (HandlerMethod) handler; Class&lt;?&gt; controllerClazz = handlerMethod.getBeanType(); if (handlerMethod.getMethodAnnotation(denyAnnotation) != null || controllerClazz.getAnnotation(denyAnnotation) != null) &#123; return true; &#125; return false; &#125; @PostConstruct public void postConstruct() &#123; Class&lt;? extends Annotation&gt; denyAnnotation = getDenyAnnotationClass(); Class&lt;? extends Annotation&gt; requiredAnnotation = getRequiredAnnotationClass(); if (denyAnnotation != null &amp;&amp; requiredAnnotation != null) &#123; throw new RuntimeException("Only one annotation can be used for the implementation class configuration"); &#125; else if (denyAnnotation == null &amp;&amp; requiredAnnotation == null) &#123; throw new RuntimeException("Annotations for implementation class configuration cannot be empty"); &#125; &#125;&#125; 第二步，创建拦截器LoginInterceptor.java和ParamInterceptor.java123456789101112131415161718192021222324252627282930313233343536373839import java.lang.annotation.Annotation;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.web.servlet.ModelAndView;import com.mgl.interceptor.annotation.DenyLoginAnnotation;import com.mgl.interceptor.annotation.Mapping;import com.mgl.interceptor.base.AbstractHandlerInterceptor;// 可以配置Mapping，也可以不配@Mapping("/test/sayHello")public class LoginInterceptor extends AbstractHandlerInterceptor &#123; private static Logger logger = LoggerFactory.getLogger(LoginInterceptor.class); @Override protected Class&lt;? extends Annotation&gt; getRequiredAnnotationClass() &#123; return null; &#125; @Override protected Class&lt;? extends Annotation&gt; getDenyAnnotationClass() &#123; return DenyLoginAnnotation.class; &#125; @Override public boolean beforeHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; logger.debug("这里进行登录校验！"); return true; &#125; @Override protected void afterView(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; &#125; @Override protected void afterHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; // TODO Auto-generated method stub &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435import java.lang.annotation.Annotation;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.web.servlet.ModelAndView;import com.mgl.interceptor.annotation.Mapping;import com.mgl.interceptor.annotation.ParamVerifyAnnotation;import com.mgl.interceptor.base.AbstractHandlerInterceptor;// 可以配置Mapping，也可以不配@Mapping("/test/sayHello")public class ParamInterceptor extends AbstractHandlerInterceptor &#123; private static Logger logger = LoggerFactory.getLogger(ParamInterceptor.class); @Override protected Class&lt;? extends Annotation&gt; getRequiredAnnotationClass() &#123; return ParamVerifyAnnotation.class; &#125; @Override protected Class&lt;? extends Annotation&gt; getDenyAnnotationClass() &#123; return null; &#125; @Override public boolean beforeHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; logger.debug("这里进行参数校验！"); return true; &#125; @Override protected void afterView(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; &#125; @Override protected void afterHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; // TODO Auto-generated method stub &#125;&#125; 第三步，创建拦截器需要用到的注解类DenyLoginAnnotation.java和ParamVerifyAnnotation.java12345678910111213import java.lang.annotation.Documented;import java.lang.annotation.ElementType;import java.lang.annotation.Inherited;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Documented@Inherited@Target(&#123; ElementType.METHOD, ElementType.TYPE &#125;)@Retention(RetentionPolicy.RUNTIME)public @interface DenyLoginAnnotation &#123; boolean check() default true;&#125; 12345678910111213import java.lang.annotation.Documented;import java.lang.annotation.ElementType;import java.lang.annotation.Inherited;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Documented@Inherited@Target(&#123; ElementType.METHOD, ElementType.TYPE &#125;)@Retention(RetentionPolicy.RUNTIME)public @interface ParamVerifyAnnotation &#123; boolean check() default true;&#125; 第四部，Controller中配置123456789101112131415import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;import com.mgl.interceptor.annotation.DenyLoginAnnotation;@Controller@RequestMapping("/test")public class TestController &#123; @RequestMapping("/sayHello") @ResponseBody // @ParamVerifyAnnotation // 添加这个注解可以走ParamInterceptor @DenyLoginAnnotation // 添加这个注解可以控制不走LoginInterceptor public String testCrossDomain() &#123; return "hello world!"; &#125;&#125; 好了，上面代码实现完成，我们可以通过之前的拦截器扫描注入功能，将这些拦截器都注入到容器了1&lt;custom:interceptor-scan base-package="com.mgl.interceptor" base-class="org.springframework.web.servlet.handler.HandlerInterceptorAdapter,com.mgl.interceptor.base.AbstractHandlerInterceptor" /&gt;]]></content>
      <categories>
        <category>经典</category>
      </categories>
      <tags>
        <tag>Interceptor</tag>
        <tag>注解配置拦截器</tag>
        <tag>Controller配置拦截器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Interceptor自动扫描注入]]></title>
    <url>%2F2018%2F08%2F14%2F2018-08-14%E6%8B%A6%E6%88%AA%E5%99%A8%E8%87%AA%E5%8A%A8%E6%89%AB%E6%8F%8F%E6%B3%A8%E5%85%A5%2F</url>
    <content type="text"><![CDATA[在项目开发中，我们经常会用到spring的拦截器功能，但是在xml配置又很麻烦，拦截器调用顺序又不好控制，所以我们在想，是不是可以使用spring的扫描功能，将拦截器按照顺序注入进去，下面我们来实现这个功能 第一步 在resourcers目录下创建下面两个文件 spring.handlers文件 1http\://www.menggl.com/schema/tools=com.test.custom.config.handler.CustomHandler spring.schemas文件 1http\://www.menggl.com/schema/custom/interceptor-scan.xsd=com/test/custom/config/handler/interceptor-scan.xsd 第二步，在com.mgl.custom.config.handler目录下创建xsd文件12345678910111213141516171819202122&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;xsd:schema xmlns="http://www.mgl.com/schema/tools" xmlns:xsd="http://www.w3.org/2001/XMLSchema" targetNamespace="http://www.mgl.com/schema/tools" xmlns:beans="http://www.springframework.org/schema/beans" xmlns:tool="http://www.springframework.org/schema/tool" elementFormDefault="qualified" attributeFormDefault="unqualified"&gt; &lt;!-- &lt;xsd:import namespace="http://www.springframework.org/schema/beans" schemaLocation="http://www.springframework.org/schema/beans/spring-beans.xsd"/&gt; &lt;xsd:import namespace="http://www.springframework.org/schema/tool" schemaLocation="http://www.springframework.org/schema/tool/spring-tool.xsd"/&gt; --&gt; &lt;xsd:element name="interceptor-scan"&gt; &lt;xsd:complexType&gt; &lt;xsd:attribute name="base-package" type="whiteSpaceTrimType" use="required"/&gt; &lt;xsd:attribute name="base-class" type="whiteSpaceTrimType" use="required"/&gt; &lt;/xsd:complexType&gt; &lt;/xsd:element&gt; &lt;xsd:simpleType name="whiteSpaceTrimType"&gt; &lt;xsd:restriction base="xsd:string"&gt; &lt;xsd:whiteSpace value="collapse"&gt;&lt;/xsd:whiteSpace&gt; &lt;/xsd:restriction&gt; &lt;/xsd:simpleType&gt;&lt;/xsd:schema&gt; 第三步 在com.mgl.custom.config.handler目录下创建CustomHandler.java12345678import org.springframework.beans.factory.xml.NamespaceHandlerSupport;import com.mgl.custom.config.parser.CustomInterceptorParser;public class CustomHandler extends NamespaceHandlerSupport &#123; @Override public void init() &#123; registerBeanDefinitionParser("interceptor-scan", new CustomInterceptorParser()); &#125;&#125; 第四步，在com.mgl.custom.config.parser目录下创建CustomInterceptorParser.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219import java.io.IOException;import java.util.ArrayList;import java.util.List;import java.util.NavigableSet;import java.util.TreeMap;import org.springframework.beans.factory.config.BeanDefinition;import org.springframework.beans.factory.config.BeanDefinitionHolder;import org.springframework.beans.factory.parsing.BeanComponentDefinition;import org.springframework.beans.factory.parsing.CompositeComponentDefinition;import org.springframework.beans.factory.support.AbstractBeanDefinition;import org.springframework.beans.factory.support.BeanDefinitionReaderUtils;import org.springframework.beans.factory.support.ManagedList;import org.springframework.beans.factory.support.RootBeanDefinition;import org.springframework.beans.factory.xml.BeanDefinitionParser;import org.springframework.beans.factory.xml.ParserContext;import org.springframework.beans.factory.xml.XmlReaderContext;import org.springframework.context.ConfigurableApplicationContext;import org.springframework.core.env.Environment;import org.springframework.core.io.Resource;import org.springframework.core.io.ResourceLoader;import org.springframework.core.io.support.ResourcePatternResolver;import org.springframework.core.io.support.ResourcePatternUtils;import org.springframework.core.type.AnnotationMetadata;import org.springframework.core.type.ClassMetadata;import org.springframework.core.type.classreading.CachingMetadataReaderFactory;import org.springframework.core.type.classreading.MetadataReader;import org.springframework.core.type.classreading.MetadataReaderFactory;import org.springframework.util.ClassUtils;import org.springframework.util.MultiValueMap;import org.springframework.util.StringUtils;import org.springframework.web.servlet.handler.MappedInterceptor;import org.w3c.dom.Element;public class CustomInterceptorParser implements BeanDefinitionParser &#123; private static final String BASE_PACKAGE_ATTRIBUTE = "base-package"; private static final String BASE_CLASS_ATTRIBUTE = "base-class"; private static final String ORDER_ANNOTATION = "org.springframework.core.annotation.Order"; private static final String MAPPING_ANNOTATION = "com.mgl.interceptor.annotation.Mapping"; private static final String EXCLUDE_MAPPING_ANNOTATION = "com.mgl.interceptor.annotation.ExcludeMapping"; private static final String DEFAULT_MAPPING_PATTERN = "/**"; private static final String[] DEFAULT_EXCLUDE_MAPPING_PATTERN = new String[] &#123; "/static/*" &#125;; private static final String RESOURCE_PATTERN = "**/*.class"; private static final int DEFAULT_ORDER = 100; private XmlReaderContext readerContext; private ResourcePatternResolver resourcePatternResolver; private Environment environment; private ResourceLoader resourceLoader; private MetadataReaderFactory metadataReaderFactory; @Override public BeanDefinition parse(Element element, ParserContext parserContext) &#123; this.readerContext = parserContext.getReaderContext(); this.environment = this.readerContext.getEnvironment(); this.resourcePatternResolver = ResourcePatternUtils.getResourcePatternResolver(this.readerContext.getResourceLoader()); this.resourceLoader = readerContext.getResourceLoader(); this.metadataReaderFactory = new CachingMetadataReaderFactory(resourceLoader); CompositeComponentDefinition compDefinition = new CompositeComponentDefinition(element.getTagName(), parserContext.extractSource(element)); parserContext.pushContainingComponent(compDefinition); String basePackage = element.getAttribute(BASE_PACKAGE_ATTRIBUTE); basePackage = this.environment.resolvePlaceholders(basePackage); String[] basePackages = StringUtils.tokenizeToStringArray(basePackage, ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS); String baseClass = element.getAttribute(BASE_CLASS_ATTRIBUTE); List&lt;String&gt; baseTypes = this.parseBaseClass(baseClass); for (String bp : basePackages) &#123; String resolvePackage = ClassUtils.convertClassNameToResourcePath(this.environment.resolveRequiredPlaceholders(bp)); String packageSearchPath = ResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX + resolvePackage + '/' + RESOURCE_PATTERN; try &#123; Resource[] resources = this.resourcePatternResolver.getResources(packageSearchPath); resources = sort(resources); for (Resource resource : resources) &#123; MetadataReader metadataReader = metadataReaderFactory.getMetadataReader(resource); ClassMetadata classMetadata = metadataReader.getClassMetadata(); if (classMetadata.isAbstract() || classMetadata.isInterface() || !classMetadata.hasSuperClass() || !validType(classMetadata, baseTypes)) &#123; continue; &#125; String className = classMetadata.getClassName(); RootBeanDefinition mappedInterceptorDef = new RootBeanDefinition(MappedInterceptor.class); mappedInterceptorDef.setSource(resource); mappedInterceptorDef.setRole(BeanDefinition.ROLE_INFRASTRUCTURE); ManagedList&lt;String&gt; includePatterns = new ManagedList&lt;String&gt;(1); String includePattern = getIncludePattern(metadataReader); if (!StringUtils.isEmpty(includePattern)) &#123; includePatterns.add(includePattern); &#125; else &#123; includePatterns.add(DEFAULT_MAPPING_PATTERN); &#125; ManagedList&lt;String&gt; excludePatterns = new ManagedList&lt;String&gt;(2); String[] excludePattern = getExcludePatterns(metadataReader); if (excludePattern != null &amp;&amp; excludePattern.length &gt; 0) &#123; for (String ep : excludePattern) &#123; excludePatterns.add(ep); &#125; &#125; else &#123; for (String ep : DEFAULT_EXCLUDE_MAPPING_PATTERN) &#123; excludePatterns.add(ep); &#125; &#125; mappedInterceptorDef.getConstructorArgumentValues().addIndexedArgumentValue(0, includePatterns); mappedInterceptorDef.getConstructorArgumentValues().addIndexedArgumentValue(1, excludePatterns); AbstractBeanDefinition beanDefinition = BeanDefinitionReaderUtils.createBeanDefinition(null, className, this.readerContext.getBeanClassLoader()); String beanName = this.readerContext.generateBeanName(beanDefinition); String beanClassName = beanDefinition.getBeanClassName(); List&lt;String&gt; aliases = new ArrayList&lt;&gt;(); if (beanClassName != null &amp;&amp; beanName.startsWith(beanClassName) &amp;&amp; beanName.length() &gt; beanClassName.length() &amp;&amp; !this.readerContext.getRegistry().isBeanNameInUse(beanClassName)) &#123; aliases.add(beanClassName); &#125; String[] aliasesArray = StringUtils.toStringArray(aliases); BeanDefinitionHolder interceptorBean = new BeanDefinitionHolder(beanDefinition, beanName, aliasesArray); mappedInterceptorDef.getConstructorArgumentValues().addIndexedArgumentValue(2, interceptorBean); String curentBeanName = parserContext.getReaderContext().registerWithGeneratedName(mappedInterceptorDef); parserContext.registerComponent(new BeanComponentDefinition(mappedInterceptorDef, curentBeanName)); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; parserContext.popAndRegisterContainingComponent(); return null; &#125; private List&lt;String&gt; parseBaseClass(String baseClass) &#123; if (StringUtils.isEmpty(baseClass)) &#123; return new ArrayList&lt;&gt;(); &#125; String[] baseTypes = baseClass.split(","); List&lt;String&gt; retTypes = new ArrayList&lt;&gt;(); if (baseTypes != null &amp;&amp; baseTypes.length &gt; 0) &#123; for (String type : baseTypes) &#123; if (!StringUtils.isEmpty(type)) &#123; retTypes.add(type); &#125; &#125; &#125; return retTypes; &#125; private String[] getExcludePatterns(MetadataReader metadataReader) &#123; List&lt;String&gt; ret = new ArrayList&lt;&gt;(); AnnotationMetadata annotationMetadata = metadataReader.getAnnotationMetadata(); MultiValueMap&lt;String, Object&gt; excludeMappingAttrs = annotationMetadata.getAllAnnotationAttributes(EXCLUDE_MAPPING_ANNOTATION); if (excludeMappingAttrs != null &amp;&amp; excludeMappingAttrs.size() &gt; 0) &#123; List&lt;Object&gt; objs = excludeMappingAttrs.get("value"); for (Object obj : objs) &#123; ret.add((String) obj); &#125; return ret.toArray(new String[ret.size()]); &#125; return null; &#125; private String getIncludePattern(MetadataReader metadataReader) &#123; AnnotationMetadata annotationMetadata = metadataReader.getAnnotationMetadata(); MultiValueMap&lt;String, Object&gt; mappingAttrs = annotationMetadata.getAllAnnotationAttributes(MAPPING_ANNOTATION); if (mappingAttrs != null &amp;&amp; mappingAttrs.size() &gt; 0) &#123; List&lt;Object&gt; objs = mappingAttrs.get("value"); String value = (String) objs.get(0); return StringUtils.isEmpty(value) ? null : value; &#125; return null; &#125; private boolean validType(ClassMetadata classMetadata, List&lt;String&gt; baseTypes) &#123; String superClassName = classMetadata.getSuperClassName(); String[] interfaceNames = classMetadata.getInterfaceNames(); for (String type : baseTypes) &#123; if (superClassName != null) &#123; if (superClassName.contains(type)) &#123; return true; &#125; &#125; if (interfaceNames != null &amp;&amp; interfaceNames.length &gt; 0) &#123; for (String interfaceName : interfaceNames) &#123; if (type.equalsIgnoreCase(interfaceName)) &#123; return true; &#125; &#125; &#125; &#125; return false; &#125; private Resource[] sort(Resource[] resources) throws IOException &#123; List&lt;Resource&gt; ret = new ArrayList&lt;Resource&gt;(); TreeMap&lt;Integer, List&lt;Resource&gt;&gt; map = new TreeMap&lt;&gt;(); for (Resource resource : resources) &#123; MetadataReader metadataReader = this.metadataReaderFactory.getMetadataReader(resource); AnnotationMetadata annotationMetadata = metadataReader.getAnnotationMetadata();// getClassMetadata(); MultiValueMap&lt;String, Object&gt; orderAttrs = annotationMetadata.getAllAnnotationAttributes(ORDER_ANNOTATION); if (orderAttrs != null) &#123; List&lt;Object&gt; values = orderAttrs.get("value"); int order = (int) values.get(0); List&lt;Resource&gt; resourceList = map.get(order); if (resourceList == null) &#123; resourceList = new ArrayList&lt;Resource&gt;(); map.put(order, resourceList); &#125; resourceList.add(resource); &#125; else &#123; List&lt;Resource&gt; resourceList = map.get(DEFAULT_ORDER); if (resourceList == null) &#123; resourceList = new ArrayList&lt;Resource&gt;(); map.put(DEFAULT_ORDER, resourceList); &#125; resourceList.add(resource); &#125; &#125; NavigableSet&lt;Integer&gt; set = map.descendingKeySet(); for (Integer key : set) &#123; ret.addAll(map.get(key)); &#125; return ret.toArray(new Resource[ret.size()]); &#125;&#125; 第五步，创建上面的parser需要的注解类Mapping.java和ExcludeMapping.java12345678910111213import java.lang.annotation.Documented;import java.lang.annotation.ElementType;import java.lang.annotation.Inherited;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Documented@Inherited@Target(&#123; ElementType.METHOD, ElementType.TYPE &#125;)@Retention(RetentionPolicy.RUNTIME)public @interface Mapping &#123; String value() default "/**";&#125; 12345678910111213import java.lang.annotation.Documented;import java.lang.annotation.ElementType;import java.lang.annotation.Inherited;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Documented@Inherited@Target(&#123;ElementType.METHOD,ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)public @interface ExcludeMapping &#123; String[] value();&#125; 第六步 在springMVC配置文件中配置命名空间及包扫描1234567xmlns:custom="http://www.mgl.com/schema/tools" xsi:schemaLocation="http://www.mgl.com/schema/tools http://www.mgl.com/schema/custom/interceptor-scan.xsd"&lt;mvc:annotation-driven /&gt;&lt;custom:interceptor-scan base-package="com.mgl.interceptor" base-class="org.springframework.web.servlet.handler.HandlerInterceptorAdapter" /&gt; 好了，我们只要将Interceptor放入com.mgl.interceptor包目录下，就可以自动注入了，还可以根据@Order进行拦截器的调用顺序控制]]></content>
      <categories>
        <category>经典</category>
      </categories>
      <tags>
        <tag>Interceptor</tag>
        <tag>自动扫描</tag>
        <tag>注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Filter实现响应结果打印]]></title>
    <url>%2F2018%2F06%2F10%2F2018-06-10Filter%E5%AE%9E%E7%8E%B0%E5%93%8D%E5%BA%94%E7%BB%93%E6%9E%9C%E6%89%93%E5%8D%B0%E5%92%8C%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E5%90%8D%E5%A4%A7%E5%B0%8F%E5%86%99%E4%B8%8D%E6%95%8F%E6%84%9F%2F</url>
    <content type="text"><![CDATA[在实际业务开发中，我们经常需要打印响应结果日志，方便以后问题跟踪和处理，但是我们是不能直接从response的输出流中获取结果，为了解决这个问题，我们可以在拦截器中使用HttpServletResponseWrapper实现类替换HttpServletResponse，将输出的结果保存下来，然后在日志打印的地方直接将结果拿出来打印就可以了 同样，有时候是历史原因导致接口中参数名不是按驼峰规则命名，接口移植重写过程中我们还要照顾旧渠道调用我们接口时使用的非驼峰格式的参数名，这样就导致获取参数值时的混乱问题，为了统一解决这个问题，我们也同样可以在拦截器中使用HttpServletRequestWrapper实现类替换HttpServletRequest，从而可以实现参数值获取时的参数名大小写不敏感。 以下是java代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301import java.io.BufferedWriter;import java.io.ByteArrayOutputStream;import java.io.IOException;import java.io.InterruptedIOException;import java.io.OutputStreamWriter;import java.io.PrintWriter;import java.io.Writer;import java.nio.charset.StandardCharsets;import java.util.Enumeration;import java.util.HashMap;import java.util.Map;import javax.servlet.FilterChain;import javax.servlet.ServletException;import javax.servlet.ServletOutputStream;import javax.servlet.WriteListener;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletRequestWrapper;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpServletResponseWrapper;import org.apache.commons.lang3.StringUtils;import org.springframework.web.filter.OncePerRequestFilter;public class RequestResponseFilter extends OncePerRequestFilter &#123; @Override protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException &#123; filterChain.doFilter(new RequestParameterWrapper(request), new ResponseContentWrapper(response)); &#125; private final class RequestParameterWrapper extends HttpServletRequestWrapper &#123; private Map&lt;String, String&gt; keyMap = new HashMap&lt;&gt;(); private boolean repeatKey = false; public RequestParameterWrapper(HttpServletRequest request) &#123; super(request); Enumeration&lt;String&gt; keys = request.getParameterNames(); while (keys.hasMoreElements()) &#123; String key = keys.nextElement(); String keyUpper = key.toUpperCase(); if (keyMap.containsKey(keyUpper)) &#123; this.repeatKey = true; break; &#125; else &#123; this.keyMap.put(keyUpper, key); &#125; &#125; &#125; @Override public String getParameter(String name) &#123; if (StringUtils.isEmpty(name)) &#123; return null; &#125; String realName = this.getRealName(name); return super.getParameter(realName); &#125; @Override public String[] getParameterValues(String name) &#123; if (StringUtils.isEmpty(name)) &#123; return null; &#125; String realName = this.getRealName(name); return super.getParameterValues(realName); &#125; private String getRealName(String name) &#123; if (this.repeatKey) &#123; return name; &#125; String upperKey = name.toUpperCase(); if (keyMap.containsKey(upperKey)) &#123; return keyMap.get(upperKey); &#125; return name; &#125; &#125; public final class ResponseContentWrapper extends HttpServletResponseWrapper &#123; private ResponsePrintWriter responsePrintWriter; private ResponseOutputStream responseOutputStream; private String content = null; public ResponseContentWrapper(HttpServletResponse servletResponse) &#123; super(servletResponse); this.responsePrintWriter = new ResponsePrintWriter(new ByteArrayOutputStream(), servletResponse); this.responseOutputStream = new ResponseOutputStream(servletResponse); &#125; @Override protected void finalize() throws Throwable &#123; super.finalize(); this.responsePrintWriter.close(); &#125; public String getContent() throws IOException &#123; try &#123; if (content != null) &#123; return content; &#125; this.responsePrintWriter.flush(); ByteArrayOutputStream output = this.responsePrintWriter.getOutput(); this.content = new String(output.toByteArray(), StandardCharsets.UTF_8); if (StringUtils.isEmpty(content)) &#123; this.responseOutputStream.flush(); this.content = this.responseOutputStream.getContent(); &#125; return content; &#125; catch (Exception e) &#123; return "UnsupportedEncoding"; &#125; &#125; @Override public PrintWriter getWriter() throws IOException &#123; return responsePrintWriter; &#125; @Override public ServletOutputStream getOutputStream() throws IOException &#123; return this.responseOutputStream; &#125; &#125; private final class ResponsePrintWriter extends PrintWriter &#123; private HttpServletResponse servletResponse; private ByteArrayOutputStream byteArrayOutputStream; private Writer writer; private boolean startWrite = false; public ResponsePrintWriter(ByteArrayOutputStream byteArrayOutputStream, HttpServletResponse servletResponse) &#123; super(byteArrayOutputStream); this.servletResponse = servletResponse; this.byteArrayOutputStream = byteArrayOutputStream; this.writer = new BufferedWriter(new OutputStreamWriter(byteArrayOutputStream)); &#125; public ByteArrayOutputStream getOutput() &#123; return this.byteArrayOutputStream; &#125; @Override public void write(String s) &#123; this.write(s, 0, s.length()); &#125; @Override public void write(String s, int off, int len) &#123; byte[] bytes = s.getBytes(StandardCharsets.UTF_8); this.byteArrayOutputStream.write(bytes, off, len); if (!startWrite) &#123; this.servletResponse.setContentLength(-1); this.startWrite = true; &#125; try &#123; this.servletResponse.getWriter().write(s, off, len); &#125; catch (IOException e) &#123; logger.error("write failed,", e); &#125; &#125; @Override public void write(char[] buf) &#123; this.write(buf, 0, buf.length); &#125; @Override public void write(char[] buf, int off, int len) &#123; try &#123; this.writer.write(buf, off, len); &#125; catch (InterruptedIOException x) &#123; Thread.currentThread().interrupt(); &#125; catch (IOException x) &#123; logger.error("HttpServletResponse write failed!"); &#125; if (!startWrite) &#123; this.servletResponse.setContentLength(-1); this.startWrite = true; &#125; try &#123; this.servletResponse.getWriter().write(buf, off, len); &#125; catch (IOException e) &#123; logger.error("write failed,", e); &#125; &#125; @Override public void write(int c) &#123; this.byteArrayOutputStream.write(c); if (!startWrite) &#123; this.servletResponse.setContentLength(-1); this.startWrite = true; &#125; try &#123; this.servletResponse.getWriter().write(c); &#125; catch (IOException e) &#123; logger.error("write failed,", e); &#125; &#125; &#125; private class ResponseOutputStream extends ServletOutputStream &#123; private HttpServletResponse servletResponse; private ByteArrayOutputStream byteArrayOutputStream; private boolean startWrite = false; public ResponseOutputStream(HttpServletResponse servletResponse) &#123; this.servletResponse = servletResponse; this.byteArrayOutputStream = new ByteArrayOutputStream(); &#125; @Override public void write(int b) throws IOException &#123; this.servletResponse.getOutputStream().write(b); &#125; @Override public void print(String s) throws IOException &#123; this.byteArrayOutputStream.write(s.getBytes(StandardCharsets.UTF_8)); if (!startWrite) &#123; this.servletResponse.setContentLength(-1); this.startWrite = true; &#125; try &#123; this.servletResponse.getOutputStream().print(s); &#125; catch (IOException e) &#123; logger.error("write failed,", e); &#125; &#125; @Override public void println(String s) throws IOException &#123; this.byteArrayOutputStream.write(s.getBytes(StandardCharsets.UTF_8)); if (!startWrite) &#123; this.servletResponse.setContentLength(-1); this.startWrite = true; &#125; try &#123; this.servletResponse.getOutputStream().println(s); &#125; catch (IOException e) &#123; logger.error("write failed,", e); &#125; &#125; @Override public void write(byte[] b) throws IOException &#123; this.byteArrayOutputStream.write(b, 0, b.length); if (!startWrite) &#123; this.servletResponse.setContentLength(-1); this.startWrite = true; &#125; try &#123; this.servletResponse.getOutputStream().write(b); &#125; catch (IOException e) &#123; logger.error("write failed,", e); &#125; &#125; @Override public void write(byte[] b, int off, int len) throws IOException &#123; if (!startWrite) &#123; this.servletResponse.setContentLength(-1); this.startWrite = true; &#125; if (b == null) &#123; throw new NullPointerException(); &#125; else if ((off &lt; 0) || (off &gt; b.length) || (len &lt; 0) || ((off + len) &gt; b.length) || ((off + len) &lt; 0)) &#123; throw new IndexOutOfBoundsException(); &#125; else if (len == 0) &#123; return; &#125; len = Math.min(b.length - off, len); this.byteArrayOutputStream.write(b, off, len); try &#123; this.servletResponse.getOutputStream().write(b, off, len); &#125; catch (IOException e) &#123; logger.error("write failed,", e); &#125; &#125; public String getContent() &#123; return new String(this.byteArrayOutputStream.toByteArray(), StandardCharsets.UTF_8); &#125; @Override public boolean isReady() &#123; // TODO Auto-generated method stub return false; &#125; @Override public void setWriteListener(WriteListener arg0) &#123; // TODO Auto-generated method stub &#125; &#125;&#125; web.xml配置12345678&lt;filter&gt; &lt;filter-name&gt;requestResponseFilter&lt;/filter-name&gt; &lt;filter-class&gt;com.mgl.filter.RequestResponseFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;requestResponseFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 使用方法123if (ResponseContentWrapper.class.isAssignableFrom(response.getClass())) &#123; logger.info("响应结果为：&#123;&#125;", ((ResponseContentWrapper) response).getContent());&#125;]]></content>
      <categories>
        <category>经典</category>
      </categories>
      <tags>
        <tag>Filter</tag>
        <tag>Log</tag>
        <tag>响应结果打印</tag>
        <tag>HttpServletResponseWrapper</tag>
        <tag>HttpServletRequestWrapper</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[zookeeper实现分布式锁和热备]]></title>
    <url>%2F2018%2F05%2F18%2F2018-05-18zookeeper%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%2F</url>
    <content type="text"><![CDATA[使用zookeeper实现分布式锁可以完美解决Redis实现分布式锁带来的弊端 基本流程： 往zookeeper中的某个永久节点上创建一个临时节点 判断创建的临时节点是否是最小的节点 如果是最小的节点，说明当前节点拿到了锁 如果不是最小节点，监听当前节点的上一个节点，如果上一个节点被删除，触发当前节点的线程去获取锁 下面是zookeeper实现分布式锁的具体代码逻辑 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656import com.google.common.collect.Maps;import com.jzg.api.util.StringUtil;import com.jzg.api.util.ThreadLocalUtil;import org.apache.commons.lang3.StringUtils;import org.apache.curator.framework.CuratorFramework;import org.apache.curator.framework.CuratorFrameworkFactory;import org.apache.curator.framework.recipes.cache.TreeCache;import org.apache.curator.framework.recipes.cache.TreeCacheEvent;import org.apache.curator.framework.recipes.cache.TreeCacheListener;import org.apache.curator.retry.ExponentialBackoffRetry;import org.apache.zookeeper.CreateMode;import org.apache.zookeeper.KeeperException;import org.apache.zookeeper.data.Stat;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.util.CollectionUtils;import javax.annotation.PostConstruct;import java.util.Collections;import java.util.List;import java.util.Map;import java.util.UUID;import java.util.concurrent.CountDownLatch;import java.util.concurrent.TimeUnit;public class ZKLock &#123; private static Logger logger = LoggerFactory.getLogger(ZKLock.class); private static final String LOCK_BASE_PATH = "/ZKLOCK"; private static final String EXECUTE_PERMISSION_BASE_PATH = "/ZKLOCK/ACTIVE/CURRENT"; private static final String EXECUTE_PERMISSION_NODE_NAME = "EPHEMERAL_NODE"; private boolean executePermission = false; private String executePermissionLockVal; private Map&lt;Integer, String&gt; currNodeNameAndIndexMap = Maps.newConcurrentMap(); private String ipPort; private int connectionTimeoutMs; private String appName = ""; private CuratorFramework client; @PostConstruct public void init() &#123; this.client = CuratorFrameworkFactory.builder().connectString(ipPort).connectionTimeoutMs(connectionTimeoutMs).retryPolicy(new ExponentialBackoffRetry(1000, 3)).build(); this.client.start(); this.executePermissionLockVal = UUID.randomUUID().toString().replaceAll("-",""); &#125; /** * 对某个key键进行尝试加锁，如果加锁失败，需要设置监听事件 * * @param lockKey * @return * @throws Exception */ public boolean tryLock(String lockKey) throws Exception &#123; try &#123; createParentNodeIfNotExists(lockKey); String currQueueNodeName = this.createCurrQueueNodeIfNotExists(lockKey); if (StringUtils.isEmpty(currQueueNodeName)) &#123; return false; &#125; return checkQueue(lockKey); &#125; catch (Exception e) &#123; String exceptionTimeTLKey = this.getExceptionTimeTLKey(lockKey); String exceptionTime = ThreadLocalUtil.getMapValue(exceptionTimeTLKey); if (StringUtils.isEmpty(exceptionTime)) &#123; ThreadLocalUtil.setMapValue(exceptionTimeTLKey, "1"); &#125; else &#123; int time = Integer.parseInt(exceptionTime); if (time &gt; 3) &#123; throw e; &#125; ThreadLocalUtil.setMapValue(exceptionTimeTLKey, new Integer(time+1).toString()); &#125; return false; &#125; &#125; private boolean checkQueue(String lockKey) throws Exception &#123; String parentNodePath = this.getParentPath(lockKey); List&lt;String&gt; childrenNodePath = findAllChildrenQueueNodeName(parentNodePath); if (CollectionUtils.isEmpty(childrenNodePath)) &#123; throw new Exception("当前占队集合为空！"); &#125; Collections.sort(childrenNodePath); String currQueueNodeName = this.getCurrQueueNameFromThreadLocal(lockKey); int idx = searchCurrQueueNodeIndex(childrenNodePath, currQueueNodeName); if (idx &lt; 0) &#123; this.resetCurrQueueNodeName(lockKey); this.resetLastQueueNodeName(lockKey); return false; &#125; else if (idx &gt; 0) &#123; String lastNodeName = this.findLastQueueNodeName(childrenNodePath, idx); String lastNodeNameTLKey = getLastNodeNameTLKey(lockKey); putThreadLocal(lastNodeNameTLKey, lastNodeName); return false; &#125; else &#123; this.resetLastQueueNodeName(lockKey); return true; &#125; &#125; /** * 创建父节点，如果父节点不存在的话 * * @param lockKey * @return * @throws Exception */ private void createParentNodeIfNotExists(String lockKey) throws Exception &#123; try &#123; String parentPath = getParentPath(lockKey); Stat stat = this.client.checkExists().forPath(parentPath); if (stat == null) &#123; try &#123; this.client.create().creatingParentsIfNeeded().withMode(CreateMode.PERSISTENT).forPath(parentPath); &#125; catch (KeeperException.NodeExistsException e) &#123; System.out.println("父节点已经创建"); &#125; &#125; &#125; catch (Exception e) &#123; logger.error("zookeeper 连接失败或无法创建节点！", e); throw e; &#125; &#125; /** * 父节点路径的ThreadLocal的key * * @param lockKey * @return */ private String getParentNodePathTLKey(String lockKey) &#123; return lockKey + "_parent_node_path"; &#125; /** * 父节点全路径的ThreadLocal的key * * @param lockKey * @return */ private String getParentNodeFullPathTLKey(String lockKey) &#123; return lockKey + "_parent_node_full_path"; &#125; /** * 记录获取锁抛出异常的次数 * * @param lockKey * @return */ private String getExceptionTimeTLKey(String lockKey) &#123; return lockKey + "_exception_time"; &#125; /** * 获取父节点路径，最后没有/ * * @param lockKey * @return */ private String getParentPath(String lockKey) &#123; String parentNodePathTLKey = getParentNodePathTLKey(lockKey); String parentNodePath = ThreadLocalUtil.getMapValue(parentNodePathTLKey); if (!StringUtils.isEmpty(parentNodePath)) &#123; return parentNodePath; &#125; else &#123; if (lockKey.startsWith("/")) &#123; if (lockKey.endsWith("/")) &#123; parentNodePath = LOCK_BASE_PATH + lockKey.substring(0, lockKey.length() - 1); &#125; else &#123; parentNodePath = LOCK_BASE_PATH + lockKey; &#125; &#125; else &#123; if (lockKey.endsWith("/")) &#123; parentNodePath = LOCK_BASE_PATH + "/" + lockKey.substring(0, lockKey.length() - 1); &#125; else &#123; parentNodePath = LOCK_BASE_PATH + "/" + lockKey; &#125; &#125; putThreadLocal(parentNodePathTLKey, parentNodePath); return parentNodePath; &#125; &#125; /** * 获取父节点路径，最后带/ * * @param lockKey * @return */ private String getParentFullPath(String lockKey) &#123; String parentNodeFullPathTLKey = this.getParentNodeFullPathTLKey(lockKey); String parentNodeFullPath = ThreadLocalUtil.getMapValue(parentNodeFullPathTLKey); if (!StringUtils.isEmpty(parentNodeFullPath)) &#123; return parentNodeFullPath; &#125; else &#123; if (lockKey.startsWith("/")) &#123; if (lockKey.endsWith("/")) &#123; parentNodeFullPath = LOCK_BASE_PATH + lockKey; &#125; else &#123; parentNodeFullPath = LOCK_BASE_PATH + lockKey + "/"; &#125; &#125; else &#123; if (lockKey.endsWith("/")) &#123; parentNodeFullPath = LOCK_BASE_PATH + "/" + lockKey; &#125; else &#123; parentNodeFullPath = LOCK_BASE_PATH + "/" + lockKey + "/"; &#125; &#125; putThreadLocal(parentNodeFullPathTLKey, parentNodeFullPath); return parentNodeFullPath; &#125; &#125; /** * 当前节点名称的ThreadLocal的key * * @param lockKey * @return */ private String getCurrNodeNameTLKey(String lockKey) &#123; return lockKey + "_curr_node_name"; &#125; /** * 获取当前排队节点的名称，如果没有，排队去获取 * * @param lockKey * @return * @throws Exception */ private String createCurrQueueNodeIfNotExists(String lockKey) throws Exception &#123; try &#123; // 对这个路径进行加锁操作 String currNodeNameTLKey = getCurrNodeNameTLKey(lockKey); String currQueueNodeName = ThreadLocalUtil.getMapValue(currNodeNameTLKey); if (StringUtil.isNullOrEmpty(currQueueNodeName)) &#123; String fullPath = getParentFullPath(lockKey); // 排队，创建临时节点 String currQueueNodePath = this.client.create().creatingParentsIfNeeded().withMode(CreateMode.EPHEMERAL_SEQUENTIAL).forPath(fullPath, "lock".getBytes()); currQueueNodeName = currQueueNodePath.substring(fullPath.length()); ThreadLocalUtil.setMapValue(currNodeNameTLKey, currQueueNodeName); &#125; return currQueueNodeName; &#125; catch (Exception e) &#123; logger.error("创建父节点：：zookeeper连接失败！", e); throw e; &#125; &#125; /** * 从当前线程获取排队节点，如果没排队抛出异常 * * @param lockKey * @return * @throws Exception */ public String getCurrQueueNameFromThreadLocal(String lockKey) &#123; String currNodeNameTLKey = getCurrNodeNameTLKey(lockKey); String currQueueName = ThreadLocalUtil.getMapValue(currNodeNameTLKey); if (StringUtils.isEmpty(currQueueName)) &#123; throw new RuntimeException("当前线程没有排队获取锁！"); &#125; return currQueueName; &#125; /** * 获取当前排队节点的路径 * * @param lockKey * @return */ private String getCurrQueueNodePath(String lockKey) &#123; String currQueueNodeName = this.getCurrQueueNameFromThreadLocal(lockKey); String parentFullPath = this.getParentFullPath(lockKey); return parentFullPath + currQueueNodeName; &#125; /** * 上一节点名称的ThreadLocal的key * * @param lockKey * @return */ private String getLastNodeNameTLKey(String lockKey) &#123; return lockKey + "_last_node_name"; &#125; /** * 获取上一个排队节点的全路径名称 * * @param lockKey * @param lastQueueNodeName * @return */ private String getLastQueueNodePath(String lockKey, String lastQueueNodeName) &#123; return this.getParentPath(lockKey) + "/" + lastQueueNodeName; &#125; /** * 当前排队节点的上一个节点名称 * * @param children * @param idx * @return */ private String findLastQueueNodeName(List&lt;String&gt; children, int idx) &#123; return children.get(idx - 1); &#125; /** * 获取上一节点名称 * * @param lockKey * @return */ private String getLastQueueNodeName(String lockKey) &#123; String lastNodeNameTLKey = this.getLastNodeNameTLKey(lockKey); if (!StringUtils.isEmpty(lastNodeNameTLKey)) &#123; return ThreadLocalUtil.getMapValue(lastNodeNameTLKey); &#125; return null; &#125; private void clean(String lockKey, boolean lockSuccess) &#123; this.resetLastQueueNodeName(lockKey); if (!lockSuccess) &#123; this.resetParentNodeFullPath(lockKey); this.resetParentNodePath(lockKey); this.resetCurrQueueNodeName(lockKey); &#125; &#125; /** * 绑定监听事件，并没有时间限制的一直等待 * * @param lockKey */ @SuppressWarnings("resource") private void waitForLock(String lockKey) &#123; CountDownLatch cdl = new CountDownLatch(1); TreeCache cache = null; TreeCacheListener listener = null; try &#123; String lastNodeName = this.getLastQueueNodeName(lockKey); if (StringUtils.isEmpty(lastNodeName)) &#123; return; &#125; String lastQueueNodePath = this.getLastQueueNodePath(lockKey, lastNodeName); cache = new TreeCache(this.client, lastQueueNodePath); listener = new TreeCacheListener() &#123; @Override public void childEvent(CuratorFramework client, TreeCacheEvent event) throws Exception &#123; if (event.getData() != null &amp;&amp; event.getType() == TreeCacheEvent.Type.NODE_REMOVED) &#123; cdl.countDown(); &#125; &#125; &#125;; try &#123; try &#123; cache.start(); &#125; catch (Exception e) &#123; return; &#125; cache.getListenable().addListener(listener); if (this.checkQueue(lockKey)) &#123; return; &#125; cdl.await(1000, TimeUnit.MILLISECONDS); &#125; catch (Exception e) &#123; logger.info("监听排队节点失败！", e); &#125; &#125; finally &#123; try &#123; cdl.countDown(); if (cache != null &amp;&amp; listener != null) &#123; cache.getListenable().removeListener(listener); &#125; &#125; catch (Exception e) &#123; logger.warn("监听节点退出异常！", e); &#125; &#125; &#125; /** * 将当前节点从缓存中清除，从zookeeper中删除 * * @param lockKey */ private void resetCurrQueueNodeName(String lockKey) &#123; String currNodeName = this.getCurrQueueNameFromThreadLocal(lockKey); if (!StringUtils.isEmpty(currNodeName)) &#123; try &#123; this.client.delete().forPath(this.getCurrQueueNodePath(lockKey)); &#125; catch (Exception e) &#123; logger.warn("删除当前节点失败，currNodeName=&#123;&#125;", currNodeName, e); &#125; &#125; String currNodeNameTLKey = this.getCurrNodeNameTLKey(lockKey); removeFromThreadLocal(currNodeNameTLKey); &#125; private void resetLastQueueNodeName(String lockKey) &#123; String lastNodeNameTLKey = this.getLastNodeNameTLKey(lockKey); removeFromThreadLocal(lastNodeNameTLKey); &#125; private void resetParentNodePath(String lockKey) &#123; String parentNodePathTLKey = this.getParentFullPath(lockKey); removeFromThreadLocal(parentNodePathTLKey); &#125; private void resetParentNodeFullPath(String lockKey) &#123; String parentNodeFullPathTLKey = this.getParentNodeFullPathTLKey(lockKey); removeFromThreadLocal(parentNodeFullPathTLKey); &#125; private boolean removeFromThreadLocal(String currNodeNameTLKey) &#123; return ThreadLocalUtil.removeMapValue(currNodeNameTLKey); &#125; /** * 对某个key键进行加锁，一直等待，直到加锁成功 * * @param lockKey * @return * @throws Exception */ public boolean acquire(String lockKey) &#123; boolean result = false; try &#123; while (!tryLock(lockKey)) &#123; waitForLock(lockKey); &#125; result = true; &#125; catch (Exception e) &#123; logger.info("获取zk锁异常或超时！", e); result = false; &#125; finally &#123; clean(lockKey, result); &#125; return result; &#125; /** * 只加锁一次，如果加锁失败，立马返回失败信息 * * @param lockKey * @return */ public boolean acquireOnce(String lockKey) &#123; boolean result = false; try &#123; result = tryLock(lockKey); &#125; catch (Exception e) &#123; logger.info("获取zk锁异常或超时！", e); return false; &#125; finally &#123; clean(lockKey, result); &#125; return result; &#125; /** * 等待一段时间还没等到，就返回失败 * * @param lockKey * @param timeoutMs * @return */ public boolean acquire(String lockKey, int timeoutMs) &#123; boolean result = false; long start = System.currentTimeMillis(); try &#123; while (!tryLock(lockKey)) &#123; if (System.currentTimeMillis() - start &gt; timeoutMs) &#123; return false; &#125; waitForLock(lockKey); &#125; if (System.currentTimeMillis() - start &gt; timeoutMs) &#123; result = false; return false; &#125; result = true; &#125; catch (Exception e) &#123; logger.info("获取zk锁异常或超时！", e); return false; &#125; finally &#123; clean(lockKey, result); &#125; return result; &#125; /** * 释放掉锁，删除缓存(当前节点，上一节点，父节点缓存)，删除zookeeper中当前节点数据 * * @param lockKey */ public void unlock(String lockKey) &#123; try &#123; String currNodeName = this.getCurrQueueNameFromThreadLocal(lockKey); if (!StringUtils.isEmpty(currNodeName)) &#123; this.resetCurrQueueNodeName(lockKey); this.resetLastQueueNodeName(lockKey); this.resetParentNodeFullPath(lockKey); this.resetParentNodePath(lockKey); &#125; &#125; catch (Exception e) &#123; logger.error("释放锁失败，删除节点失败！"); &#125; &#125; /** * 查找所有排队子节点 * * @param parentNodePath * @return * @throws Exception */ private List&lt;String&gt; findAllChildrenQueueNodeName(String parentNodePath) throws Exception &#123; try &#123; return this.client.getChildren().forPath(parentNodePath); &#125; catch (Exception e) &#123; logger.error("zookeeper连接失败，或查找不到子节点！path=&#123;&#125;", parentNodePath, e); throw e; &#125; &#125; /** * 将当前线程的当前key赋值 * * @param tlKey * @param currNodeName */ private void putThreadLocal(String tlKey, String currNodeName) &#123; ThreadLocalUtil.setMapValue(tlKey, currNodeName); &#125; /** * 查询当前节点排在第几号位置 * * @param childrenNodePath * @param currQueueNodeName * @return */ private int searchCurrQueueNodeIndex(List&lt;String&gt; childrenNodePath, String currQueueNodeName) &#123; return Collections.binarySearch(childrenNodePath, currQueueNodeName); &#125; /** * 获取运行权限 */ public boolean acquireActive()&#123; try&#123; // 如果保存的是自己已经拿到锁了，还得去校验一遍，为了解决脑列问题 if(this.executePermission)&#123; String value = getExecutePermissionValue(); if(value != null &amp;&amp; value.equals(this.executePermissionLockVal))&#123; return true; &#125; &#125; // 如果没有拿到锁，就将当前zkLock保存的状态修改一下 this.executePermission = false; return this.createEphemeralNode(); &#125;catch (Exception e)&#123; return false; &#125; &#125; public boolean removeExecutePermission() &#123; try&#123; this.client.delete().forPath(this.getEphemeralNodePath()); return true; &#125;catch (Exception e)&#123; logger.error("模拟连接断掉失败！"); return false; &#125; &#125; private String getExecutePermissionValue() throws Exception&#123; try &#123; return new String(this.client.getData().forPath(this.getEphemeralNodePath()),"UTF-8"); &#125; catch (KeeperException.NoNodeException e) &#123; return null; &#125;catch(Exception e)&#123; logger.info("获取临时节点Value失败！",e); throw e; &#125; &#125; private Stat getExecutePermissionStat() throws Exception &#123; try&#123; return this.client.checkExists().forPath(this.getEphemeralNodePath()); &#125;catch (Exception e)&#123; logger.error("获取临时节点状态失败！"); throw e; &#125; &#125; private String getEphemeralNodePath() &#123; return EXECUTE_PERMISSION_BASE_PATH + "_" + this.appName + "/" + EXECUTE_PERMISSION_NODE_NAME; &#125; private boolean createEphemeralNode() throws Exception &#123; try &#123; Stat stat = this.getExecutePermissionStat(); if (stat == null) &#123; try &#123; this.client.create().creatingParentsIfNeeded().withMode(CreateMode.EPHEMERAL).forPath(this.getEphemeralNodePath(),this.executePermissionLockVal.getBytes("UTF-8")); stat = this.getExecutePermissionStat(); if(stat != null)&#123; this.executePermission = true; System.out.println("加锁成功:::"+this.executePermission+",,,"+this.executePermissionLockVal+",,,"); return true; &#125;else&#123; return false; &#125; &#125; catch (KeeperException.NodeExistsException e) &#123; return false; &#125; &#125;else&#123; return false; &#125; &#125; catch (Exception e) &#123; logger.error("zookeeper 连接失败或无法创建节点！", e); throw e; &#125; &#125; public String getIpPort() &#123; return ipPort; &#125; public void setIpPort(String ipPort) &#123; this.ipPort = ipPort; &#125; public int getConnectionTimeoutMs() &#123; return connectionTimeoutMs; &#125; public void setConnectionTimeoutMs(int connectionTimeoutMs) &#123; this.connectionTimeoutMs = connectionTimeoutMs; &#125; public String getAppName() &#123; return appName; &#125; public void setAppName(String appName) &#123; this.appName = appName; &#125;&#125; spring中配置12345&lt;bean id="zkLock" class="com.api.lock.ZKLock"&gt; &lt;property name="ipPort" value="$&#123;lock.zk.ipPort&#125;"/&gt; &lt;property name="connectionTimeoutMs" value="$&#123;lock.zk.timeout&#125;"/&gt; &lt;property name="appName" value="$&#123;lock.zk.appName&#125;"/&gt;&lt;/bean&gt;]]></content>
      <categories>
        <category>经典</category>
      </categories>
      <tags>
        <tag>分布式锁</tag>
        <tag>zookeeper</tag>
        <tag>curator</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis实现分布式锁]]></title>
    <url>%2F2018%2F05%2F17%2F2018-05-17redis%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%2F</url>
    <content type="text"><![CDATA[redis实现分布式锁redis分布式锁是通过setNx，getset原子性操作实现的 基本流程是： 使用setNx命令给给定的锁Key（比如要给OrderNo=1234加锁，key值就为lock_1234）设置值（System.currentTimeMillis()+UUID） 如果设置成功了，就表明加锁成功 如果设置失败了，就表明有其它线程在占用该锁，获取占用锁线程设置的值（System.currentTimeMillis()+UUID） 判断当前占用锁的进程占用锁是否超时，如果超时，使用getset抢着去赋新值，如果赋值后返回的结果是之前超时线程赋的值，则表明占用锁成功，否则占用锁失败，等待一段时间重新尝试获取锁 下面是具体的代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110import java.util.UUID;import org.apache.commons.lang3.StringUtils;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Component;/** * 分布式锁 CAS * @author menggl */@Componentpublic class RedisLock &#123; private static Logger logger = LoggerFactory.getLogger(RedisLock.class); @Autowired private RedisCache redis; private static final String CLK_PREFIX = "lock_"; private static final int HOLD_LOCK_EXPIRE_MILL_SECOND = 50 * 1000; // 持有锁有效时长为50秒，50秒之后锁自动释放 private static final int DEFAULT_TIME_OUT_MILL_SECOND = 5 * 1000; // 获取锁超时时长默认值5秒 private static final long LOCK_VALUE_EXPIRE = 60*60; // 锁值有效时长，1小时 /** * lockKey可以是当前订单号或者VIN码，对订单号或VIN码加锁 * @param lockKey * @param timeOutSeconds 获取锁超时时间，毫秒,-1:没有超时限制，谨慎使用 * @return */ public boolean tryLock(String lockKey,long timeOutMillSeconds)&#123; try &#123; ThreadLocalUtil.removeMapValue(lockKey); String redisKey = CLK_PREFIX + lockKey; long startTime = System.currentTimeMillis(); String uuid = UUID.randomUUID().toString().replaceAll("-", ""); while(true)&#123; long currentTime = System.currentTimeMillis(); String newVal = currentTime+"_"+uuid; boolean setnx = redis.setNx(redisKey, newVal); if(!setnx)&#123; // 锁被占用 String oldVal = redis.get(redisKey); if(oldVal == null)&#123; continue; &#125; String[] oldArr = oldVal.split("_",2); long expireTime = Long.parseLong(oldArr[0])+HOLD_LOCK_EXPIRE_MILL_SECOND; // 锁有效期判定 if(System.currentTimeMillis() &gt;= expireTime)&#123; String getStr = redis.getSet(redisKey, newVal); if(getStr == null || oldVal.equals(getStr))&#123; logger.debug("trylock successed, getSet, key=&#123;&#125;, newValue=&#123;&#125;, oldValue=&#123;&#125;, expireTime=&#123;&#125;, currentTime=&#123;&#125;, &#123;&#125;, interval=&#123;&#125; millseconds",redisKey,newVal,oldVal,expireTime,currentTime,currentTime-expireTime,HOLD_LOCK_EXPIRE_MILL_SECOND); ThreadLocalUtil.setMapValue(lockKey, System.currentTimeMillis()+""); this.redis.expire(redisKey, LOCK_VALUE_EXPIRE); return true; &#125; &#125; try &#123; Thread.sleep(200); &#125; catch (InterruptedException e) &#123; logger.error("Thread sleep error:",e); &#125; &#125;else&#123; // 正常获取到锁 logger.debug("trylock successed, key=&#123;&#125;, value=&#123;&#125;",redisKey,newVal); ThreadLocalUtil.setMapValue(lockKey, System.currentTimeMillis()+""); this.redis.expire(redisKey, LOCK_VALUE_EXPIRE); return true; &#125; // 获取锁时长超时判定 long costTime = System.currentTimeMillis() - startTime; if(timeOutMillSeconds != -1 &amp;&amp; costTime &gt; timeOutMillSeconds)&#123; logger.warn("获取锁超时，timeout= &#123;&#125; millseconds",costTime); return false; &#125; &#125; &#125; catch (Exception e) &#123; logger.error("trylock error, msg:",e); return false; &#125; &#125; /** * lockKey可以是当前订单号或者VIN码，对订单号或VIN码加锁 * @param lockKey * @return */ public boolean tryLock(String lockKey)&#123; return this.tryLock(lockKey,DEFAULT_TIME_OUT_MILL_SECOND); &#125; /** * 释放锁，lockKey可以是当前订单号或者VIN码 * @param lockKey * @return */ public boolean unlock(String lockKey)&#123; String millSecondsStr = ThreadLocalUtil.getMapValue(lockKey); if(!StringUtils.isBlank(millSecondsStr))&#123; try&#123; long millSeconds = Long.parseLong(millSecondsStr); if(millSeconds + HOLD_LOCK_EXPIRE_MILL_SECOND - 200 &gt; System.currentTimeMillis())&#123; String redisKey = CLK_PREFIX + lockKey; return this.redis.del(redisKey); &#125; &#125;finally&#123; ThreadLocalUtil.removeMapValue(lockKey); &#125; &#125; return true; &#125;&#125; 问题： 没有使用redis的超时机制，因为如果setNx成功，setExpire失败，那么这把锁就永远不能被别的线程拿到，所以使用服务器时间判断超时 各个服务器使用的时间不一致时，会导致这台服务器获刚获取到锁，另一台服务器就判定超时，然后就拿到了锁 如果占用锁的线程崩掉，没有释放锁，就只能一直等待，直到锁超时，没有一个监控拿到锁线程的机制 拿到锁的线程处理业务时间不确定，如果业务没处理完，锁就超时了，就会出现同时拿到锁的情况 不是公平锁，都是随机获取锁 综上所述： 只有在有界的网络延迟、有界的程序中断、有界的时钟错误范围，Redlock才能正常工作，但是这三种场景的边界又是无法确认的，所以专家不建议使用Redlock。对于正确性要求高的场景，专家推荐了Zookeeper，关于使用Zookeeper作为分布式锁后面再讨论。]]></content>
      <categories>
        <category>经典</category>
      </categories>
      <tags>
        <tag>redis</tag>
        <tag>分布式锁</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Interceptor中解决跨域问题]]></title>
    <url>%2F2018%2F05%2F07%2F2018-05-07Interceptor%E4%B8%AD%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[在项目开发过程中，我们会遇到浏览器跨域请求资源的场景，跨域的时候有时候还需要携带cookie，我们发现配置上SpringMVC自带的mvc:cors后我们自己写的业务校验拦截器Interceptor还会被调用两次，如果业务拦截器中有校验cookie中字段的逻辑也会校验失败，这样跨域问题就没有解决 导致这个问题出现的原因是使用SpringMVC自带的mvc:cors实现跨域，也是使用的Interceptor，但是这个Interceptor是在所有Interceptor都调用完成之后才调用的，这就导致业务拦截时校验失败，调用不到Cors的拦截器就返回了，导致跨域授权失败，资源请求失败 我们看一下源码：所有请求都会走DispatchServlet.doDispatch()方法12345678910// Determine handler for the current request.mappedHandler = getHandler(processedRequest);// 这里会顺序调用所有的Interceptor，直到有一个拦截器返回false或者抛出异常或者所有拦截器都调用完毕if (!mappedHandler.applyPreHandle(processedRequest, response)) &#123; return;&#125;// Actually invoke the handler.mv = ha.handle(processedRequest, response, mappedHandler.getHandler()); 解决方案：在所有的业务拦截器的前面判断是否为OPTIONS权限请求，如果是OPTIONS请求，不进行业务拦截12345678910public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; ServletServerHttpRequest serverRequest = new ServletServerHttpRequest(request); if (serverRequest != null &amp;&amp; serverRequest.getMethod() != null) &#123; if ("OPTIONS".equalsIgnoreCase(serverRequest.getMethod().name())) &#123; return true; &#125; &#125; // ...业务逻辑 return true;&#125; 简单跨域请求（1) 请求方法是以下三种方法之一： HEAD GET POST （2）HTTP的头信息不超出以下几种字段： Accept Accept-Language Content-Language Last-Event-ID Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain 凡是不满足上面要求的都是不简单跨域请求 浏览器对这两种情况，处理的方式是不一样的 简单请求只有一次http调用，消息头中携带Referer: http://localhost:8080/cross-domain1/和Origin: http://localhost:8080信息，表示跨域的请求来自http://localhost:8080。 复杂请求会有两次http调用，第一次http请求是OPTIONS请求，跨域权限请求，第二次才是真正的资源访问请求 跨域解决方案如下：第一种：使用CorsFilter 定义跨域请求过滤器CORSFilter 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import java.io.IOException;import javax.servlet.Filter;import javax.servlet.FilterChain;import javax.servlet.FilterConfig;import javax.servlet.ServletException;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;import javax.servlet.http.HttpServletResponse;public class CORSFilter implements Filter &#123; public CORSFilter() &#123; &#125; public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; HttpServletResponse httpServletResponse = (HttpServletResponse) response; // 允许哪些域名下的网页可以进行跨域请求 httpServletResponse.setHeader("Access-Control-Allow-Origin", "http://localhost:8080"); // 跨域请求时允许的请求头信息 httpServletResponse.setHeader("Access-Control-Allow-Headers", "User-Agent,Origin,Cache-Control,Content-type,Date,Server,withCredentials,AccessToken,X-Custom-Header"); // 服务端控制的是否允许跨域请求携带cookie // 若客户端想发送带cookie的跨域请求，使用withCredentials控制打开，如下所示 // js代码：var xhr = new XMLHttpRequest();xhr.withCredentials = true; // ajax代码： xhrFields:&#123;withCredentials:true,&#125; httpServletResponse.setHeader("Access-Control-Allow-Credentials", "true"); // 允许的请求类型 httpServletResponse.setHeader("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS, HEAD"); httpServletResponse.setHeader("Access-Control-Max-Age", "5"); // 该字段可选，浏览器可以拿到哪些字段信息，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma，如果想拿到其它字段，就必须在这里指定 httpServletResponse.setHeader("Access-Control-Expose-Headers", "accesstoken"); // 资源过期时间，秒 httpServletResponse.setHeader("Expires", "-1"); // 控制浏览器缓存，不缓存 httpServletResponse.setHeader("Cache-Control", "no-cache"); // http1.0使用的浏览器缓存控制 httpServletResponse.setHeader("pragma", "no-cache"); chain.doFilter(request, response); &#125; public void init(FilterConfig fConfig) throws ServletException &#123; &#125; public void destroy() &#123; &#125;&#125; 在web.xml配置上这个过滤器 12345678&lt;filter&gt; &lt;filter-name&gt;corsFilter&lt;/filter-name&gt; &lt;filter-class&gt;com.test.filter.CORSFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;corsFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 在业务校验拦截器Interceptor中将OPTIONS请求过滤 123456789101112131415161718192021222324252627public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; ServletServerHttpRequest serverRequest = new ServletServerHttpRequest(request); logger.debug(serverRequest.getMethod().name()); if (serverRequest != null &amp;&amp; serverRequest.getMethod() != null) &#123; if ("OPTIONS".equalsIgnoreCase(serverRequest.getMethod().name())) &#123; logger.debug("OPTIONS请求不进行业务拦截校验！"); return true; &#125; &#125; if ("/test/setCookies".equals(request.getServletPath())) &#123; return true; &#125; // 模拟业务使用cookie中的参数 Cookie[] cookies = request.getCookies(); String token = null; if (cookies != null &amp;&amp; cookies.length &gt; 0) &#123; for (Cookie c : cookies) &#123; if (c.getName().equals("token")) &#123; token = c.getValue(); &#125; &#125; &#125; if (token == null) &#123; throw new Exception("参数token不能为空！"); &#125; return true;&#125; 第二种：使用mvc:cors 添加springMVC的cors配置 12345678&lt;mvc:cors&gt; &lt;mvc:mapping path="/**" allowed-origins="*" allow-credentials="true" allowed-methods="GET,POST,PUT,DELETE,OPTIONS,HEAD" max-age="3600" allowed-headers="User-Agent,Origin,Cache-Control,Content-type,Date,Server,withCredentials,AccessToken,X-Custom-Header"/&gt;&lt;/mvc:cors&gt; 在业务拦截器Interceptor中将OPTIONS请求过滤 123456789101112131415161718192021222324252627public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; ServletServerHttpRequest serverRequest = new ServletServerHttpRequest(request); logger.debug(serverRequest.getMethod().name()); if (serverRequest != null &amp;&amp; serverRequest.getMethod() != null) &#123; if ("OPTIONS".equalsIgnoreCase(serverRequest.getMethod().name())) &#123; logger.debug("OPTIONS请求不进行业务拦截校验！"); return true; &#125; &#125; if ("/test/setCookies".equals(request.getServletPath())) &#123; return true; &#125; // 模拟业务使用cookie中的参数 Cookie[] cookies = request.getCookies(); String token = null; if (cookies != null &amp;&amp; cookies.length &gt; 0) &#123; for (Cookie c : cookies) &#123; if (c.getName().equals("token")) &#123; token = c.getValue(); &#125; &#125; &#125; if (token == null) &#123; throw new Exception("参数token不能为空！"); &#125; return true;&#125; 第三种：使用@CrossOrigin1234567891011@Controller@RequestMapping("/test")@CrossOrigin(origins = &#123; "http://localhost:8080" &#125;, allowCredentials = "true", maxAge = 5, allowedHeaders = &#123; "User-Agent", "Origin", "Cache-Control", "Content-type", "Date", "Server", "withCredentials", "AccessToken", "X-Custom-Header" &#125;)public class TestController &#123; @RequestMapping(name = "/crossDomain", method = &#123; RequestMethod.GET, RequestMethod.POST, RequestMethod.PUT &#125;) @ResponseBody public String testCrossDomain() &#123; return "success OK!"; &#125; 这个对于简单跨域请求是没问题的，对于非简单跨域请求权限校验失败。 测试demo创建web项目：cross-domain1(localhost:8080)和cross-domain2(localhost:8081) 我们将要从localhost:8080项目下的网页访问localhost:8081项目下的请求 cross-domain1项目创建test.html12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;html&gt;&lt;!-- 这个html是在http://localhost:8080项目下 --&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;script src="static/js/jquery-1.8.1.min.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;input type="button" id="testBtn1" value="简单跨域"/&gt;&lt;input type="button" id="testBtn2" value="非简单跨域"/&gt;&lt;script type="text/javascript"&gt;$(document).ready(function()&#123; $("#testBtn2").click(function()&#123; $.ajax(&#123; url:'http://localhost:8081/cross-domain2/test/crossDomain', type: "GET",// 请求方式 async: false,// 默认为true，异步方式请求 contentType: 'application/x-www-form-urlencoded', // 内容编码格式，默认是application/x-www-form-urlencoded crossDomain: true, cache:false, data: &#123;token:"abc"&#125;, dataType: 'json',// 预期服务器返回的数据类型 beforeSend:function(XMLHttpReqeust)&#123; XMLHttpReqeust.withCredentials = true;// 可以附带cookie信息,同时服务端配置权限的时Access-Control-Allow-Origin就不能设置为*，必须设置指定的域了 XMLHttpReqeust.setRequestHeader("X-Custom-Header","session=xxxxyyyyzzzz");// 新增消息头 &#125;, complete:function(XMLHttpRequest, textStatus)&#123; console.log('complete'); &#125;, success:function(data, textStatus)&#123; console.log(data); &#125;, error:function(XMLHttpRequest, textStatus, errorThrown)&#123; console.log(errorThrown); &#125;, &#125;) &#125;); $("#testBtn1").click(function()&#123; $.ajax(&#123; url:'http://localhost:8081/cross-domain2/test/crossDomain', type: "GET",// 请求方式 async: false,// 默认为true，异步方式请求 contentType: 'application/x-www-form-urlencoded', // 内容编码格式，默认是application/x-www-form-urlencoded crossDomain: true, cache:false, data: &#123;token:"abc"&#125;, dataType: 'json',// 预期服务器返回的数据类型 complete:function(XMLHttpRequest, textStatus)&#123; console.log('complete'); &#125;, success:function(data, textStatus)&#123; console.log(data); &#125;, error:function(XMLHttpRequest, textStatus, errorThrown)&#123; console.log(errorThrown); &#125;, &#125;) &#125;);&#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; cross-domain2项目，创建Controller123456789101112131415161718192021222324252627import javax.servlet.http.Cookie;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;@Controller@RequestMapping("/test")public class TestController &#123; @RequestMapping("/crossDomain") @ResponseBody public String testCrossDomain() &#123; return "success OK!"; &#125; @RequestMapping("/setCookies") @ResponseBody public String setCookies(HttpServletRequest request, HttpServletResponse response) &#123; Cookie token = new Cookie("token", "123456"); token.setPath("/"); token.setMaxAge(86400); response.addCookie(token); return "success OK!"; &#125;&#125;]]></content>
      <categories>
        <category>经典</category>
      </categories>
      <tags>
        <tag>Cors</tag>
        <tag>CrossOrigin</tag>
        <tag>简单跨域</tag>
        <tag>cookie</tag>
        <tag>ajax跨域</tag>
        <tag>spring跨域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA虚拟机之运行时数据区]]></title>
    <url>%2F2018%2F03%2F20%2F2018-03-20JAVA%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%2F</url>
    <content type="text"><![CDATA[JAVA运行时数据区域(runtime data area)java运行时数据区可以分为6个区域 Java堆 Java虚拟机栈 本地方法栈 方法区 运行时常量池 程序计数器 线程私有的有： 程序计数器 本地方法栈 java虚拟机栈 线程共有的有： java堆 方法区 运行时常量池 PC程序计数器可以理解为一块较小的内存空间，可以看做是当前线程执行字节码的行号计数器，一个线程分配一小块，以便记录当前线程执行的上线文环境，多线程切换时将上线文环境数据保存和加载。如果线程执行到本地方法，则PC程序计数器不会记录本地方法的上下文（没有字节码可以记录啊）。 Java虚拟机栈每个java线程都会拥有一块Java虚拟机栈的内存空间，Java虚拟机栈记录的是每个JAVA方法执行时候的内存模型，每调用一个JAVA方法的时候都会在Java虚拟机栈里面创建一个栈帧每个栈帧都会包含下面几个部分： 局部变量表 操作数栈 动态链接 方法返回地址 下面我们解释一下栈帧中各个部分都是干什么用的 局部变量表 作用：保存方法中的参数、局部变量等 如果这个栈帧是实例的方法栈帧，这个局部变量表第0个Slot肯定就是this（当前的实例），然后方法中的局部变量从第1个Slot开始 局部变量表以变量槽Slot为基本单位，在32位虚拟机中一个变量槽可以保存一个32位以内的数据类型（boolean、byte、char、short、int、float、reference和returnAddress八种），对于64位的数据用连续的两个变量槽来记录 如果方法中的某个变量的作用域结束了，那么这个变量对应的slot内存就可以被其它变量覆盖重用了 returnAddress类型是为字节码指令：jsr、jsr_w、ret服务的，它指向了一条字节码指令的地址（返回上一个调用该方法的字节码地址？） 引用类型reference没有明确规定它的长度 在java程序被编译成class文件时，就在方法的Code属性的max_locals数据项中确定该方法需要分配的局部变量表的内存大小 操作数栈 就像汇编一样，jvm也有指令集，java指令集是由一个字节表示的，也就是说指令集不超过256个，现在的java指令集也就200多条 指令运行时需要读取数据，处理完成后需要保存数据，这个操作数栈就是用来保存这些指令执行中需要的参数数据和结果数据的 操作数分两种，一种直接嵌入到指令中，可以叫做是嵌入操作数；还有一种是会压入操作数栈，这种可以叫做栈中操作数 嵌入操作数在编译期就已经确定好了，比如putstatic指令，将数据赋值给一个静态变量，该静态变量就是一个嵌入式操作数，它会紧跟指令，用两个字节表示，这个操作数是一个索引值，索引值指向的是运行时常量池中该静态字段对应的符号引用，由于符号引用中包含了这个静态变量的基本信息，如所属类、简单名称、描述符，这样指令就知道要给哪个类的哪个字段赋值了 栈中操作数是在运行期动态确定的数据，比如一个指令需要两个参数，需要先把两个参数放入操作数栈中，使用后出栈，将运行结果再入栈 动态链接 静态链接是在类加载的时候或者第一次使用的时候就将符号引用确定下来直接引用的过程 动态链接是在代码执行的时候才会确定符号引用对应的直接引用地址的过程 方法返回地址这个应该就保存在局部变量表中吧 本地方法栈与java虚拟机栈类似，为Java使用到的本地方法提供服务用的。 当java线程调用了一个本地方法时，它就会进入一个全新的不受java虚拟机限制的世界，本地方法还可以反过来通过本地方法接口来访问虚拟机的运行时数据区 如果某个虚拟机实现的本地方法接口是使用C连接模型的话，那么它的本地方法栈就是C栈 下面是定义了一个java的Native Method，类似于定义了一个接口123456public class IHaveNatives&#123; native public void Native1( int x ) ; native static public long Native2() ; native synchronized private float Native3( Object o ) ; native void Native4( int[] ary ) throws Exception ;&#125; Java堆 java堆是被所有线程共享的一块内存区域 所有的对象和数组的内存分配都在堆上面 为了垃圾收集方便，java堆又可以分为新生代、老年代和永久代（也叫方法区，jdk1.8中没有永久代，用metaspace实现）三块区域 方法区 保存虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码Class等数据 jdk6时，字符串常量是保存在方法区中的，jdk7开始，已将其移到堆中了 jdk8的方法区被元数据区替代（MetaSpace） 注意：这里的类变量是类的静态变量 类型的常量池：这里保存的是该class用到的其它常量的有序集合，包括字面量（直接常量）和符号引用（对象引用，非字面量），这个在动态链接中起核心作用（将符号引用解释为直接引用） 方法信息：方法信息包含该类中的所有方法，每个方法包含下面的信息：方法修饰符、方法返回类型、方法名、方法参数个数/类型/顺序等、方法的字节码、操作数栈和该方法在栈帧中的局部变量区大小、异常表 方法表：为了提高访问效率，JVM为每个加载的非虚拟类的类型都添加一个方法表，方法表是一组该类及该类父类方法的直接引用。jvm可以通过方法表快速激活实例方法。 常量池JAVA字面量（JAVA直接量）指的是int，long、double的直接量，比如123,”中国”,’c’,123.01，等具体的数值 符号引用符号引用是一个字符串，我们在代码里引用一个非字面量的东西，不管是变量还是常量，它都只是由一个符号串定义的符号，这个符号串在常量池中，类加载的时候，第一次加载到这个符号时，就会将这个符号引用（字符串）解析成直接引用（指针） 直接引用 指向目标的指针，指向对象、类变量、类方法的指针 相对偏移量，指向实例的变量、方法的指针 一个可以间接定位到对象的句柄 class文件中的常量池查看class文件中的常量池信息， 使用命令 1javap -verbose Test.class 使用Notepad++以16进制打开class文件 我们先看看常量池在class文件中的位置 常量池的数据结构是怎么组成的 常量池的数据结构很简单，前面有两个字节表示常量池计数器（constant_pool_count），它记录了常量池中常量项的个数，如果它的数值为10，则后面就会紧跟着9个常量项（cp_info） 每个常量项的数据结构是什么下面是不同类型的常量项的tag值常量项可以分成两种类型 下面是int和float常量项的数据结构 比如在class中定义了两个变量，并且赋值12public static int a = 32768;// [-32768,32767]的数据都不放入常量池中public static float b = 11.2; 在常量池中的数据结构如下 我们使用javap -v Test.class来看看常量池中保存的数据 下面是long和double的常量项结构 下面是String的常量项结构CONSTANT_String_info常量项的值为#21指向CONSTANT_Utf8_info常量项里的值 方法区中的运行时常量池方法区中的常量池是动态的，可以随时增加或被垃圾回收 运用比较多的就是String类的intern()方法 测试代码1234567891011public static void main(String[] args) &#123; String s1 = new String("1"); s1.intern(); String s2 = "1"; System.out.println(s1 == s2); String s3 = new String("1") + new String("1"); s3.intern(); String s4 = "11"; System.out.println(s3 == s4);&#125; 上面的代码在jdk6中运行结果是12falsefalse 在jdk7中运行的结果是12falsetrue jdk6中的常量池是放在永久区中的（Perm区），永久区和堆区是完全分开的，也就是说堆中对象地址永远不可能与Perm区中的对象地址相等 jdk7中的常量池已经将Perm区移动到堆中了，当调用intern()的时候会做一个操作：常量池中创建一个”11”对象，该对象保存的是s3对象的地址，所以之后使用”11”常量池赋值的时候就是赋的s3对象的引用地址 下面是jdk8中的常量池12345678910111213141516171819202122232425262728public static void main(String[] args) &#123; // s1在常量池中 String s1 = "abcd"; // s2在堆中 String s2 = new String("abcd"); System.out.println(s1 == s2);// 这里肯定是false // s3到常量池中找s2对应的字符串的常量对应的地址 String s3 = s2.intern(); System.out.println(s1 == s3);// s3找到的是s1常量池的地址,这里是true System.out.println(s2 == s3);// s2是堆中的地址，这里的s3是常量池中的地址s1，肯定是false // 这里的两个1都在常量池中，"11"在常量池中是不存在的 String s4 = new String("1") + new String("1"); // 在常量池中新增加一个"11"的对象，该对象保存的是s4的引用地址，以后所有使用"11"赋值的字符串变量都使用的是s4的引用地址 s4.intern(); String s5 = "11"; String s6 = "11"; System.out.println(s5 == s4); System.out.println(s6 == s4); // 这里会创建两个对象，一个在常量池中的"9"(类加载后就存在?)，另一个是在堆中创建的s7对象 String s7 = new String("9"); String s8 = s7.intern();// 这里返回的是常量池中的"9"保存的地址（在类加载完后就存在了?） String s9 = "9";// 这里使用的是常量池中的"9"保存的地址 System.out.println(s7 == s9);// 一个在堆中，一个在常量池中，false System.out.println(s8 == s9);// 这两个都是常量池中"9"保存的引用地址，true&#125; 如果在代码中就存在的字面量，也就是在class文件中的常量池中的常量，在类加载后就会保存在运行时常量池中，动态创建的字符串,比如String new_ss = new String(“1”)+new String(“1”);”11”不会在常量池中保存，只能调用new_ss.intern()将”11”放入常量池，这时候常量池中”11”对象就保存的是new_ss堆中的引用地址了，以后任何String s1、2、3..=”11”;中的引用地址都是new_ss的堆中地址 配置参数-Xms // 虚拟机初始堆内存大小-Xmx // 虚拟机最大堆内存大小-Xmn // 虚拟机年轻代堆内存大小（1.4及之后版本） -Xss // 设置JVM栈的大小 -Xmn // 年轻代的内存大小 查看虚拟机加载、卸载的class数量、空间及耗费的时间1jstat -class [进程号] Loaded 加载class的数量 Bytes 所占用空间大小 Unloaded 未加载class数量 Bytes 未加载占用空间大小 Time 加载使用时间 查看JIT编译过的方法（编译字节码成机器码）数量及耗时时间1jstat -compiler [进程号] Compiled 编译数量 Failed 编译失败数量 Invalid 无效数量 Time 编译耗时 FailedType 失败类型 FailedMethod 编译失败的最后一个方法名称 查看虚拟机内存统计1jstat -gccapacity [进程号] NGCMN 新生代最小容量 NGCMX 新生代最大容量 NGC 当前新生代所占容量 EC eden区容量大小 S0C 第一个幸存区容量大小 S1C 第二个幸存区容量大小 OGCMN 老年代最小容量大小 OGCMX 老年代最大容量大小 OGC 当前老年代大小 OC 当前老年代大小 MCMN MetaSpace最小容量大小 MCMX MetaSpace最大容量大小 MC 当前MetaSpace容量大小 CCSMN 当前压缩类空间大小 CCSMX 当前压缩类空间最大容量 CCSC 当前压缩类使用空间大小 YGC 年轻代GC次数 FGC 老年代GC次数 查看虚拟机垃圾回收统计1jstat -gc [进程号] [间隔时间/毫秒] EC 年轻代Eden区的容量 EU 年轻代Eden区使用大小 S0C 年轻代第一个survivor区的容量 S0U 年轻代第一个Survivor区的使用大小 S1C 年轻代第二个Survivor区的容量 S1U 年轻代第二个Survivor区的使用大小 OC 老年代的容量 OU 老年代的使用大小 PC 持久代的容量 1.8之后就是MC PU 持久代的使用大小 1.8之后就是MU CCSC 压缩类空间容量 CCSU 压缩类空间使用大小 YGC 从应用程序启动以来年轻代GC的次数 YGCT 从应用城区启动以来年轻代GC所用时间 FGC 从应用程序启动以来FullGC的次数 FGCT 从应用程序启动以来FullGC使用时间 GCT 从应用程序启动以来GC使用的事件 新生代的内存统计1jstat -gcnewcapacity [进程号] NGCMN 新生代最小容量 NGCMX 新生代最大容量 NGC 当前新生代容量 EC 当前eden区容量大小 ECMX 当前eden区最大容量大小 S0C 第一个幸存区容量大小 S0CMX 第一个幸存区最大容量大小 S1C 第二个幸存区容量大小 S1CMX 第二个幸存区最大容量大小 YGC 年轻代垃圾回收次数 FGC 老年代垃圾回收次数 新生代垃圾回收统计1jstat -gcnew [进程号] EC eden区的容量 EU eden区使用大小 S0C 第一个幸存区的容量 S0U 第一个幸存区使用大小 S1C 第二个幸存区容量 S1U 第二个幸存区使用大小 TT 对象在新生代存活的次数 MTT 对象在新生代存活的最大次数 DSS 期望的幸存区大小 YGC 年轻代GC次数 YGCT 年轻代GC消耗时间 老年代内存统计1jstat -gcoldcapacity [进程号] OGCMN 老年代最小容量大小 OGCMX 老年代最大容量大小 OGC 当前老年代容量大小 OC 老年代容量大小 YGC FGC FGCT GCT 老年代垃圾回收统计1jstat -gcold [进程号] MC 方法区大小 MU 方法区使用大小 OC 老年代大小 OU 老年代使用大小 CCSC 压缩类空间大小 CCSU 压缩类空间使用大小 YGC FGC FGCT GCT 元数据空间内存统计 MCMN 元数据区最小空间大小 MCMX 元数据区最大空间大小 MC 当前元数据区空间大小 CCSMN CCSMX CCSC YGC FGC FGCT GCT 查看JVM内存使用百分比统计1jstat -gcutil [进程号] E eden区使用比例 S0 第一个幸存区使用比例 S1 第二个幸存区使用比例 O 老年代使用比例 M 元数据区使用比例 CCS 压缩区使用比例 YGC FGC FGCT GCT 查看JVM编译方法统计1jstat -printcompilation [进程号] Compiled 最近编译的方法数量 Size 最近编译方法的字节码数量 Type 最近编译方法的编译类型 Method 方法名标识 导出堆内存状态1jmap -dump:format=b,file=[文件名] [进程号] 分析工具:Memory Analyzer http://www.eclipse.org/mat/downloads.php // 查看对象及数量1jmap -histo [进程号] 参考：https://blog.csdn.net/wangtaomtk/article/details/52267548]]></content>
      <categories>
        <category>经典</category>
      </categories>
      <tags>
        <tag>虚拟机</tag>
        <tag>性能调优</tag>
        <tag>JVM参数</tag>
        <tag>垃圾回收</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA虚拟机之类加载器]]></title>
    <url>%2F2018%2F03%2F16%2F2018-03-16JAVA%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B9%8B%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%2F</url>
    <content type="text"><![CDATA[java虚拟机组成： 类加载器：加载类用的 执行引擎：执行java代码用的 运行时数据区：相当于操作系统内存，保存虚拟机运行时的缓存数据用的，是一块需要优化的部分 类加载器将java的.class文件按照规范加载到运行时数据区的方法区中，以供执行引擎解释执行 每个类加载器将class文件加载完之后，都会将全限定名(包名+类名)保存起来，也就是说每一个类加载器只能加载一份全限定名的class文件不同的类加载器可以加载相同的全限定名文件 java类加载器是分层级的，最顶级的类加载器是BootstrapClassLoader，其次的类加载器是ExtClassLoader，最后才是AppClassLoader结构如下所示：12345--BootstrapClassLoader 加载$JAVA_HOME$/lib/rt.jar下的类----ExtClassLoader 加载$JAVA_HOME$/lib/ext.jar下的类------AppClassLoader--------URLClassLoader spring中的类加载器----------WebappClassLoader 在tomcat中部署的每个项目都会创建一个类加载器，以保证加载的相同命名空间（不同项目、不同实现）的类加载后不同，以实现隔离项目冲突的目的 各个类加载器之间是组合的关系，不是继承的关系 双亲委派模型当一个classLoader想加载一个class文件的时候，首先从当前ClassLoader查找有没有加载过这个class，如果没有加载过就去父加载器里查有没有加载过这个class，最后直到BootstrapClassLoader顶级加载器也没有加载过这个class，才会从顶级加载器开始尝试加载这个class，然后是子加载器，最后直到当前ClassLoader都加载class失败，这个类才是加载失败! 下面是ClassLoader.loadClass的代码实现1234567891011121314151617181920212223242526272829303132333435363738protected Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException&#123; // 加载一个类的时候需要加锁，防止并发加载同一个类时出现冲突 synchronized (getClassLoadingLock(name)) &#123; // 看看这个类是否已经被当前类加载器加载过 Class&lt;?&gt; c = findLoadedClass(name); // 如果没有被加载过会返回null if (c == null) &#123; long t0 = System.nanoTime(); try &#123; // 找到当前类加载器的父类加载器加载这个命名空间下的class if (parent != null) &#123; c = parent.loadClass(name, false); &#125; else &#123;// 如果父加载器是null，则说明当前委托的类加载器已经到顶了，到BootstrapClassLoader了 c = findBootstrapClassOrNull(name); &#125; &#125; catch (ClassNotFoundException e) &#123; // ClassNotFoundException thrown if class not found // from the non-null parent class loader &#125; // 如果父加载器没有加载过这个class，并且也不能加载这个class，则只能当前类加载器尝试去加载这个类了 if (c == null) &#123; // If still not found, then invoke findClass in order // to find the class. long t1 = System.nanoTime(); c = findClass(name); // this is the defining class loader; record the stats sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0); sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1); sun.misc.PerfCounter.getFindClasses().increment(); &#125; &#125; if (resolve) &#123; resolveClass(c); &#125; return c; &#125;&#125; 测试类加载器加载顺序No1.创建下面的类，并将编译好的class文件及命名空间文件夹放到D:\temp目录下面12345public class HelloLoader &#123; public void print() &#123; System.out.println("I am in BootstrapClassLoader!"); &#125;&#125; 然后修改本地HelloLoader类中的代码为：12345public class HelloLoader &#123; public void print() &#123; System.out.println("I am in AppClassLoader!"); &#125;&#125; 测试类定义：123456public class FindClassOrder &#123; public static void main(String[] args) &#123; HelloLoader helloLoader = new HelloLoader(); helloLoader.print(); &#125;&#125; 正常情况下会输出：I am in AppClassLoader! //ClassLoader加载的是本地HelloLoader定义的类 添加虚拟机运行参数：-Xbootclasspath/a:D:\temp（添加BootstrapClassLoader加载类路径的范围D:\temp） 再次运行时输出变成了：I am in BootstrapClassLoader! //ClassLoader加载的是D:\temp目录下定义的类 No2.即使配置了运行参数：-Xbootclasspath/a:D:\temp，如果AppClassLoader强行加载某个类，创建对象的时候也不会用到父加载器加载到的同命名空间下的类1234567891011121314151617181920212223242526272829303132import java.io.File;import java.io.FileInputStream;import java.lang.reflect.Method;import org.apache.commons.io.IOUtils;public class FindClassOrder &#123; public static void main(String[] args) throws Exception &#123; // 使用appClassLoader强行加载HelloLoader这个class ClassLoader classLoader = FindClassOrder.class.getClassLoader(); byte[] bHelloLoader = loadClassBytes("D:\\temp\\com\\test\\HelloLoader.class"); Method defineClassMethod = ClassLoader.class.getDeclaredMethod("defineClass", byte[].class,int.class,int.class); defineClassMethod.setAccessible(true); defineClassMethod.invoke(classLoader, new Object[]&#123;bHelloLoader,0,bHelloLoader.length&#125;); defineClassMethod.setAccessible(false); // 当前AppClassLoader强行加载了HelloLoader这个类，就不会再使用父加载器加载的这个类了 HelloLoader helloLoader = new HelloLoader(); helloLoader.print(); &#125; public static byte[] loadClassBytes(String filePath) throws Exception &#123; return IOUtils.toByteArray(new FileInputStream(new File(filePath))); &#125; /* &lt;!-- https://mvnrepository.com/artifact/commons-io/commons-io --&gt; IOUtils使用到的jar包 &lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.6&lt;/version&gt; &lt;/dependency&gt; */&#125; 双亲委托模型的弊端：父类加载器无法访问子类加载器的对象。比如父类加载器定义一个接口，同时绑定一个工厂方法，由于接口实现类不在父加载器中，所以无法访问和创建实例 No3.父加载器加载的类，不能访问加载子加载器加载的类1.编译下面java，将class文件放入D:\temp目录下面1234567public class HelloLoader &#123; public void print() &#123; System.out.println("I am in BootstrapClassLoader!"); System.out.println(Thread.currentThread().getContextClassLoader()); new HelloChildLoader().print(); &#125;&#125; 2.本地java1234567public class HelloLoader &#123; public void print() &#123; System.out.println("I am in AppClassLoader!"); System.out.println(Thread.currentThread().getContextClassLoader()); new HelloChildLoader().print(); &#125;&#125; 12345public class HelloChildLoader &#123; public void print() &#123; System.out.println("I am HelloChildLoader!"); &#125;&#125; 123456public class FindClassOrder &#123; public static void main(String[] args) &#123; HelloLoader helloLoader = new HelloLoader(); helloLoader.print(); &#125;&#125; 上面的main方法运行之后输出结果：12345I am in BootstrapClassLoader! sun.misc.Launcher$AppClassLoader@c387f44 &lt;br&gt;Exception in thread "main" java.lang.NoClassDefFoundError: com/test/HelloChildLoader at com.test.HelloLoader.print(HelloLoader.java:7)at com.test.FindClassOrder.main(FindClassOrder.java:6) 修改main方法：1234567891011121314151617181920212223import java.io.File;import java.io.FileInputStream;import java.lang.reflect.Method;import org.apache.commons.io.IOUtils;public class FindClassOrder &#123; public static void main(String[] args) throws Exception &#123; // 使用appClassLoader强行加载HelloLoader这个class ClassLoader classLoader = FindClassOrder.class.getClassLoader(); byte[] bHelloLoader = loadClassBytes("D:\\tmp\\com\\test\\HelloLoader.class"); Method defineClassMethod = ClassLoader.class.getDeclaredMethod("defineClass", byte[].class,int.class,int.class); defineClassMethod.setAccessible(true); defineClassMethod.invoke(classLoader, new Object[]&#123;bHelloLoader,0,bHelloLoader.length&#125;); defineClassMethod.setAccessible(false); // 当前AppClassLoader强行加载了HelloLoader这个类，就不会再使用父加载器加载的这个类了 HelloLoader helloLoader = new HelloLoader(); helloLoader.print(); &#125; public static byte[] loadClassBytes(String filePath) throws Exception &#123; return IOUtils.toByteArray(new FileInputStream(new File(filePath))); &#125;&#125; 运行上面代码，结果如下：123I am in BootstrapClassLoader!sun.misc.Launcher$AppClassLoader@c387f44I am HelloChildLoader! 以上结果表明： 父类加载器加载的class不能直接创建子类加载器加载的类，因为父类加载器没有访问子类加载器加载的类的权限 解决方法： 父类加载器使用Thread.currentThread().getContextClassLoader()可以获取到子类加载器ClassLoader，进而可以创建子类加载器加载的对象 以下是测试用例：创建一个待被应用类加载器加载的类HelloChildLoader12345public class HelloChildLoader &#123; public void print() &#123; System.out.println("this is HelloChildLoader!"); &#125;&#125; 将下面编译后的class拷贝到D:\temp目录下123456public class HelloLoader &#123; public void print() throws Exception &#123; System.out.println("I am in BootstrapClassLoader!"); new HelloChildLoader().print(); &#125;&#125; 本地HelloLoader实现如下123456public class HelloLoader &#123; public void print() throws Exception &#123; System.out.println("I am in AppClassLoader!"); new HelloChildLoader().print(); &#125;&#125; 测试类代码如下：123456public class FindClassOrder &#123; public static void main(String[] args) throws Exception &#123; HelloLoader helloLoader = new HelloLoader(); helloLoader.print(); &#125;&#125; 配置虚拟机运行时参数：-Xbootclasspath/a:D:\temp运行后结果如下：1234I am in BootstrapClassLoader!Exception in thread &quot;main&quot; java.lang.NoClassDefFoundError: com/test/classloader/HelloChildLoader at com.test.classloader.HelloLoader.print(HelloLoader.java:6) at com.test.classloader.FindClassOrder.main(FindClassOrder.java:6) 以上运行结果表明，启动类加载器不能直接加载和创建应用类加载器的类对象 修改D:\temp目录下的类实现：1234567891011public class HelloLoader &#123; public void print() throws Exception &#123; System.out.println("I am in BootstrapClassLoader!"); ClassLoader classLoader = Thread.currentThread().getContextClassLoader(); Class&lt;?&gt; helloChildLoaderClazz = Class.forName("com.test.classloader.HelloChildLoader", false, classLoader); // 这里如果启动类加载器定义了HelloChildLoader的接口，就直接用接口接收就可以了，不用反射调用了 Object helloChildLoader = helloChildLoaderClazz.newInstance(); Method printMethod = helloChildLoaderClazz.getDeclaredMethod("print",new Class[]&#123;&#125;); printMethod.invoke(helloChildLoader, new Object[]&#123;&#125;); &#125;&#125; 执行main方法运行结果如下：12I am in BootstrapClassLoader!this is HelloChildLoader! 上面运行结果表明： 启动类加载器加载的类中，我们可以通过应用类加载器(通过Thread.currentThread().getContextClassLoader()获取)和要加载应用类的全限定名，我们就可以得到应用类加载器的实例对象 热部署自定义一个ClassLoader，用于实现热部署12345678910111213141516171819202122232425262728public class MyClassLoader extends ClassLoader &#123; private String fileName; public MyClassLoader(String fileName) &#123; this.fileName = fileName; &#125; @Override protected Class&lt;?&gt; findClass(String className) throws ClassNotFoundException &#123; Class&lt;?&gt; clazz = this.findLoadedClass(className); // 如果当前类被加载过，就不会重复去加载 if (clazz == null) &#123; try &#123; String classFile = getClassFile(className); byte[] bytes = IOUtils.toByteArray(new FileInputStream(new File(classFile))); return super.defineClass(className, bytes, 0, bytes.length); &#125; catch (FileNotFoundException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; return clazz; &#125; private String getClassFile(String classFile) &#123; return this.fileName + "/" + classFile.replaceAll("[.]", "/") + ".class"; &#125;&#125; 定义一个需要热部署的类12345public class DemoA &#123; public void hot()&#123; System.out.println("OldDemoA is Running!"); &#125;&#125; 测试类代码123456789101112131415161718192021public class DoopRun &#123; public static void main(String[] args) &#123; while(true)&#123; try &#123; // 每次循环都重新创建MyClassLoader保证没有加载过DemoA这个类 MyClassLoader loader = new MyClassLoader("D:\\temp"); Class&lt;?&gt; clazz = loader.loadClass("com.test.classloader.DemoA"); Object demoA = clazz.newInstance(); Method m = demoA.getClass().getMethod("hot", new Class[]&#123;&#125;); m.invoke(demoA, new Object[]&#123;&#125;); &#125; catch (Exception e) &#123; System.out.println("not find!"); &#125; try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 将DemoA.class文件放入D:\temp目录下面，并保证当前main启动环境下没有这个类定义启动main，每隔一段时间输出打印”OldDemoA is Running!”，结果如下：123OldDemoA is Running!OldDemoA is Running!OldDemoA is Running! 修改D:\temp目录下的DemoA类定义为下面代码：12345public class DemoA &#123; public void hot()&#123; System.out.println("NewDemoA is Running!"); &#125;&#125; 然后覆盖到D:\temp目录下面，输出打印变成如下：1234OldDemoA is Running!NewDemoA is Running!NewDemoA is Running!NewDemoA is Running!]]></content>
      <categories>
        <category>经典</category>
      </categories>
      <tags>
        <tag>虚拟机</tag>
        <tag>类加载器</tag>
        <tag>classloader</tag>
        <tag>双亲委派模型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[idea工具的使用]]></title>
    <url>%2F2018%2F02%2F21%2F2018-02-21idea%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[最近开始使用idea开发工具开发项目，很多配置与eclipse中的配置不一样，特整理一些配置方法 idea配置maven仓库File -&gt; Settings -&gt; 搜索”maven”关键字 -&gt; 将”Always update snapshots”按钮勾选上，将”User settings file”配置好，如下图所示 在当前工作窗口，导入第二个工程 File -&gt; Project structure…(或直接按Ctrl+Alt+Shift+S) -&gt; 选择Modules选项卡 -&gt; 点击”+”按钮添加模块 -&gt; Import Module -&gt; 选择项目文件夹 -&gt; 选择项目类型，之后就可以在Project窗口看到添加的项目了 idea设置自动编译 File -&gt; Settings -&gt; Build… -&gt; Compiler -&gt; 选中Build project automatically 和 compile independent modules in parallel按钮，如下图所示 快速创建一个main方法快捷键： psvm 快速输入System.out.println()快捷键：sout 生成构造器、getter、setter方法 Alt+Insert 自动填充变量名称 Ctrl+Alt+V 获取注册码参考博客：https://blog.csdn.net/halen001/article/details/81137092 我使用的是第三种方式： idea版本：idea 2018.2.2 (Ultimate Edition) 修改hosts文件：C:\Windows\System32\drivers\etc\hosts 将下面配置追加到文件末尾10.0.0.0 account.jetbrains.com 使用下面注册码注册1K71U8DBPNE-eyJsaWNlbnNlSWQiOiJLNzFVOERCUE5FIiwibGljZW5zZWVOYW1lIjoibGFuIHl1IiwiYXNzaWduZWVOYW1lIjoiIiwiYXNzaWduZWVFbWFpbCI6IiIsImxpY2Vuc2VSZXN0cmljdGlvbiI6IkZvciBlZHVjYXRpb25hbCB1c2Ugb25seSIsImNoZWNrQ29uY3VycmVudFVzZSI6ZmFsc2UsInByb2R1Y3RzIjpbeyJjb2RlIjoiSUkiLCJwYWlkVXBUbyI6IjIwMTktMDUtMDQifSx7ImNvZGUiOiJSUzAiLCJwYWlkVXBUbyI6IjIwMTktMDUtMDQifSx7ImNvZGUiOiJXUyIsInBhaWRVcFRvIjoiMjAxOS0wNS0wNCJ9LHsiY29kZSI6IlJEIiwicGFpZFVwVG8iOiIyMDE5LTA1LTA0In0seyJjb2RlIjoiUkMiLCJwYWlkVXBUbyI6IjIwMTktMDUtMDQifSx7ImNvZGUiOiJEQyIsInBhaWRVcFRvIjoiMjAxOS0wNS0wNCJ9LHsiY29kZSI6IkRCIiwicGFpZFVwVG8iOiIyMDE5LTA1LTA0In0seyJjb2RlIjoiUk0iLCJwYWlkVXBUbyI6IjIwMTktMDUtMDQifSx7ImNvZGUiOiJETSIsInBhaWRVcFRvIjoiMjAxOS0wNS0wNCJ9LHsiY29kZSI6IkFDIiwicGFpZFVwVG8iOiIyMDE5LTA1LTA0In0seyJjb2RlIjoiRFBOIiwicGFpZFVwVG8iOiIyMDE5LTA1LTA0In0seyJjb2RlIjoiR08iLCJwYWlkVXBUbyI6IjIwMTktMDUtMDQifSx7ImNvZGUiOiJQUyIsInBhaWRVcFRvIjoiMjAxOS0wNS0wNCJ9LHsiY29kZSI6IkNMIiwicGFpZFVwVG8iOiIyMDE5LTA1LTA0In0seyJjb2RlIjoiUEMiLCJwYWlkVXBUbyI6IjIwMTktMDUtMDQifSx7ImNvZGUiOiJSU1UiLCJwYWlkVXBUbyI6IjIwMTktMDUtMDQifV0sImhhc2giOiI4OTA4Mjg5LzAiLCJncmFjZVBlcmlvZERheXMiOjAsImF1dG9Qcm9sb25nYXRlZCI6ZmFsc2UsImlzQXV0b1Byb2xvbmdhdGVkIjpmYWxzZX0=-Owt3/+LdCpedvF0eQ8635yYt0+ZLtCfIHOKzSrx5hBtbKGYRPFDrdgQAK6lJjexl2emLBcUq729K1+ukY9Js0nx1NH09l9Rw4c7k9wUksLl6RWx7Hcdcma1AHolfSp79NynSMZzQQLFohNyjD+dXfXM5GYd2OTHya0zYjTNMmAJuuRsapJMP9F1z7UTpMpLMxS/JaCWdyX6qIs+funJdPF7bjzYAQBvtbz+6SANBgN36gG1B2xHhccTn6WE8vagwwSNuM70egpahcTktoHxI7uS1JGN9gKAr6nbp+8DbFz3a2wd+XoF3nSJb/d2f/6zJR8yJF8AOyb30kwg3zf5cWw==-MIIEPjCCAiagAwIBAgIBBTANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTE1MTEwMjA4MjE0OFoXDTE4MTEwMTA4MjE0OFowETEPMA0GA1UEAwwGcHJvZDN5MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAxcQkq+zdxlR2mmRYBPzGbUNdMN6OaXiXzxIWtMEkrJMO/5oUfQJbLLuMSMK0QHFmaI37WShyxZcfRCidwXjot4zmNBKnlyHodDij/78TmVqFl8nOeD5+07B8VEaIu7c3E1N+e1doC6wht4I4+IEmtsPAdoaj5WCQVQbrI8KeT8M9VcBIWX7fD0fhexfg3ZRt0xqwMcXGNp3DdJHiO0rCdU+Itv7EmtnSVq9jBG1usMSFvMowR25mju2JcPFp1+I4ZI+FqgR8gyG8oiNDyNEoAbsR3lOpI7grUYSvkB/xVy/VoklPCK2h0f0GJxFjnye8NT1PAywoyl7RmiAVRE/EKwIDAQABo4GZMIGWMAkGA1UdEwQCMAAwHQYDVR0OBBYEFGEpG9oZGcfLMGNBkY7SgHiMGgTcMEgGA1UdIwRBMD+AFKOetkhnQhI2Qb1t4Lm0oFKLl/GzoRykGjAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBggkA0myxg7KDeeEwEwYDVR0lBAwwCgYIKwYBBQUHAwEwCwYDVR0PBAQDAgWgMA0GCSqGSIb3DQEBCwUAA4ICAQC9WZuYgQedSuOc5TOUSrRigMw4/+wuC5EtZBfvdl4HT/8vzMW/oUlIP4YCvA0XKyBaCJ2iX+ZCDKoPfiYXiaSiH+HxAPV6J79vvouxKrWg2XV6ShFtPLP+0gPdGq3x9R3+kJbmAm8w+FOdlWqAfJrLvpzMGNeDU14YGXiZ9bVzmIQbwrBA+c/F4tlK/DV07dsNExihqFoibnqDiVNTGombaU2dDup2gwKdL81ua8EIcGNExHe82kjF4zwfadHk3bQVvbfdAwxcDy4xBjs3L4raPLU3yenSzr/OEur1+jfOxnQSmEcMXKXgrAQ9U55gwjcOFKrgOxEdek/Sk1VfOjvS+nuM4eyEruFMfaZHzoQiuw4IqgGc45ohFH0UUyjYcuFxxDSU9lMCv8qdHKm+wnPRb0l9l5vXsCBDuhAGYD6ss+Ga+aDY6f/qXZuUCEUOH3QUNbbCUlviSz6+GiRnt1kA9N2Qachl+2yBfaqUqr8h7Z2gsx5LcIf5kYNsqJ0GavXTVyWh7PYiKX4bs354ZQLUwwa/cG++2+wNWP+HtBhVxMRNTdVhSm38AknZlD+PTAsWGu9GyLmhti2EnVwGybSD2Dxmhxk3IPCkhKAK+pl0eWYGZWG3tJ9mZ7SowcXLWDFAk0lRJnKGFMTggrWjV8GYpw5bq23VmIqqDLgkNzuoog== 设置字体大小File -&gt; Settings -&gt; Color Schema font -&gt; 修改size的大小 设置使用eclipse快捷键File -&gt; Settings -&gt; keymap -&gt; 选择Eclipse即可 代买补全设置File -&gt; Settings -&gt; keymap 赋值eclipse配置方案 搜索并修改Completion-Basic快捷键为Alt+/ File -&gt; Settings -&gt; keymap -&gt; live Templates 选择默认扩展为Enter 添加Java模板组 添加main快捷键 点击define 参考博客： https://blog.csdn.net/www_wangjun/article/details/71722941]]></content>
      <categories>
        <category>整理</category>
      </categories>
      <tags>
        <tag>idea</tag>
        <tag>工具</tag>
        <tag>配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux下的常用命令]]></title>
    <url>%2F2018%2F01%2F11%2F2018-01-11Linux%E4%B8%8B%E7%9A%84%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[运行脚本失败，回车换行符问题如下报错信息：1-bash: ./start.sh: /bin/bash^M: 坏的解释器: 没有那个文件或目录 查看文件是否有^M换行符存在12345cat -v start.sh或者vi -b start.sh 或者vi start.sh 后输入命令: :e ++ff=unix start.sh 可以看到整个文件的换行都有^M符号 解决方法 使用vi打开脚本文件，输入下面命令 1:set ff=unix 使用cat tr命令,注意，这里的^M是Ctrl+V，Ctrl+M输入的 1cat start.sh | tr -d "^M" &gt; new_start.sh 使用sed命令替换 1sed 's/^M//g' start.sh &gt;new_start.sh 使用vi打开文件，输入下面命令,或者直接使用vi -b 文件名的方式打开文件 1:e ++ff=unix start.sh // 以unix格式打开文件 然后执行替换命令,这里的^M也是通过Ctrl+V，Ctrl+M输入的1:%s/^M//g 查看命令可以输入下面指令123:h ++:h ff:h ffs]]></content>
      <categories>
        <category>整理</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>vi</tag>
        <tag>vim</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java线程池源码解析]]></title>
    <url>%2F2018%2F01%2F09%2F2018-01-09Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%8A%80%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[线程池使用背景多线程任务获取线程的方法 new Thread() 使用线程池 众所周知，创建一个线程是需要消耗很多的系统资源，如果随意创建大量无用的执行短生命周期任务的线程，会占用过多系统资源导致死机或者OOM 相比直接创建线程，我们使用线程池的技术会有很多好处 重用线程，减少线程创建、消亡的开销，性能更佳 可以控制线程创建的数量，提高系统资源的使用率，同时可以避免更多线程运行时的资源竞争，避免堵塞 可以提供定时任务执行，定期执行，单线程执行，并发数控制等功能 通过Executors创建四种线程池Java通过Executors可以提供四种线程池的创建，分别是 newCachedThreadPool 创建一个可以缓存的线程池，如果线程池线程数量超过处理需要，可以灵活收回线程，若需要更多线程，则新建线程 newFixedThreadPool 创建一个确定线程数量的线程池，可以控制线程最大并发数，超出的线程就需要放入队列等待 newScheduledThreadPool 创建一个确定线程数量的线程池，支持定时及周期性的执行任务 newSingleThreadPool 创建一个单线程的线程池，单线程执行处理所有的任务，保证任务执行顺序是FIFO或LIFO。 newCachedThreadPool()创建线程池 1234567ExecutorService cachedThreadPool = Executors.newCachedThreadPool();// 实际创建对象ThreadPoolExecutor，最大线程数是Integer的最大值，相当于不限制线程数public static ExecutorService newCachedThreadPool() &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;());&#125; newFixedThreadPool(10) 1234567ExecutorService fixedThreadPool = Executors.newFixedThreadPool(10);// 实际创建对象也是ThreadPoolExecutor，创建一个指定大小的线程池，线程数不能改变，超出线程数的任务放入队列中等待public static ExecutorService newFixedThreadPool(int nThreads) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;());&#125; newSingleThreadExecutor() 创建一个单线程的线程池 12345678ExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor();// 实际创建对象是FinalizableDelegatedExecutorService，传递进去一个单线程的ThreadPoolExecutor,实际还是使用ThreadPoolExecutor处理任务public static ExecutorService newSingleThreadExecutor() &#123; return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()));&#125; newScheduledThreadPool() 创建可定期执行任务的线程池 123456789ExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(10);// 创建的是一个ScheduledThreadPoolExecutor，这个类继承自ThreadPoolExecutor,实际上创建的还是ThreadPoolExecutorpublic static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) &#123; return new ScheduledThreadPoolExecutor(corePoolSize);&#125;public ScheduledThreadPoolExecutor(int corePoolSize) &#123; super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS, new DelayedWorkQueue());&#125; 线程池实现类ThreadPoolExecutor ThreadPollExecutor（newCachedThreadPool/newFixedThreadPool/newSingleThreadExecutor/newScheduledThreadPool最后都会用这个）是如何启动线程的 我们来看看ThreadPoolExecutor到底是怎么实现任务执行的123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228public class ThreadPoolExecutor extends AbstractExecutorService &#123; public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,BlockingQueue&lt;Runnable&gt; workQueue) &#123; this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, Executors.defaultThreadFactory(), defaultHandler); &#125; public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,BlockingQueue&lt;Runnable&gt; workQueue,ThreadFactory threadFactory) &#123; this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory, defaultHandler); &#125; public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,BlockingQueue&lt;Runnable&gt; workQueue,RejectedExecutionHandler handler) &#123; this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, Executors.defaultThreadFactory(), handler); &#125; // 最终都会调用到这个构造方法 public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,BlockingQueue&lt;Runnable&gt; workQueue,ThreadFactory threadFactory,RejectedExecutionHandler handler) &#123; if (corePoolSize &lt; 0 || maximumPoolSize &lt;= 0 || maximumPoolSize &lt; corePoolSize || keepAliveTime &lt; 0) throw new IllegalArgumentException(); if (workQueue == null || threadFactory == null || handler == null) throw new NullPointerException(); this.corePoolSize = corePoolSize; this.maximumPoolSize = maximumPoolSize; this.workQueue = workQueue; this.keepAliveTime = unit.toNanos(keepAliveTime); this.threadFactory = threadFactory; this.handler = handler; &#125; //-536870912 // 11100000000000000000000000000000 // 需要运行00011111111111111111111111111111个线程才会超标 private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0)); private static final int COUNT_BITS = Integer.SIZE - 3; // CAPACITY===00011111111111111111111111111111 // ~CAPACITY===11100000000000000000000000000000 private static final int CAPACITY = (1 &lt;&lt; COUNT_BITS) - 1; // 11100000000000000000000000000000 private static final int RUNNING = -1 &lt;&lt; COUNT_BITS; // 00000000000000000000000000000000 private static final int SHUTDOWN = 0 &lt;&lt; COUNT_BITS; // 00100000000000000000000000000000 private static final int STOP = 1 &lt;&lt; COUNT_BITS; // 01000000000000000000000000000000 private static final int TIDYING = 2 &lt;&lt; COUNT_BITS; // 01100000000000000000000000000000 private static final int TERMINATED = 3 &lt;&lt; COUNT_BITS; private static int runStateOf(int c) &#123; // 运行状态 // 与11100000000000000000000000000000求与操作 // 除了RUNNING状态，其它求与出来的值都是大于等于0 return c &amp; ~CAPACITY; &#125; // 统计线程数数量 private static int workerCountOf(int c) &#123; // 11100000000000000000000000000000+n个worker // 与00011111111111111111111111111111求与操作 return c &amp; CAPACITY; &#125; private static int ctlOf(int rs, int wc) &#123; return rs | wc; &#125; private static boolean isRunning(int c) &#123; // 如果状态小于0，就是在运行中 return c &lt; SHUTDOWN; &#125; public void execute(Runnable command) &#123; // 不管是execute(Runnable)还是submit(Runnable/Callable)，最后都会调用到这里 if (command == null) throw new NullPointerException(); int c = ctl.get(); if (workerCountOf(c) &lt; corePoolSize) &#123;// 如果线程数小于初始线程数，直接创建线程执行任务就可以了 if (addWorker(command, true)) return; c = ctl.get(); &#125; if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;// 看看能不能放入队列或跟空闲线程匹配上 int recheck = ctl.get(); if (! isRunning(recheck) &amp;&amp; remove(command)) reject(command); else if (workerCountOf(recheck) == 0) addWorker(null, false); &#125; else if (!addWorker(command, false)) // 线程数创建多余初始线程数了，也不能放入队列了，也没有空闲线程匹配了，还是得创建新线程执行任务 reject(command); &#125; // 这就是大名鼎鼎的addWorker,创建线程包装类Worker，执行任务队列中的任务 private boolean addWorker(Runnable firstTask, boolean core) &#123; // 创建线程执行新任务 retry: for (;;) &#123; int c = ctl.get(); int rs = runStateOf(c);// 看线程数，超过了536870912个就不允许新建线程了，一开始值这个值是-536870912，有点夸张了 if (rs &gt;= SHUTDOWN &amp;&amp; ! (rs == SHUTDOWN &amp;&amp; firstTask == null &amp;&amp; ! workQueue.isEmpty())) return false; for (;;) &#123; int wc = workerCountOf(c); if (wc &gt;= CAPACITY ||// 如果创建的是初始线程（core=true）超过了初始线程数，或者创建的不是初始线程（core=fase）超过了线程池最大线程数，直接返回，不创建了 wc &gt;= (core ? corePoolSize : maximumPoolSize)) return false; if (compareAndIncrementWorkerCount(c))// 增加线程数统计 break retry; c = ctl.get(); // Re-read ctl if (runStateOf(c) != rs) continue retry; &#125; &#125; boolean workerStarted = false; boolean workerAdded = false; Worker w = null; try &#123; w = new Worker(firstTask);// 创建一个Worker，间接也创建里面的一个线程，将当前任务再传递进去，创建的线程会优先处理当前的任务 final Thread t = w.thread; if (t != null) &#123; final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try &#123; int rs = runStateOf(ctl.get()); if (rs &lt; SHUTDOWN || (rs == SHUTDOWN &amp;&amp; firstTask == null)) &#123; if (t.isAlive()) // precheck that t is startable throw new IllegalThreadStateException(); //HashSet&lt;Worker&gt; workers = new HashSet&lt;Worker&gt;();这个workers是ThreadPoolExecutor中的属性 workers.add(w);// 将工作线程添加到集合中统一管理 int s = workers.size(); if (s &gt; largestPoolSize)// 更新线程池创建之后的最大并发线程数数量 largestPoolSize = s; workerAdded = true; &#125; &#125; finally &#123; mainLock.unlock(); &#125; if (workerAdded) &#123; t.start(); // 启动worker中的线程，线程持有的正好是该Worker这个Runnable，运行的时候会调用该Worker的run()方法，进而会调用ThreadPoolExecutor类中的runWorker()方法，开启处理当前任务和之后匹配到的新任务中的任务 workerStarted = true; &#125; &#125; &#125; finally &#123; if (! workerStarted) addWorkerFailed(w); &#125; return workerStarted; &#125; // 我们再来看看大名鼎鼎的Worker，任务线程封装类 private final class Worker extends AbstractQueuedSynchronizer implements Runnable&#123; // ThreadPoolExecutor的私有类 private static final long serialVersionUID = 6138294804551838833L; final Thread thread; Runnable firstTask; volatile long completedTasks; Worker(Runnable firstTask) &#123; // 将新任务传递进来 setState(-1); // inhibit interrupts until runWorker this.firstTask = firstTask; this.thread = getThreadFactory().newThread(this); &#125; public void run() &#123;// Worker.thread.start()方法启动后就会调用到这个run方法 runWorker(this);// 这个runWorker(this)方法就是ThreadPoolExecutor中的 &#125; ... &#125; // 我们再来看看大名鼎鼎的runWorker()方法 final void runWorker(Worker w) &#123;// ThreadPoolExecutor中的 Thread wt = Thread.currentThread(); Runnable task = w.firstTask; w.firstTask = null; w.unlock(); // allow interrupts boolean completedAbruptly = true; try &#123; while (task != null || (task = getTask()) != null) &#123;// 这里才是获取线程的重要地方 w.lock(); if ((runStateAtLeast(ctl.get(), STOP) || (Thread.interrupted() &amp;&amp; runStateAtLeast(ctl.get(), STOP))) &amp;&amp; !wt.isInterrupted()) wt.interrupt(); try &#123; beforeExecute(wt, task); Throwable thrown = null; try &#123; task.run(); &#125; catch (RuntimeException x) &#123; thrown = x; throw x; &#125; catch (Error x) &#123; thrown = x; throw x; &#125; catch (Throwable x) &#123; thrown = x; throw new Error(x); &#125; finally &#123; afterExecute(task, thrown); &#125; &#125; finally &#123; task = null; w.completedTasks++; w.unlock(); &#125; &#125; completedAbruptly = false; &#125; finally &#123; processWorkerExit(w, completedAbruptly); &#125; &#125; // 我们再来看看大名鼎鼎的runWorker()-&gt;getTask()方法 private Runnable getTask() &#123; boolean timedOut = false; for (;;) &#123; int c = ctl.get(); int rs = runStateOf(c); if (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123; decrementWorkerCount(); return null; &#125; int wc = workerCountOf(c); boolean timed = allowCoreThreadTimeOut || wc &gt; corePoolSize; if ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut)) &amp;&amp; (wc &gt; 1 || workQueue.isEmpty())) &#123; if (compareAndDecrementWorkerCount(c)) return null; continue; &#125; try &#123; Runnable r = timed ? // 这下真相大白了，所有的任务(排除newCachedThreadPool的firstTask)都是通过不同线程池里的不同队列中获取到的，至于任务入队、任务出队的具体实现，下面我们会详细讲解 workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) : workQueue.take(); if (r != null) return r; timedOut = true; &#125; catch (InterruptedException retry) &#123; timedOut = false; &#125; &#125; &#125; 。。。&#125; newCachedThreadPoolexecute(Runnable)的任务封装和任务运行任务封装都是将Runnable原封不动的放入队列中，根本就不进行封装 任务运行直接调用传进来的Runnable.run()方法就可以了 submit(Runnable)的任务封装和任务运行任务封装123456789101112131415161718// 封装成FutureTaskpublic Future&lt;?&gt; submit(Runnable task) &#123; if (task == null) throw new NullPointerException(); RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, null); execute(ftask); return ftask;&#125;protected &lt;T&gt; RunnableFuture&lt;T&gt; newTaskFor(Runnable runnable, T value) &#123; return new FutureTask&lt;T&gt;(runnable, value);// 封装成FutureTask&#125;public FutureTask(Runnable runnable, V result) &#123; this.callable = Executors.callable(runnable, result);// 本质是要创建FutureTask中的一个callable，这样在FutureTask-&gt;run()方法中就可以调用callable.call()方法了/*public static &lt;T&gt; Callable&lt;T&gt; callable(Runnable task, T result) &#123; if (task == null) throw new NullPointerException(); return new RunnableAdapter&lt;T&gt;(task, result);// 封装一个RunnableAdapter当做FutureTask的callable，这样就在调用FutureTask-&gt;run()的时候callable.call()方法了&#125;*/ this.state = NEW; // ensure visibility of callable&#125; 任务运行执行FutureTask.run()方法1234567891011121314151617181920212223242526272829303132333435363738public void run() &#123; if (state != NEW || !UNSAFE.compareAndSwapObject(this, runnerOffset,null, Thread.currentThread())) return; try &#123; Callable&lt;V&gt; c = callable; if (c != null &amp;&amp; state == NEW) &#123; V result; boolean ran; try &#123; result = c.call();// 调用自己的callable属性值的call()方法，本质就是调用RunnableAdapter.call()方法/*static final class RunnableAdapter&lt;T&gt; implements Callable&lt;T&gt; &#123; final Runnable task; final T result; RunnableAdapter(Runnable task, T result) &#123; this.task = task; // 这个是传递进来的Runnable任务 this.result = result; // 这里可定设置的null或默认值 &#125; public T call() &#123; task.run();// 执行Runnable.run()方法 return result; &#125;&#125;*/ ran = true; &#125; catch (Throwable ex) &#123; result = null; ran = false; setException(ex); &#125; if (ran) set(result); &#125; &#125; finally &#123; runner = null; int s = state; if (s &gt;= INTERRUPTING) handlePossibleCancellationInterrupt(s); &#125; &#125; submit(Callable)的任务封装和任务运行任务封装1234567891011121314public &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task) &#123; if (task == null) throw new NullPointerException(); RunnableFuture&lt;T&gt; ftask = newTaskFor(task);// 这里同样也是要封装成FutureTask，只不过这次封装的是Callable类型的任务，那就更容易了 execute(ftask); return ftask;&#125;protected &lt;T&gt; RunnableFuture&lt;T&gt; newTaskFor(Callable&lt;T&gt; callable) &#123; return new FutureTask&lt;T&gt;(callable);&#125;public FutureTask(Callable&lt;V&gt; callable) &#123; if (callable == null) throw new NullPointerException(); this.callable = callable; // 都不用转换，直接赋值给callable属性就可以了 this.state = NEW; // ensure visibility of callable&#125; 任务运行因为封装成的FutureTask的属性callable就是传递进去的Callable任务，运行的时候直接调用到了Callable任务自己实现的业务逻辑了 FutureTask.run()-&gt;callable.call()&lt;==&gt;自己实现的Callable接口任务类.call()方法 任务入队和任务出队 execute(Runnable),submit(Runnable/Callable)入队、出队实现逻辑都是一样的 任务入队不管是execute()还是submit()，最后都会调用到execute(Runnable command)方法，如果是submit(Callable)，会将Callable转换成FutureTask，这个FutureTask也同样是一个Runnable类型的实现类，为什么要实现Runnable接口？完全可以实现Callable接口啊，拿到任务后RutureTask.call()就行了，估计场景不一样，FutureTask本来就不会立即运行的意思，就不要实现Callable接口了吧 123456789101112131415161718192021// 添加任务运行public void execute(Runnable command) &#123; if (command == null) throw new NullPointerException(); int c = ctl.get(); if (workerCountOf(c) &lt; corePoolSize) &#123;// 如果线程数小于初始线程数，直接创建线程执行任务就可以了，注意：newCachedThreadPool创建的线程池初始线程数为0，最大线程数数量没有限制，所以一直都不会走这个逻辑 if (addWorker(command, true)) return; c = ctl.get(); &#125; // 对newCachedThreadPool线程池来说，使用的是SynchronousQueue队列，必须有空闲线程的情况下才会走这个方法体 // 对于newFixedThreadPool(5)使用的队列是LinkedBlockingQueue，可以方Integer.MAX_VALUE个任务进去 if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123; int recheck = ctl.get(); if (! isRunning(recheck) &amp;&amp; remove(command)) reject(command); else if (workerCountOf(recheck) == 0) addWorker(null, false); &#125; else if (!addWorker(command, false)) // 没空闲线程的情况下走这里，如果新任务加入不了队列中，只能新建线程去处理这个任务了 reject(command);&#125; 我们先看看没空闲线程的情况下，任务怎么入队列，调用的是上面的这个代码块 12else if (!addWorker(command, false)) // 没空闲线程的情况下走这里，如果新任务加入不了队列中，只能新建线程去处理这个任务了 reject(command) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179private boolean addWorker(Runnable firstTask, boolean core) &#123; // 创建线程执行新任务 retry: for (;;) &#123; int c = ctl.get(); int rs = runStateOf(c);// 看线程数，超过了536870912个就不允许新建线程了，一开始值这个值是-536870912，有点夸张了 if (rs &gt;= SHUTDOWN &amp;&amp; ! (rs == SHUTDOWN &amp;&amp; firstTask == null &amp;&amp; ! workQueue.isEmpty())) return false; for (;;) &#123; int wc = workerCountOf(c); if (wc &gt;= CAPACITY ||// 如果创建的是初始线程（core=true）超过了初始线程数，或者创建的不是初始线程（core=fase）超过了线程池最大线程数，直接返回，不创建了 wc &gt;= (core ? corePoolSize : maximumPoolSize)) return false; if (compareAndIncrementWorkerCount(c))// 增加线程数统计 break retry; c = ctl.get(); // Re-read ctl if (runStateOf(c) != rs) continue retry; &#125; &#125; boolean workerStarted = false; boolean workerAdded = false; Worker w = null; try &#123; w = new Worker(firstTask);// 创建一个Worker，间接也创建里面的一个线程，将当前任务再传递进去，创建的线程会优先处理当前的任务 final Thread t = w.thread; if (t != null) &#123; final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try &#123; int rs = runStateOf(ctl.get()); if (rs &lt; SHUTDOWN || (rs == SHUTDOWN &amp;&amp; firstTask == null)) &#123; if (t.isAlive()) // precheck that t is startable throw new IllegalThreadStateException(); //HashSet&lt;Worker&gt; workers = new HashSet&lt;Worker&gt;();这个workers是ThreadPoolExecutor中的属性 workers.add(w);// 将工作线程添加到集合中统一管理 int s = workers.size(); if (s &gt; largestPoolSize)// 更新线程池创建之后的最大并发线程数数量 largestPoolSize = s; workerAdded = true; &#125; &#125; finally &#123; mainLock.unlock(); &#125; if (workerAdded) &#123; t.start(); // 启动worker中的线程，线程持有的正好是该Worker这个Runnable，运行的时候会调用该Worker的run()方法，进而会调用ThreadPoolExecutor类中的runWorker()方法，开启处理当前任务和之后匹配到的新任务中的任务 workerStarted = true; &#125; &#125; &#125; finally &#123; if (! workerStarted) addWorkerFailed(w); &#125; return workerStarted;&#125;// 创建Worker实例，就会创建一个新线程，在调用worker.thread.start()方法后就会调用该实例中的run()方法private final class Worker extends AbstractQueuedSynchronizer implements Runnable&#123; // ThreadPoolExecutor的私有类 private static final long serialVersionUID = 6138294804551838833L; final Thread thread; Runnable firstTask; volatile long completedTasks; Worker(Runnable firstTask) &#123; // 将新任务传递进来 setState(-1); // inhibit interrupts until runWorker this.firstTask = firstTask; this.thread = getThreadFactory().newThread(this); &#125; public void run() &#123;// Worker.thread.start()方法启动后就会调用到这个run方法 runWorker(this);// 这个runWorker(this)方法就是ThreadPoolExecutor中的 &#125; ...&#125;// 创建的线程开始工作了final void runWorker(Worker w) &#123; Thread wt = Thread.currentThread(); Runnable task = w.firstTask;// worker中的任务优先处理 w.firstTask = null;// 拿到firstTask后立刻清除firstTask属性的值 w.unlock(); // allow interrupts boolean completedAbruptly = true; try &#123; while (task != null || (task = getTask()) != null) &#123; // 首先会执行线程创建时的第一个任务，其次会不断查找队列中的新任务来执行/*private Runnable getTask() &#123;//这个getTask是线程获取任务的核心代码 boolean timedOut = false; // Did the last poll() time out? for (;;) &#123; int c = ctl.get(); // 看看是不是负数 int rs = runStateOf(c); // Check if queue empty only if necessary. if (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123; decrementWorkerCount(); return null; &#125; // 看看有多少个工作worker了 int wc = workerCountOf(c); // 会不会被淘汰，允许线程超时，或者工作线程大于初始线程数 boolean timed = allowCoreThreadTimeOut || wc &gt; corePoolSize; if ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut)) &amp;&amp; (wc &gt; 1 || workQueue.isEmpty())) &#123; if (compareAndDecrementWorkerCount(c)) return null; continue; &#125; try &#123; Runnable r = timed ? workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) : workQueue.take(); // 这是查找队列中的新任务的核心代码 if (r != null) return r; timedOut = true; &#125; catch (InterruptedException retry) &#123;timedOut = false;&#125; &#125;&#125;*/ w.lock(); if ((runStateAtLeast(ctl.get(), STOP) || (Thread.interrupted() &amp;&amp; runStateAtLeast(ctl.get(), STOP))) &amp;&amp; !wt.isInterrupted()) wt.interrupt();// 如果线程数过多，中断这个线程 try &#123; beforeExecute(wt, task); Throwable thrown = null; try &#123; task.run(); &#125; catch (RuntimeException x) &#123; thrown = x; throw x; &#125; catch (Error x) &#123; thrown = x; throw x; &#125; catch (Throwable x) &#123; thrown = x; throw new Error(x); &#125; finally &#123; afterExecute(task, thrown); &#125; &#125; finally &#123; task = null; w.completedTasks++; w.unlock(); &#125; &#125; completedAbruptly = false;// 突然结束了 &#125; finally &#123; processWorkerExit(w, completedAbruptly);/*private void processWorkerExit(Worker w, boolean completedAbruptly) &#123; if (completedAbruptly) // 如果是突然结束，线程数应该没有减一，现在需要减一操作 decrementWorkerCount(); final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try &#123; completedTaskCount += w.completedTasks;// 线程结束前执行任务数量进行统计 workers.remove(w);// 从线程池中将当前worker去掉 &#125; finally &#123; mainLock.unlock(); &#125; tryTerminate();// 尝试终止线程 int c = ctl.get(); if (runStateLessThan(c, STOP)) &#123; if (!completedAbruptly) &#123;// 如果不是突然结束 int min = allowCoreThreadTimeOut ? 0 : corePoolSize; // 是否允许初始线程一直保留 if (min == 0 &amp;&amp; ! workQueue.isEmpty())// 如果最小初始线程数是0，并且任务队列中不为空 min = 1;// 需要一个线程去消费任务队列 if (workerCountOf(c) &gt;= min)// 如果还有线程正在运行中，直接返回了 return; // replacement not needed &#125; addWorker(null, false);// 否则创建一个线程去处理任务吧，本线程是必须得收回了 &#125;&#125;*//*final void tryTerminate() &#123; for (;;) &#123; int c = ctl.get();// 查看执行任务数是否超标 if (isRunning(c) || // 如果仍让在运行中，直接返回 runStateAtLeast(c, TIDYING) || (runStateOf(c) == SHUTDOWN &amp;&amp; ! workQueue.isEmpty())) return;// 直接返回 ... &#125;&#125;*/ &#125;&#125; 我们再来看看有空闲线程的情况下，任务会如何入队列，这里入队列的意思就是跟空闲线程配对了，配上了直接让空闲线程执行任务，配不上还得创建线程（就像上面的addWorker）执行123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081public boolean offer(E runnable) &#123;//SynchronousQueue中的 if (e == null) throw new NullPointerException(); return transferer.transfer(runnable, true, 0) != null;&#125;//runnable, true, 0// 提交任务到空闲线程队列E transfer(E runnable, boolean timed, long nanos) &#123; //SynchronousQueue中的 SNode s = null; int mode = (runnable == null) ? REQUEST : DATA;// runnable不是null，表示要添加一个任务到空闲线程队列，runnable为null，表示获取新任务 for (;;) &#123; SNode h = head; if (h == null || h.mode == mode) &#123; // 查找有没有空闲线程，如果h为null，表示没有空闲线程，将任务添加到空闲线程队列肯定是失败的 if (timed &amp;&amp; nanos &lt;= 0) &#123; // 添加新任务的时候timed为true，nanos为0，那么就会走这里的逻辑 if (h != null &amp;&amp; h.isCancelled()) casHead(h, h.next); else return null;// 到这个地方还是没有空闲线程，只能返回null了，表示添加到空闲线程队列失败 &#125; else if (casHead(h, s = snode(s, runnable, h, mode))) &#123; 。。。//将任务添加到队列的时候这里肯定是不走的，timed=true,nanos=0 &#125; &#125; else if (!isFulfilling(h.mode)) &#123; // 添加新任务的时候head不为null并且head节点也不是DATA:1、FULFILLING:2类型节点（那么其它类型只有REQUEST:0、FULFILLING|mode:3），可以将新任务与head节点绑定，也就是将新任务与空闲线程绑定，意思就是添加到空闲线程队列成功 if (h.isCancelled()) // already cancelled casHead(h, h.next); // pop and retry else if (casHead(h, s=snode(s, runnable, h, FULFILLING|mode))) &#123;// 新增的节点模式是3（为什么不是DATA类型1？如果是DATA类型，就会走上面的if语句块中的逻辑了，这里要解决得是并发情况下前面有一个正在匹配中的新任务节点，本次新任务节点也得继续走这个逻辑块），请求的模式是DATA=1，再与FULFILLING取或预算后的值是3，也就是说所有添加到队列中的任务模式都是3/*static SNode snode(SNode s, Object e, SNode next, int mode) &#123; if (s == null) s = new SNode(e);// 创建一个新任务节点 s.mode = mode;// 模式是3 s.next = next;// 当前节点的下一个节点是头节点 return s;&#125;*/ for (;;) &#123; // loop until matched or waiters disappear SNode m = s.next; // m is s's match if (m == null) &#123; // all waiters are gone casHead(s, null); // pop fulfill node s = null; // use new node next time break; // restart main loop &#125; SNode mn = m.next; if (m.tryMatch(s)) &#123; // 这里才是真正的将新任务节点与空闲线程的head节点匹配的关键步骤/*boolean tryMatch(SNode s) &#123; if (match == null &amp;&amp; // 如果当前head节点的match属性为null UNSAFE.compareAndSwapObject(this, matchOffset, null, s)) &#123;// 将match属性设置成新添加进来的任务节点 Thread w = waiter; if (w != null) &#123; // waiters need at most one unpark waiter = null; LockSupport.unpark(w);// 将该head上等待的线程给唤醒 &#125; return true; &#125; return match == s;//看看match属性值和新添加进来的节点是否一样&#125;*/ casHead(s, mn); // pop both s and m，将head节点和对应的任务节点都删除掉 /* boolean casHead(SNode h, SNode nh) &#123; return h == head &amp;&amp; UNSAFE.compareAndSwapObject(this, headOffset, h, nh);//将第一个head节点和匹配上的任务节点都删除掉，新进来的任务节点只能与下一个head节点匹配了&#125;*/ return (E) ((mode == REQUEST) ? m.item : s.item);// 如果是请求任务数据?请求任务不走这个地方吧，就返回第一个head节点里面的Runnable，如果是新增新任务请求，就返回新任务数据 &#125; else // lost match s.casNext(m, mn); // 将新进来的任务匹配下一个空闲线程的head节点（如果有空闲线程的话），实现方案是把当前匹配到新任务的空闲线程对应的head节点剔除掉/*boolean casNext(SNode cmp, SNode val) &#123; return cmp == next &amp;&amp; UNSAFE.compareAndSwapObject(this, nextOffset, cmp, val);&#125;*/ &#125; &#125; &#125; else &#123; // 清理正在匹配中的任务节点和对应空闲线程head节点 SNode m = h.next; if (m == null) casHead(h, null); else &#123; SNode mn = m.next; if (m.tryMatch(h)) casHead(h, mn); // pop both h and m else // lost match h.casNext(m, mn); // help unlink &#125; &#125; &#125;&#125; 任务出队使用的队列是 SynchronousQueue，在线程消费完自己的第一个任务之后，会继续获取队列中的其它任务，队列SynchronousQueue获取其它任务的方法会调用到workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) 实现逻辑如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124public E poll(long timeout, TimeUnit unit) throws InterruptedException &#123; E e = transferer.transfer(null, true, unit.toNanos(timeout)); if (e != null || !Thread.interrupted()) return e; throw new InterruptedException();&#125;// null true 60000000// 从队列中获取一个Runnable的任务，不能超过规定的时间，如果超过规定的时间，就表示该线程空闲下来可以回收了E transfer(E runnable, boolean timed, long nanos) &#123; //SynchronousQueue中的 SNode s = null; // constructed/reused as needed int mode = (runnable == null) ? REQUEST : DATA;// 现在是空闲线程获取任务，这里的runnable就是null，对应的模式就是REQUEST for (;;) &#123; SNode h = head; if (h == null || h.mode == mode) &#123; // 如果没有其它空闲线程，或者头节点的模式也是REQUEST模式 if (timed &amp;&amp; nanos &lt;= 0) &#123; // 这里的代码块是肯定不会走的 。。。// 空闲线程获取任务的时候，这里肯定是走不到的，timed是true，nanos=60000000000 &#125; else if (casHead(h, s = snode(s, runnable, h, mode))) &#123;// 当前空闲线程会创建一个head节点，然后放入所有head节点的前面，优先匹配新任务，越活跃的线程就越有机会获得新任务，越不活跃的线程就越没机会获取新任务// static SNode snode(SNode s, Object e, SNode next, int mode) &#123;// if (s == null) s = new SNode(e);创建一个新的SNode节点，该节点中的任务为null// s.mode = mode;// 这个节点的类型是获取一个任务给线程// s.next = next;// 这个节点的下一个节点是h=null// return s;// 返回这个心创建的节点// &#125; SNode m = awaitFulfill(s, timed, nanos);// 这里会阻塞，直到节点中match属性不为null为止，match不为null的情况有两种，一种是超时情况下match赋值为自身，另一种是有任务时设置成任务节点// 等待任务中/*SNode awaitFulfill(SNode s, boolean timed, long nanos) &#123;//SynchronousQueue中的 final long deadline = timed ? System.nanoTime() + nanos : 0L;// 设置一个截止时间，到截止时间点了线程仍拿不到任务，就得把这个空闲线程搞掉了 Thread w = Thread.currentThread(); int spins = shouldSpin(s) ? (timed ? maxTimedSpins : maxUntimedSpins) : 0;// 是否需要自旋，如果需要自旋，判断是否需要等待时间，如果需要等待时间，就判断CPU是几核的，如果1核CPU，返回0，多核CPU返回32 //shouldSpin(s)&lt;====&gt;SNode h = head; return (h == s || h == null || isFulfilling(h.mode));// 如果头节点等于当前节点，或者头几点是空节点，或者该节点是自旋节点，都需要自旋 for (;;) &#123; if (w.isInterrupted())// 如果当前线程被中断了 s.tryCancel(); SNode m = s.match;// 获取匹配到的节点 if (m != null)// 如果拿到任务了，很顺利啊，就直接返回该任务吧 return m; if (timed) &#123;// 看看是不是需要判断是否超时 nanos = deadline - System.nanoTime(); if (nanos &lt;= 0L) &#123;// 超时了 s.tryCancel();// 将match设置成当前的Node节点 continue; &#125; &#125; if (spins &gt; 0)// 需要自旋多少次？32次 spins = shouldSpin(s) ? (spins-1) : 0; else if (s.waiter == null)// 如果这个头节点的waiter是空的，设置这个头节点的waiter为当前的线程 s.waiter = w; // establish waiter so can park next iter else if (!timed) LockSupport.park(this); else if (nanos &gt; spinForTimeoutThreshold)// 如果自旋了32次之后该线程还是没有空闲超时，就让该线程park掉剩下的空闲超时时间，默认是60秒，自旋32次，等着新任务进来main线程执行tryMatch()之后唤醒当前线程；超时后还是会在这个循环里，就会走到s.tryCancel()中的方法了 LockSupport.parkNanos(this, nanos); &#125;&#125;*/ if (m == s) &#123; // 如果拿到的节点是自身，表示线程超时了也没有新任务要处理/* void tryCancel() &#123; UNSAFE.compareAndSwapObject(this, matchOffset, null, this);//将头节点的match属性设置成自己&#125;*/ clean(s);// 超时后清理这个head节点/*void clean(SNode s) &#123; s.item = null; // forget item s.waiter = null; // forget thread SNode past = s.next; if (past != null &amp;&amp; past.isCancelled()) past = past.next; SNode p; while ((p = head) != null &amp;&amp; p != past &amp;&amp; p.isCancelled()) casHead(p, p.next); // Unsplice embedded nodes while (p != null &amp;&amp; p != past) &#123; SNode n = p.next; if (n != null &amp;&amp; n.isCancelled()) p.casNext(n, n.next); else p = n; &#125;&#125;*/ return null; &#125; if ((h = head) != null &amp;&amp; h.next == s)// 如果当前队列中的头节点是自己拿到的任务节点和对应的空闲线程head节点，将匹配成功的空闲线程head节点删除 casHead(h, s.next); // help s's fulfiller return (E) ((mode == REQUEST) ? m.item : s.item);// 如果是请求任务，就返回匹配到的任务，如果是添加任务，就返回本空闲线程head节点对应的任务（肯定是null） &#125; &#125; else if (!isFulfilling(h.mode)) &#123; // 如果有新任务正在匹配中，模式是FULFILLING|mode:3，这块逻辑也是走不到的// static boolean isFulfilling(int m) &#123; return (m &amp; FULFILLING) != 0; &#125; 。。。//getTask()的时候不会走到这个地方的逻辑 &#125; else &#123; // 清理正在匹配中的任务节点和对应空闲线程head节点 SNode m = h.next; if (m == null) casHead(h, null); else &#123; SNode mn = m.next; if (m.tryMatch(h)) casHead(h, mn); // pop both h and m else // lost match h.casNext(m, mn); // help unlink &#125; &#125; &#125;&#125;// 清理当前线程的头节点void clean(SNode s) &#123; s.item = null; // forget item s.waiter = null; // forget thread SNode past = s.next; if (past != null &amp;&amp; past.isCancelled()) past = past.next; // Absorb cancelled nodes at head SNode p; while ((p = head) != null &amp;&amp; p != past &amp;&amp; p.isCancelled()) casHead(p, p.next); // Unsplice embedded nodes while (p != null &amp;&amp; p != past) &#123; SNode n = p.next; if (n != null &amp;&amp; n.isCancelled()) p.casNext(n, n.next); else p = n; &#125;&#125; newFixedThreadPool任务封装与上面的newCachedThreadPool封装逻辑一样 任务运行与上面的newCachedThreadPool运行逻辑一样 任务入队和出队-execute(Runnable)，submit(Runnable/Callable)的入队出队逻辑都是一样的 任务入队 使用的队列是 LinkedBlockingQueue， 当创建的线程数量大于初始线程数时，执行到offer(runnalbe)的时候将新任务放入队列中去123456789101112131415161718192021222324252627282930313233343536public boolean offer(E e) &#123; if (e == null) throw new NullPointerException(); final AtomicInteger count = this.count; if (count.get() == capacity) return false; int c = -1; Node&lt;E&gt; node = new Node&lt;E&gt;(e); final ReentrantLock putLock = this.putLock; putLock.lock(); try &#123; if (count.get() &lt; capacity) &#123; enqueue(node);/*private void enqueue(Node&lt;E&gt; node) &#123; last = last.next = node;// 将当前节点放到链表的最后面&#125;*/ c = count.getAndIncrement(); if (c + 1 &lt; capacity) notFull.signal(); &#125; &#125; finally &#123; putLock.unlock(); &#125; if (c == 0) signalNotEmpty();// 通知一下别的线程，队列中有任务需要处理了/*private void signalNotEmpty() &#123; final ReentrantLock takeLock = this.takeLock; takeLock.lock(); try &#123; notEmpty.signal();// 这里是唤醒线程去执行任务 &#125; finally &#123; takeLock.unlock(); &#125;&#125;*/ return c &gt;= 0;&#125; 任务出队1234567891011121314151617181920212223242526272829303132333435boolean timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;//这个是falseRunnable r = timed ? workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) : workQueue.take();// LinkedBlockingQueue从队列中获取订单时使用这个方法 public E take() throws InterruptedException &#123; E x; int c = -1; final AtomicInteger count = this.count; final ReentrantLock takeLock = this.takeLock; takeLock.lockInterruptibly(); try &#123; while (count.get() == 0) &#123; notEmpty.await();// 空闲线程发现队列中没有任务可以执行，就await阻塞，直到被signal()为止 &#125; x = dequeue();/*private E dequeue() &#123;// 将head丢出去，垃圾回收，然后把Head后第一个节点上的任务取出来，然后把Head后第一个节点变成head节点 Node&lt;E&gt; h = head; Node&lt;E&gt; first = h.next; h.next = h; // help GC head = first; E x = first.item; first.item = null; return x;&#125;*/ c = count.getAndDecrement(); if (c &gt; 1) notEmpty.signal(); &#125; finally &#123; takeLock.unlock(); &#125; if (c == capacity) signalNotFull(); return x;&#125; newScheduledThreadPoolexecute(Runnable)的任务封装和任务运行execute(Runnable)任务封装1234567891011121314151617181920public void execute(Runnable command) &#123; schedule(command, 0, NANOSECONDS);&#125;public ScheduledFuture&lt;?&gt; schedule(Runnable command,long delay,TimeUnit unit) &#123; if (command == null || unit == null) throw new NullPointerException(); RunnableScheduledFuture&lt;?&gt; t = decorateTask(command,new ScheduledFutureTask&lt;Void&gt;(command, null,triggerTime(delay, unit)));// 返回的还是ScheduledFutureTask对象/*ScheduledFutureTask(Runnable r, V result, long ns) &#123;// 创建一个ScheduledFutureTask，其实也是FutureTask，里面会有一个callable的属性，调用call的时候就会调用runnable的run方法 super(r, result); this.time = ns; this.period = 0; this.sequenceNumber = sequencer.getAndIncrement();&#125;public FutureTask(Runnable runnable, V result) &#123; this.callable = Executors.callable(runnable, result);// return new RunnableAdapter&lt;T&gt;(task, result); 需要将runnable类型的任务转换成RunnableAdapter的类型 this.state = NEW;&#125;*/ delayedExecute(t);// 将任务放入队列中 return t;&#125; execute(Runnable) 任务运行调用ScheduledFutureTask.run()方法后 不管Runnable还是Callable，最后都会封装成ScheduledFutureTask，调用run方法的时候就是调用ScheduledFutureTask.run()方法， 最后都会调用其父类的FutureTask.run()-&gt;callable.call() 这里需要注意的是Callable类型的任务FutureTask中callable是Callable任务本身 而Runnable类型的任务FutureTask中callable是通过Executors.callable(runnable, result)创建出来的，是RunnableAdapter类型1234567891011121314151617181920212223242526272829303132333435363738394041public void run() &#123;//ScheduledThreadPoolExecutor.ScheduledFutureTask中的 boolean periodic = isPeriodic(); if (!canRunInCurrentRunState(periodic))// 如果是周期性任务返回false 如果不是周期性的任务，返回true，如果shutdown之后还是会继续运行 cancel(false); else if (!periodic) ScheduledFutureTask.super.run();// 最终会调用FutureTask.run()方法 else if (ScheduledFutureTask.super.runAndReset()) &#123; setNextRunTime(); reExecutePeriodic(outerTask); &#125;&#125;public void run() &#123; // FutureTask.run() if (state != NEW || !UNSAFE.compareAndSwapObject(this, runnerOffset, null, Thread.currentThread())) return; try &#123; Callable&lt;V&gt; c = callable; if (c != null &amp;&amp; state == NEW) &#123; V result; boolean ran; try &#123; result = c.call(); // RunnableAdapter.call() 其本质是调用这个/*public T call() &#123; task.run(); return result;&#125;*/ ran = true; &#125; catch (Throwable ex) &#123; result = null; ran = false; setException(ex); &#125; if (ran) set(result); &#125; &#125; finally &#123; runner = null; int s = state; if (s &gt;= INTERRUPTING) handlePossibleCancellationInterrupt(s); &#125;&#125; submit(Runnable)的任务封装和任务运行submit(Runnable)的任务封装12345678910public Future&lt;?&gt; submit(Runnable task) &#123; return schedule(task, 0, NANOSECONDS);&#125;public ScheduledFuture&lt;?&gt; schedule(Runnable command,long delay,TimeUnit unit) &#123;// 走到这个地方，就跟execute(Runnable)的逻辑一模一样了 if (command == null || unit == null) throw new NullPointerException(); RunnableScheduledFuture&lt;?&gt; t = decorateTask(command,new ScheduledFutureTask&lt;Void&gt;(command, null, triggerTime(delay, unit))); delayedExecute(t); return t;&#125; submit(Runnable)的任务运行既然与execute(Runnable)封装的对象都一样，那么运行时也是一样的 submit(Callable)的任务封装和任务运行submit(Callable)的任务封装123456789101112131415161718192021public Future&lt;?&gt; submit(Runnable task) &#123; // ScheduledThreadPoolExecutor中的 return schedule(task, 0, NANOSECONDS);&#125;public &lt;V&gt; ScheduledFuture&lt;V&gt; schedule(Callable&lt;V&gt; callable,long delay,TimeUnit unit) &#123; // ScheduledThreadPoolExecutor中的 if (callable == null || unit == null) throw new NullPointerException(); RunnableScheduledFuture&lt;V&gt; t = decorateTask(callable,new ScheduledFutureTask&lt;V&gt;(callable,triggerTime(delay, unit)));// 这里将会创建一个ScheduledFutureTask任务对象/*ScheduledFutureTask(Callable&lt;V&gt; callable, long ns) &#123;// ScheduledThreadPoolExecutor中的ScheduledFutureTask中的 super(callable); this.time = ns; this.period = 0; this.sequenceNumber = sequencer.getAndIncrement();&#125;public FutureTask(Callable&lt;V&gt; callable) &#123; // FutureTask中的 if (callable == null) throw new NullPointerException(); this.callable = callable;// 直接将Callable类型的任务赋值给callable属性了 this.state = NEW; &#125;*/ delayedExecute(t); return t;&#125; submit(Callable)的任务运行调用ScheduledFutureTask.run()方法后 不管Runnable还是Callable，最后都会封装成ScheduledFutureTask，调用run方法的时候就是调用ScheduledFutureTask.run()方法， 最后都会调用其父类的FutureTask.run()-&gt;callable.call() 这里需要注意的是Callable类型的任务FutureTask中callable是Callable任务本身 而Runnable类型的任务FutureTask中callable是通过Executors.callable(runnable, result)创建出来的，是RunnableAdapter类型12345678910111213141516171819202122232425262728293031323334353637public void run() &#123;//ScheduledThreadPoolExecutor.ScheduledFutureTask中的 boolean periodic = isPeriodic(); if (!canRunInCurrentRunState(periodic))// 如果是周期性任务返回false 如果不是周期性的任务，返回true，如果shutdown之后还是会继续运行 cancel(false); else if (!periodic) ScheduledFutureTask.super.run();// 最终会调用到FutureTask.run()方法 else if (ScheduledFutureTask.super.runAndReset()) &#123; setNextRunTime(); reExecutePeriodic(outerTask); &#125;&#125;public void run() &#123; if (state != NEW || !UNSAFE.compareAndSwapObject(this, runnerOffset, null, Thread.currentThread())) return; try &#123; Callable&lt;V&gt; c = callable; if (c != null &amp;&amp; state == NEW) &#123; V result; boolean ran; try &#123; result = c.call();// Callable.call()其本质是调用这个，然后返回结果 ran = true; &#125; catch (Throwable ex) &#123; result = null; ran = false; setException(ex); &#125; if (ran) set(result); &#125; &#125; finally &#123; runner = null; int s = state; if (s &gt;= INTERRUPTING) handlePossibleCancellationInterrupt(s); &#125;&#125; 任务入队和出队 execute(Runnable)、submit(Runnable/Callable)任务入队和出队逻辑都是一样的execute(Runnable)12345678910public void execute(Runnable command) &#123; schedule(command, 0, NANOSECONDS);&#125;public ScheduledFuture&lt;?&gt; schedule(Runnable command, long delay, TimeUnit unit) &#123; if (command == null || unit == null) throw new NullPointerException(); RunnableScheduledFuture&lt;?&gt; t = decorateTask(command,new ScheduledFutureTask&lt;Void&gt;(command, null, triggerTime(delay, unit))); delayedExecute(t);// 传递进去的对象都是ScheduledFutureTask return t;&#125; submit(Runnable)123456789public Future&lt;?&gt; submit(Runnable task) &#123; return schedule(task, 0, NANOSECONDS);&#125;public ScheduledFuture&lt;?&gt; schedule(Runnable command,long delay,TimeUnit unit) &#123; if (command == null || unit == null) throw new NullPointerException(); RunnableScheduledFuture&lt;?&gt; t = decorateTask(command,new ScheduledFutureTask&lt;Void&gt;(command, null,triggerTime(delay, unit))); delayedExecute(t);// 传递进去的对象都是ScheduledFutureTask return t;&#125; submit(Callable)123456789public &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task) &#123; return schedule(task, 0, NANOSECONDS);&#125;public &lt;V&gt; ScheduledFuture&lt;V&gt; schedule(Callable&lt;V&gt; callable,long delay,TimeUnit unit) &#123; if (callable == null || unit == null) throw new NullPointerException(); RunnableScheduledFuture&lt;V&gt; t = decorateTask(callable,new ScheduledFutureTask&lt;V&gt;(callable,triggerTime(delay, unit))); delayedExecute(t);// 传递进去的对象都是ScheduledFutureTask return t;&#125; 任务入队1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980private void delayedExecute(RunnableScheduledFuture&lt;?&gt; task) &#123; if (isShutdown()) reject(task); else &#123; super.getQueue().add(task);// 这里到了入队的和兴，队列类型是DelayedWorkQueue if (isShutdown() &amp;&amp; !canRunInCurrentRunState(task.isPeriodic()) &amp;&amp; remove(task)) task.cancel(false); else ensurePrestart(); &#125;&#125;// DelayedWorkQueue的add(task)是怎么处理的public boolean add(Runnable e) &#123; return offer(e);&#125;public boolean offer(Runnable x) &#123;//这里的任务是ScheduledFutureTask if (x == null) throw new NullPointerException(); RunnableScheduledFuture&lt;?&gt; e = (RunnableScheduledFuture&lt;?&gt;)x; final ReentrantLock lock = this.lock; lock.lock();// 这里插入新任务的时候需要加锁，如果不加锁的话，不停变换DelayedWorkQueue（本质是数组）的不同下标下的元素是有问题的 try &#123; int i = size; if (i &gt;= queue.length)// 这里是通过数组private RunnableScheduledFuture&lt;?&gt;[] queue = new RunnableScheduledFuture&lt;?&gt;[INITIAL_CAPACITY];来持有数据的 grow();// size = i + 1; if (i == 0) &#123;// 如果是数组的第一个任务，没什么好说的，直接摆在第一个下标位置就可以了 queue[0] = e; setIndex(e, 0);/*private void setIndex(RunnableScheduledFuture&lt;?&gt; f, int idx) &#123; if (f instanceof ScheduledFutureTask)((ScheduledFutureTask)f).heapIndex = idx;// 设置任务的heapIndex为0&#125;*/ &#125; else &#123; siftUp(i, e);// 如果数组中还有别的定时任务，那么还是排队执行吧，看谁执行时间最早，将它排在前面/*判断当前添加的任务运行时间是否比之前添加的任务早，如果需要先运行，就把这个任务跟那些后运行的任务调换位置private void siftUp(int k, RunnableScheduledFuture&lt;?&gt; key) &#123; while (k &gt; 0) &#123; int parent = (k - 1) &gt;&gt;&gt; 1; RunnableScheduledFuture&lt;?&gt; e = queue[parent]; if (key.compareTo(e) &gt;= 0) break; queue[k] = e; setIndex(e, k); k = parent; &#125; queue[k] = key; setIndex(key, k);&#125;public int compareTo(Delayed other) &#123;// 比较到底是谁需要先运行，谁需要后运行 if (other == this) // compare zero if same object return 0; if (other instanceof ScheduledFutureTask) &#123; ScheduledFutureTask&lt;?&gt; x = (ScheduledFutureTask&lt;?&gt;)other; long diff = time - x.time;// 当前任务的触发时间与上一个任务的触发时间比较 if (diff &lt; 0) return -1; else if (diff &gt; 0) return 1; else if (sequenceNumber &lt; x.sequenceNumber) return -1; else return 1; &#125; long diff = getDelay(NANOSECONDS) - other.getDelay(NANOSECONDS); return (diff &lt; 0) ? -1 : (diff &gt; 0) ? 1 : 0;&#125;*/ &#125; if (queue[0] == e) &#123;// 为什么第一个任务进来要这么处理呢 leader = null; available.signal(); &#125; &#125; finally &#123; lock.unlock(); &#125; return true;&#125; 任务出队123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137// 启动线程执行任务出队，之后就是任务执行了（暂且不管，上面有解释）void ensurePrestart() &#123; int wc = workerCountOf(ctl.get()); if (wc &lt; corePoolSize) // 如果线程数还不够初始线程数，啥也别说了，创建线程吧 addWorker(null, true); else if (wc == 0) addWorker(null, false);&#125;// 所有线程池类型的线程在拿任务的逻辑都是一样的，存活的执行生命周期中的绝大部分时间都是在运行runWorker()方法，拿任务，执行任务final void runWorker(Worker w) &#123;// ThreadPoolExecutor中的 Thread wt = Thread.currentThread(); Runnable task = w.firstTask; w.firstTask = null; w.unlock(); // allow interrupts boolean completedAbruptly = true; try &#123; while (task != null || (task = getTask()) != null) &#123;// 这里才是获取线程的重要地方 w.lock(); if ((runStateAtLeast(ctl.get(), STOP) || (Thread.interrupted() &amp;&amp; runStateAtLeast(ctl.get(), STOP))) &amp;&amp; !wt.isInterrupted()) wt.interrupt(); try &#123; beforeExecute(wt, task); Throwable thrown = null; try &#123; task.run(); &#125; catch (RuntimeException x) &#123; thrown = x; throw x; &#125; catch (Error x) &#123; thrown = x; throw x; &#125; catch (Throwable x) &#123; thrown = x; throw new Error(x); &#125; finally &#123; afterExecute(task, thrown); &#125; &#125; finally &#123; task = null; w.completedTasks++; w.unlock(); &#125; &#125; completedAbruptly = false; &#125; finally &#123; processWorkerExit(w, completedAbruptly); &#125;&#125;private Runnable getTask() &#123; boolean timedOut = false; // Did the last poll() time out? for (;;) &#123; int c = ctl.get(); int rs = runStateOf(c); if (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123; decrementWorkerCount(); return null; &#125; int wc = workerCountOf(c); boolean timed = allowCoreThreadTimeOut || wc &gt; corePoolSize; if ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut)) &amp;&amp; (wc &gt; 1 || workQueue.isEmpty())) &#123; if (compareAndDecrementWorkerCount(c)) return null; continue; &#125; try &#123; Runnable r = timed ? workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) : workQueue.take();// 最后会走到这个地方 if (r != null) return r; timedOut = true; &#125; catch (InterruptedException retry) &#123; timedOut = false; &#125; &#125;&#125;public RunnableScheduledFuture&lt;?&gt; take() throws InterruptedException &#123;// 这是DelayedWorkerQueue中的方法 final ReentrantLock lock = this.lock; lock.lockInterruptibly();// 所有线程在队列中拿任务的时候都得加锁 try &#123; for (;;) &#123; // 这里是需要不停的自旋来获取队列中的任务 RunnableScheduledFuture&lt;?&gt; first = queue[0];// 拿到第一个任务 if (first == null) available.await(); else &#123; long delay = first.getDelay(NANOSECONDS); if (delay &lt;= 0)// 看看第一个任务到运行时间了没有，到运行时间了就开始运行 return finishPoll(first);/*private RunnableScheduledFuture&lt;?&gt; finishPoll(RunnableScheduledFuture&lt;?&gt; f) &#123; int s = --size;// 队列大小 RunnableScheduledFuture&lt;?&gt; x = queue[s];// 拿到队列最后面的那个任务 queue[s] = null; if (s != 0)// 如果队列最后面的那个任务不为null，尝试将它放入队列首部（如果队列首部之后的任务都比这个最后面的任务执行时间晚的话），如果比它执行早，它还真不能放到队列首部，得按时间排队才行 siftDown(0, x); setIndex(f, -1);//设置第一个任务的heapIndex为-1 return f;// 返回第一个任务&#125;private void siftDown(int k, RunnableScheduledFuture&lt;?&gt; key) &#123;//0，和最后那个任务 尝试将最后那个任务放入队列首部（如果队列首部之后的任务都比这个最后面的任务执行时间晚的话），如果比它执行早，它还真不能放到队列首部，得按时间与队列首部之后的任务排队才行 int half = size &gt;&gt;&gt; 1;//取任务数量的半数 while (k &lt; half) &#123;// 从0开始找 int child = (k &lt;&lt; 1) + 1;// 找到子节点 RunnableScheduledFuture&lt;?&gt; c = queue[child];// 拿到子节点 int right = child + 1;// 拿到子节点相邻右边的子节点 if (right &lt; size &amp;&amp; c.compareTo(queue[right]) &gt; 0)// 比较这两个子节点，拿到最先执行的那个节点任务 c = queue[child = right]; if (key.compareTo(c) &lt;= 0)// 将队列最后那个节点与最小子节点进行比较，如果比子节点执行时间还早，就不用将子节点挪动了，直接将最后的那个队列任务放入队列中的下标是0的位置 break; queue[k] = c;// 如果队列最后的那个节点比最小子节点执行时间晚，就将最小子节点移动到0下标 setIndex(c, k); k = child;// 腾出来的下标就是刚才移走的最小子节点下标，再看看队列最后节点能否放入这个腾出来的下标下面 &#125; queue[k] = key;// 最后总会拿到一个空闲的位置（如果拿不到比最后节点执行时间还早的子节点，直接放入下标是0的位置上就可以了），将队列最后节点放到这个位置上 setIndex(key, k);// 设置heapIndex，感觉没卵用&#125;*/ first = null; if (leader != null)// 如果leader不是自己，那么我就得等待了 available.await(); else &#123; // 如果第一个任务需要等一段时间才能执行，那么这个线程在这等着吧（因为是leader嘛），其它线程可以休息了，至于等完这段时间后，这个任务会不会被自己领到，那就说不好了，因为自己已经把锁释放掉了，其它线程就可以加锁来获取任务了，在任务到执行期的前一瞬间，有个线程拿到锁了，也就理所当然的拿走了这个刚到执行期的任务 Thread thisThread = Thread.currentThread(); leader = thisThread; try &#123; available.awaitNanos(delay); &#125; finally &#123; if (leader == thisThread) leader = null; &#125; &#125; &#125; &#125; &#125; finally &#123; // 没有等待第一个任务到执行期的线程，那怎么行，得通知别的一个线程才行（本线程有可能被中断啊） if (leader == null &amp;&amp; queue[0] != null) available.signal(); lock.unlock(); &#125;&#125; 固定时间间隔执行任务1234567891011cachedExecutors.scheduleAtFixedRate(new Runnable() &#123; @Override public void run() &#123; try &#123; Thread.sleep(500); System.out.println("线程1执行完任务..."); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125;,3,1,TimeUnit.SECONDS); 相对时间间隔执行任务1234567891011cachedExecutors.scheduleWithFixedDelay(new Runnable() &#123; @Override public void run() &#123; try &#123; Thread.sleep(500); System.out.println("线程2执行完任务..."); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125;,3,1,TimeUnit.SECONDS);]]></content>
      <categories>
        <category>整理</category>
      </categories>
      <tags>
        <tag>线程池</tag>
        <tag>定时任务</tag>
      </tags>
  </entry>
</search>
