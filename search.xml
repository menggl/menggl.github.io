<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JAVA虚拟机之类加载器]]></title>
    <url>%2F2018%2F08%2F06%2FJAVA%E8%99%9A%E6%8B%9F%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[java虚拟机组成： 类加载器：加载类用的 执行引擎：执行java代码用的 运行时数据区：相当于操作系统内存，保存虚拟机运行时的缓存数据用的，是一块需要优化的部分 类加载器将java的.class文件按照规范加载到运行时数据区的方法区中，以供执行引擎解释执行 每个类加载器将class文件加载完之后，都会将(包名+类名)当做一个命名空间保存起来，也就是说每一个类加载器只能加载一份（包名+类名）的文件不同的类加载器可以加载相同的(包名+类名)文件 java类加载器是分层级的，最顶级的类加载器是BootstrapClassLoader，其次的类加载器是ExtClassLoader，最后才是AppClassLoader结构如下所示：12345--BootstrapClassLoader 加载$JAVA_HOME$/lib/rt.jar下的类----ExtClassLoader 加载$JAVA_HOME$/lib/ext.jar下的类------AppClassLoader--------URLClassLoader spring中的类加载器----------WebappClassLoader 在tomcat中部署的每个项目都会创建一个类加载器，以保证加载的相同命名空间（不同项目、不同实现）的类加载后不同，以实现隔离项目冲突的目的 各个类加载器之间是组合的关系，不是继承的关系 双亲委派模型当一个classLoader想加载一个class文件的时候，首先从当前ClassLoader查找有没有加载过这个class，如果没有加载过就去父加载器里查有没有加载过这个class，最后直到BootstrapClassLoader顶级加载器也没有加载过这个class，才会从顶级加载器开始尝试加载这个class，然后是子加载器，最后直到当前ClassLoader都加载class失败，这个类才是加载失败! 下面是ClassLoader.loadClass的代码实现1234567891011121314151617181920212223242526272829303132333435363738protected Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException&#123; // 加载一个类的时候需要加锁，防止并发加载同一个类时出现冲突 synchronized (getClassLoadingLock(name)) &#123; // 看看这个类是否已经被当前类加载器加载过 Class&lt;?&gt; c = findLoadedClass(name); // 如果没有被加载过会返回null if (c == null) &#123; long t0 = System.nanoTime(); try &#123; // 找到当前类加载器的父类加载器加载这个命名空间下的class if (parent != null) &#123; c = parent.loadClass(name, false); &#125; else &#123;// 如果父加载器是null，则说明当前委托的类加载器已经到顶了，到BootstrapClassLoader了 c = findBootstrapClassOrNull(name); &#125; &#125; catch (ClassNotFoundException e) &#123; // ClassNotFoundException thrown if class not found // from the non-null parent class loader &#125; // 如果父加载器没有加载过这个class，并且也不能加载这个class，则只能当前类加载器尝试去加载这个类了 if (c == null) &#123; // If still not found, then invoke findClass in order // to find the class. long t1 = System.nanoTime(); c = findClass(name); // this is the defining class loader; record the stats sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0); sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1); sun.misc.PerfCounter.getFindClasses().increment(); &#125; &#125; if (resolve) &#123; resolveClass(c); &#125; return c; &#125;&#125; 测试类加载器加载顺序No1.创建下面的类，并将编译好的class文件及命名空间文件夹放到D:\temp目录下面12345public class HelloLoader &#123; public void print() &#123; System.out.println("I am in BootstrapClassLoader!"); &#125;&#125; 然后修改本地HelloLoader类中的代码为：12345public class HelloLoader &#123; public void print() &#123; System.out.println("I am in AppClassLoader!"); &#125;&#125; 测试类定义：123456public class FindClassOrder &#123; public static void main(String[] args) &#123; HelloLoader helloLoader = new HelloLoader(); helloLoader.print(); &#125;&#125; 正常情况下会输出：I am in AppClassLoader! //ClassLoader加载的是本地HelloLoader定义的类 添加虚拟机运行参数：-Xbootclasspath/a:D:\temp（添加BootstrapClassLoader加载类路径的范围D:\temp） 再次运行时输出变成了：I am in BootstrapClassLoader! //ClassLoader加载的是D:\temp目录下定义的类 No2.即使配置了运行参数：-Xbootclasspath/a:D:\temp，如果AppClassLoader强行加载某个类，创建对象的时候也不会用到父加载器加载到的同命名空间下的类1234567891011121314151617181920212223242526272829303132import java.io.File;import java.io.FileInputStream;import java.lang.reflect.Method;import org.apache.commons.io.IOUtils;public class FindClassOrder &#123; public static void main(String[] args) throws Exception &#123; // 使用appClassLoader强行加载HelloLoader这个class ClassLoader classLoader = FindClassOrder.class.getClassLoader(); byte[] bHelloLoader = loadClassBytes("D:\\temp\\com\\test\\HelloLoader.class"); Method defineClassMethod = ClassLoader.class.getDeclaredMethod("defineClass", byte[].class,int.class,int.class); defineClassMethod.setAccessible(true); defineClassMethod.invoke(classLoader, new Object[]&#123;bHelloLoader,0,bHelloLoader.length&#125;); defineClassMethod.setAccessible(false); // 当前AppClassLoader强行加载了HelloLoader这个类，就不会再使用父加载器加载的这个类了 HelloLoader helloLoader = new HelloLoader(); helloLoader.print(); &#125; public static byte[] loadClassBytes(String filePath) throws Exception &#123; return IOUtils.toByteArray(new FileInputStream(new File(filePath))); &#125; /* &lt;!-- https://mvnrepository.com/artifact/commons-io/commons-io --&gt; IOUtils使用到的jar包 &lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.6&lt;/version&gt; &lt;/dependency&gt; */&#125; 双亲委托模型的弊端：父类加载器无法访问子类加载器的对象。比如父类加载器定义一个接口，同时绑定一个工厂方法，由于接口实现类不在父加载器中，所以无法访问和创建实例 No3.父加载器加载的类，不能访问加载子加载器加载的类1.编译下面java，将class文件放入D:\temp目录下面1234567public class HelloLoader &#123; public void print() &#123; System.out.println("I am in BootstrapClassLoader!"); System.out.println(Thread.currentThread().getContextClassLoader()); new HelloChildLoader().print(); &#125;&#125; 2.本地java1234567public class HelloLoader &#123; public void print() &#123; System.out.println("I am in AppClassLoader!"); System.out.println(Thread.currentThread().getContextClassLoader()); new HelloChildLoader().print(); &#125;&#125; 12345public class HelloChildLoader &#123; public void print() &#123; System.out.println("I am HelloChildLoader!"); &#125;&#125; 123456public class FindClassOrder &#123; public static void main(String[] args) &#123; HelloLoader helloLoader = new HelloLoader(); helloLoader.print(); &#125;&#125; 上面的main方法运行之后输出结果：12345I am in BootstrapClassLoader! sun.misc.Launcher$AppClassLoader@c387f44 &lt;br&gt;Exception in thread "main" java.lang.NoClassDefFoundError: com/test/HelloChildLoader at com.test.HelloLoader.print(HelloLoader.java:7)at com.test.FindClassOrder.main(FindClassOrder.java:6) 修改main方法：1234567891011121314151617181920212223import java.io.File;import java.io.FileInputStream;import java.lang.reflect.Method;import org.apache.commons.io.IOUtils;public class FindClassOrder &#123; public static void main(String[] args) throws Exception &#123; // 使用appClassLoader强行加载HelloLoader这个class ClassLoader classLoader = FindClassOrder.class.getClassLoader(); byte[] bHelloLoader = loadClassBytes("D:\\tmp\\com\\test\\HelloLoader.class"); Method defineClassMethod = ClassLoader.class.getDeclaredMethod("defineClass", byte[].class,int.class,int.class); defineClassMethod.setAccessible(true); defineClassMethod.invoke(classLoader, new Object[]&#123;bHelloLoader,0,bHelloLoader.length&#125;); defineClassMethod.setAccessible(false); // 当前AppClassLoader强行加载了HelloLoader这个类，就不会再使用父加载器加载的这个类了 HelloLoader helloLoader = new HelloLoader(); helloLoader.print(); &#125; public static byte[] loadClassBytes(String filePath) throws Exception &#123; return IOUtils.toByteArray(new FileInputStream(new File(filePath))); &#125;&#125; 运行上面代码，结果如下：123I am in BootstrapClassLoader!sun.misc.Launcher$AppClassLoader@c387f44I am HelloChildLoader! 以上结果表明： 父类加载器加载的class不能直接创建子类加载器加载的类，因为父类加载器没有访问子类加载器加载的类的权限 解决方法：父类加载器使用Thread.currentThread().getContextClassLoader()可以获取到子类加载器ClassLoader，进而可以创建子类加载器加载的对象]]></content>
      <categories>
        <category>经典</category>
      </categories>
      <tags>
        <tag>虚拟机</tag>
        <tag>类加载器</tag>
        <tag>classloader</tag>
        <tag>双亲委派模型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F08%2F06%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Hello world]]></content>
  </entry>
</search>
