<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[使用注解配置Controller的拦截器]]></title>
    <url>%2F2018%2F08%2F15%2F2018-08-15%E4%BD%BF%E7%94%A8%E6%B3%A8%E8%A7%A3%E9%85%8D%E7%BD%AEController%E7%9A%84%E6%8B%A6%E6%88%AA%E5%99%A8%2F</url>
    <content type="text"><![CDATA[上篇文章我们解决了怎么使用spring的扫描注入功能将指定包下面的拦截器注入到容器中，这篇文章我们将要解决如何更细粒度的配置请求对应的拦截器，那么我们首先想到了注解，基于注解配置可以让不同的业务请求对应到不同的拦截器调用链，好了，正文开始 我们知道要定义一个拦截器需要继承HandlerInterceptorAdapter抽象类，那么我么可以在这个接口上进行所有的拦截器的处理工作，其它拦截器来继承这个拦截器 第一步，创建AbstractHandlerInterceptor.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166import java.lang.annotation.Annotation;import javax.annotation.PostConstruct;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.web.method.HandlerMethod;import org.springframework.web.servlet.ModelAndView;import org.springframework.web.servlet.handler.HandlerInterceptorAdapter;public abstract class AbstractHandlerInterceptor extends HandlerInterceptorAdapter &#123; private static Logger logger = LoggerFactory.getLogger(AbstractHandlerInterceptor.class); /** * 覆写afterCompletion，首先判断是否通过注解校验，通过后才执行相应的拦截器逻辑 */ @Override public final void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; if (isForAction(handler)) &#123; afterView(request, response, handler, ex); &#125; &#125; /** * 子类可以实现该方法，该方法替代原HandlerInterceptorAdapter中的afterCompletion函数 * * @param request * @param response * @param handler * @param ex * @throws Exception */ protected abstract void afterView(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception; @Override public final void afterConcurrentHandlingStarted(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; // TODO Auto-generated method stub super.afterConcurrentHandlingStarted(request, response, handler); &#125; /** * 覆写postHandle，首先判断是否通过注解校验，通过后才执行相应的拦截器逻辑 */ @Override public final void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; if (isForAction(handler)) &#123; afterHandle(request, response, handler, modelAndView); &#125; &#125; /** * 子类可以实现该方法，该方法替代原HandlerInterceptorAdapter中的postHandle函数 * * @param request * @param response * @param handler * @param modelAndView * @throws Exception */ protected abstract void afterHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception; /** * 覆写preHandle */ @Override public final boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; logger.debug("interceptor className==&#123;&#125;", this.getClass().getName()); if (!isForAction(handler)) &#123; return true; &#125; return beforeHandle(request, response, handler); &#125; /** * 子类需要重新实现该方法,设置该拦截器为RequiredAnnotation类型 * * @return */ protected abstract Class&lt;? extends Annotation&gt; getRequiredAnnotationClass(); /** * 子类需要重新实现该方法，设置该拦截器为DenyAnnotation类型 * * @return */ protected abstract Class&lt;? extends Annotation&gt; getDenyAnnotationClass(); /** * 子类可以实现该方法，该方法替代原HandlerInterceptorAdapter中的preHandle函数 * * @param request * @param response * @param handler * @return * @throws Exception */ public abstract boolean beforeHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception; /** * 判断该请求是否需要走这个拦截器校验 * * @param handler * @return */ public final boolean isForAction(Object handler) &#123; // 如果该拦截器是RequiredAnnotaion类型，那么Controller中必须有该配置才会走这个拦截器校验 if (!checkRequiredAnnotations(handler)) &#123; return false; &#125; // 如果该拦截器是DenyAnnotation类型，那么Controller中必须有该配置才会不走这个拦截器校验 if (checkDenyAnnotations(handler)) &#123; return false; &#125; return true; &#125; /** * 判断Controller中有没有RequiredAnnotation的注解 * * @param handler * @return */ private boolean checkRequiredAnnotations(Object handler) &#123; Class&lt;? extends Annotation&gt; requiredAnnotation = getRequiredAnnotationClass(); if (requiredAnnotation == null) &#123; return true; &#125; HandlerMethod handlerMethod = (HandlerMethod) handler; Class&lt;?&gt; controllerClazz = handlerMethod.getBeanType(); if (handlerMethod.getMethodAnnotation(requiredAnnotation) != null || controllerClazz.getAnnotation(requiredAnnotation) != null) &#123; return true; &#125; return false; &#125; /** * 判断Controller中有没有DenyAnnotation的注解 * * @param handler * @return */ private boolean checkDenyAnnotations(Object handler) &#123; Class&lt;? extends Annotation&gt; denyAnnotation = getDenyAnnotationClass(); if (denyAnnotation == null) &#123; return false; &#125; HandlerMethod handlerMethod = (HandlerMethod) handler; Class&lt;?&gt; controllerClazz = handlerMethod.getBeanType(); if (handlerMethod.getMethodAnnotation(denyAnnotation) != null || controllerClazz.getAnnotation(denyAnnotation) != null) &#123; return true; &#125; return false; &#125; @PostConstruct public void postConstruct() &#123; Class&lt;? extends Annotation&gt; denyAnnotation = getDenyAnnotationClass(); Class&lt;? extends Annotation&gt; requiredAnnotation = getRequiredAnnotationClass(); if (denyAnnotation != null &amp;&amp; requiredAnnotation != null) &#123; throw new RuntimeException("Only one annotation can be used for the implementation class configuration"); &#125; else if (denyAnnotation == null &amp;&amp; requiredAnnotation == null) &#123; throw new RuntimeException("Annotations for implementation class configuration cannot be empty"); &#125; &#125;&#125; 第二步，创建拦截器LoginInterceptor.java和ParamInterceptor.java123456789101112131415161718192021222324252627282930313233343536373839import java.lang.annotation.Annotation;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.web.servlet.ModelAndView;import com.mgl.interceptor.annotation.DenyLoginAnnotation;import com.mgl.interceptor.annotation.Mapping;import com.mgl.interceptor.base.AbstractHandlerInterceptor;// 可以配置Mapping，也可以不配@Mapping("/test/sayHello")public class LoginInterceptor extends AbstractHandlerInterceptor &#123; private static Logger logger = LoggerFactory.getLogger(LoginInterceptor.class); @Override protected Class&lt;? extends Annotation&gt; getRequiredAnnotationClass() &#123; return null; &#125; @Override protected Class&lt;? extends Annotation&gt; getDenyAnnotationClass() &#123; return DenyLoginAnnotation.class; &#125; @Override public boolean beforeHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; logger.debug("这里进行登录校验！"); return true; &#125; @Override protected void afterView(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; &#125; @Override protected void afterHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; // TODO Auto-generated method stub &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435import java.lang.annotation.Annotation;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.web.servlet.ModelAndView;import com.mgl.interceptor.annotation.Mapping;import com.mgl.interceptor.annotation.ParamVerifyAnnotation;import com.mgl.interceptor.base.AbstractHandlerInterceptor;// 可以配置Mapping，也可以不配@Mapping("/test/sayHello")public class ParamInterceptor extends AbstractHandlerInterceptor &#123; private static Logger logger = LoggerFactory.getLogger(ParamInterceptor.class); @Override protected Class&lt;? extends Annotation&gt; getRequiredAnnotationClass() &#123; return ParamVerifyAnnotation.class; &#125; @Override protected Class&lt;? extends Annotation&gt; getDenyAnnotationClass() &#123; return null; &#125; @Override public boolean beforeHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; logger.debug("这里进行参数校验！"); return true; &#125; @Override protected void afterView(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; &#125; @Override protected void afterHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; // TODO Auto-generated method stub &#125;&#125; 第三步，创建拦截器需要用到的注解类DenyLoginAnnotation.java和ParamVerifyAnnotation.java12345678910111213import java.lang.annotation.Documented;import java.lang.annotation.ElementType;import java.lang.annotation.Inherited;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Documented@Inherited@Target(&#123; ElementType.METHOD, ElementType.TYPE &#125;)@Retention(RetentionPolicy.RUNTIME)public @interface DenyLoginAnnotation &#123; boolean check() default true;&#125; 12345678910111213import java.lang.annotation.Documented;import java.lang.annotation.ElementType;import java.lang.annotation.Inherited;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Documented@Inherited@Target(&#123; ElementType.METHOD, ElementType.TYPE &#125;)@Retention(RetentionPolicy.RUNTIME)public @interface ParamVerifyAnnotation &#123; boolean check() default true;&#125; 第四部，Controller中配置123456789101112131415import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;import com.mgl.interceptor.annotation.DenyLoginAnnotation;@Controller@RequestMapping("/test")public class TestController &#123; @RequestMapping("/sayHello") @ResponseBody // @ParamVerifyAnnotation // 添加这个注解可以走ParamInterceptor @DenyLoginAnnotation // 添加这个注解可以控制不走LoginInterceptor public String testCrossDomain() &#123; return "hello world!"; &#125;&#125; 好了，上面代码实现完成，我们可以通过之前的拦截器扫描注入功能，将这些拦截器都注入到容器了1&lt;custom:interceptor-scan base-package="com.mgl.interceptor" base-class="org.springframework.web.servlet.handler.HandlerInterceptorAdapter,com.mgl.interceptor.base.AbstractHandlerInterceptor" /&gt;]]></content>
      <categories>
        <category>经典</category>
      </categories>
      <tags>
        <tag>Interceptor</tag>
        <tag>注解配置拦截器</tag>
        <tag>Controller配置拦截器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Interceptor自动扫描注入]]></title>
    <url>%2F2018%2F08%2F14%2F2018-08-14%E6%8B%A6%E6%88%AA%E5%99%A8%E8%87%AA%E5%8A%A8%E6%89%AB%E6%8F%8F%E6%B3%A8%E5%85%A5%2F</url>
    <content type="text"><![CDATA[在项目开发中，我们经常会用到spring的拦截器功能，但是在xml配置又很麻烦，拦截器调用顺序又不好控制，所以我们在想，是不是可以使用spring的扫描功能，将拦截器按照顺序注入进去，下面我们来实现这个功能 第一步 在resourcers目录下创建下面两个文件 spring.handlers文件 1http\://www.menggl.com/schema/tools=com.test.custom.config.handler.CustomHandler spring.schemas文件 1http\://www.menggl.com/schema/custom/interceptor-scan.xsd=com/test/custom/config/handler/interceptor-scan.xsd 第二步，在com.mgl.custom.config.handler目录下创建xsd文件12345678910111213141516171819202122&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;xsd:schema xmlns="http://www.mgl.com/schema/tools" xmlns:xsd="http://www.w3.org/2001/XMLSchema" targetNamespace="http://www.mgl.com/schema/tools" xmlns:beans="http://www.springframework.org/schema/beans" xmlns:tool="http://www.springframework.org/schema/tool" elementFormDefault="qualified" attributeFormDefault="unqualified"&gt; &lt;!-- &lt;xsd:import namespace="http://www.springframework.org/schema/beans" schemaLocation="http://www.springframework.org/schema/beans/spring-beans.xsd"/&gt; &lt;xsd:import namespace="http://www.springframework.org/schema/tool" schemaLocation="http://www.springframework.org/schema/tool/spring-tool.xsd"/&gt; --&gt; &lt;xsd:element name="interceptor-scan"&gt; &lt;xsd:complexType&gt; &lt;xsd:attribute name="base-package" type="whiteSpaceTrimType" use="required"/&gt; &lt;xsd:attribute name="base-class" type="whiteSpaceTrimType" use="required"/&gt; &lt;/xsd:complexType&gt; &lt;/xsd:element&gt; &lt;xsd:simpleType name="whiteSpaceTrimType"&gt; &lt;xsd:restriction base="xsd:string"&gt; &lt;xsd:whiteSpace value="collapse"&gt;&lt;/xsd:whiteSpace&gt; &lt;/xsd:restriction&gt; &lt;/xsd:simpleType&gt;&lt;/xsd:schema&gt; 第三步 在com.mgl.custom.config.handler目录下创建CustomHandler.java12345678import org.springframework.beans.factory.xml.NamespaceHandlerSupport;import com.mgl.custom.config.parser.CustomInterceptorParser;public class CustomHandler extends NamespaceHandlerSupport &#123; @Override public void init() &#123; registerBeanDefinitionParser("interceptor-scan", new CustomInterceptorParser()); &#125;&#125; 第四步，在com.mgl.custom.config.parser目录下创建CustomInterceptorParser.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219import java.io.IOException;import java.util.ArrayList;import java.util.List;import java.util.NavigableSet;import java.util.TreeMap;import org.springframework.beans.factory.config.BeanDefinition;import org.springframework.beans.factory.config.BeanDefinitionHolder;import org.springframework.beans.factory.parsing.BeanComponentDefinition;import org.springframework.beans.factory.parsing.CompositeComponentDefinition;import org.springframework.beans.factory.support.AbstractBeanDefinition;import org.springframework.beans.factory.support.BeanDefinitionReaderUtils;import org.springframework.beans.factory.support.ManagedList;import org.springframework.beans.factory.support.RootBeanDefinition;import org.springframework.beans.factory.xml.BeanDefinitionParser;import org.springframework.beans.factory.xml.ParserContext;import org.springframework.beans.factory.xml.XmlReaderContext;import org.springframework.context.ConfigurableApplicationContext;import org.springframework.core.env.Environment;import org.springframework.core.io.Resource;import org.springframework.core.io.ResourceLoader;import org.springframework.core.io.support.ResourcePatternResolver;import org.springframework.core.io.support.ResourcePatternUtils;import org.springframework.core.type.AnnotationMetadata;import org.springframework.core.type.ClassMetadata;import org.springframework.core.type.classreading.CachingMetadataReaderFactory;import org.springframework.core.type.classreading.MetadataReader;import org.springframework.core.type.classreading.MetadataReaderFactory;import org.springframework.util.ClassUtils;import org.springframework.util.MultiValueMap;import org.springframework.util.StringUtils;import org.springframework.web.servlet.handler.MappedInterceptor;import org.w3c.dom.Element;public class CustomInterceptorParser implements BeanDefinitionParser &#123; private static final String BASE_PACKAGE_ATTRIBUTE = "base-package"; private static final String BASE_CLASS_ATTRIBUTE = "base-class"; private static final String ORDER_ANNOTATION = "org.springframework.core.annotation.Order"; private static final String MAPPING_ANNOTATION = "com.mgl.interceptor.annotation.Mapping"; private static final String EXCLUDE_MAPPING_ANNOTATION = "com.mgl.interceptor.annotation.ExcludeMapping"; private static final String DEFAULT_MAPPING_PATTERN = "/**"; private static final String[] DEFAULT_EXCLUDE_MAPPING_PATTERN = new String[] &#123; "/static/*" &#125;; private static final String RESOURCE_PATTERN = "**/*.class"; private static final int DEFAULT_ORDER = 100; private XmlReaderContext readerContext; private ResourcePatternResolver resourcePatternResolver; private Environment environment; private ResourceLoader resourceLoader; private MetadataReaderFactory metadataReaderFactory; @Override public BeanDefinition parse(Element element, ParserContext parserContext) &#123; this.readerContext = parserContext.getReaderContext(); this.environment = this.readerContext.getEnvironment(); this.resourcePatternResolver = ResourcePatternUtils.getResourcePatternResolver(this.readerContext.getResourceLoader()); this.resourceLoader = readerContext.getResourceLoader(); this.metadataReaderFactory = new CachingMetadataReaderFactory(resourceLoader); CompositeComponentDefinition compDefinition = new CompositeComponentDefinition(element.getTagName(), parserContext.extractSource(element)); parserContext.pushContainingComponent(compDefinition); String basePackage = element.getAttribute(BASE_PACKAGE_ATTRIBUTE); basePackage = this.environment.resolvePlaceholders(basePackage); String[] basePackages = StringUtils.tokenizeToStringArray(basePackage, ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS); String baseClass = element.getAttribute(BASE_CLASS_ATTRIBUTE); List&lt;String&gt; baseTypes = this.parseBaseClass(baseClass); for (String bp : basePackages) &#123; String resolvePackage = ClassUtils.convertClassNameToResourcePath(this.environment.resolveRequiredPlaceholders(bp)); String packageSearchPath = ResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX + resolvePackage + '/' + RESOURCE_PATTERN; try &#123; Resource[] resources = this.resourcePatternResolver.getResources(packageSearchPath); resources = sort(resources); for (Resource resource : resources) &#123; MetadataReader metadataReader = metadataReaderFactory.getMetadataReader(resource); ClassMetadata classMetadata = metadataReader.getClassMetadata(); if (classMetadata.isAbstract() || classMetadata.isInterface() || !classMetadata.hasSuperClass() || !validType(classMetadata, baseTypes)) &#123; continue; &#125; String className = classMetadata.getClassName(); RootBeanDefinition mappedInterceptorDef = new RootBeanDefinition(MappedInterceptor.class); mappedInterceptorDef.setSource(resource); mappedInterceptorDef.setRole(BeanDefinition.ROLE_INFRASTRUCTURE); ManagedList&lt;String&gt; includePatterns = new ManagedList&lt;String&gt;(1); String includePattern = getIncludePattern(metadataReader); if (!StringUtils.isEmpty(includePattern)) &#123; includePatterns.add(includePattern); &#125; else &#123; includePatterns.add(DEFAULT_MAPPING_PATTERN); &#125; ManagedList&lt;String&gt; excludePatterns = new ManagedList&lt;String&gt;(2); String[] excludePattern = getExcludePatterns(metadataReader); if (excludePattern != null &amp;&amp; excludePattern.length &gt; 0) &#123; for (String ep : excludePattern) &#123; excludePatterns.add(ep); &#125; &#125; else &#123; for (String ep : DEFAULT_EXCLUDE_MAPPING_PATTERN) &#123; excludePatterns.add(ep); &#125; &#125; mappedInterceptorDef.getConstructorArgumentValues().addIndexedArgumentValue(0, includePatterns); mappedInterceptorDef.getConstructorArgumentValues().addIndexedArgumentValue(1, excludePatterns); AbstractBeanDefinition beanDefinition = BeanDefinitionReaderUtils.createBeanDefinition(null, className, this.readerContext.getBeanClassLoader()); String beanName = this.readerContext.generateBeanName(beanDefinition); String beanClassName = beanDefinition.getBeanClassName(); List&lt;String&gt; aliases = new ArrayList&lt;&gt;(); if (beanClassName != null &amp;&amp; beanName.startsWith(beanClassName) &amp;&amp; beanName.length() &gt; beanClassName.length() &amp;&amp; !this.readerContext.getRegistry().isBeanNameInUse(beanClassName)) &#123; aliases.add(beanClassName); &#125; String[] aliasesArray = StringUtils.toStringArray(aliases); BeanDefinitionHolder interceptorBean = new BeanDefinitionHolder(beanDefinition, beanName, aliasesArray); mappedInterceptorDef.getConstructorArgumentValues().addIndexedArgumentValue(2, interceptorBean); String curentBeanName = parserContext.getReaderContext().registerWithGeneratedName(mappedInterceptorDef); parserContext.registerComponent(new BeanComponentDefinition(mappedInterceptorDef, curentBeanName)); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; parserContext.popAndRegisterContainingComponent(); return null; &#125; private List&lt;String&gt; parseBaseClass(String baseClass) &#123; if (StringUtils.isEmpty(baseClass)) &#123; return new ArrayList&lt;&gt;(); &#125; String[] baseTypes = baseClass.split(","); List&lt;String&gt; retTypes = new ArrayList&lt;&gt;(); if (baseTypes != null &amp;&amp; baseTypes.length &gt; 0) &#123; for (String type : baseTypes) &#123; if (!StringUtils.isEmpty(type)) &#123; retTypes.add(type); &#125; &#125; &#125; return retTypes; &#125; private String[] getExcludePatterns(MetadataReader metadataReader) &#123; List&lt;String&gt; ret = new ArrayList&lt;&gt;(); AnnotationMetadata annotationMetadata = metadataReader.getAnnotationMetadata(); MultiValueMap&lt;String, Object&gt; excludeMappingAttrs = annotationMetadata.getAllAnnotationAttributes(EXCLUDE_MAPPING_ANNOTATION); if (excludeMappingAttrs != null &amp;&amp; excludeMappingAttrs.size() &gt; 0) &#123; List&lt;Object&gt; objs = excludeMappingAttrs.get("value"); for (Object obj : objs) &#123; ret.add((String) obj); &#125; return ret.toArray(new String[ret.size()]); &#125; return null; &#125; private String getIncludePattern(MetadataReader metadataReader) &#123; AnnotationMetadata annotationMetadata = metadataReader.getAnnotationMetadata(); MultiValueMap&lt;String, Object&gt; mappingAttrs = annotationMetadata.getAllAnnotationAttributes(MAPPING_ANNOTATION); if (mappingAttrs != null &amp;&amp; mappingAttrs.size() &gt; 0) &#123; List&lt;Object&gt; objs = mappingAttrs.get("value"); String value = (String) objs.get(0); return StringUtils.isEmpty(value) ? null : value; &#125; return null; &#125; private boolean validType(ClassMetadata classMetadata, List&lt;String&gt; baseTypes) &#123; String superClassName = classMetadata.getSuperClassName(); String[] interfaceNames = classMetadata.getInterfaceNames(); for (String type : baseTypes) &#123; if (superClassName != null) &#123; if (superClassName.contains(type)) &#123; return true; &#125; &#125; if (interfaceNames != null &amp;&amp; interfaceNames.length &gt; 0) &#123; for (String interfaceName : interfaceNames) &#123; if (type.equalsIgnoreCase(interfaceName)) &#123; return true; &#125; &#125; &#125; &#125; return false; &#125; private Resource[] sort(Resource[] resources) throws IOException &#123; List&lt;Resource&gt; ret = new ArrayList&lt;Resource&gt;(); TreeMap&lt;Integer, List&lt;Resource&gt;&gt; map = new TreeMap&lt;&gt;(); for (Resource resource : resources) &#123; MetadataReader metadataReader = this.metadataReaderFactory.getMetadataReader(resource); AnnotationMetadata annotationMetadata = metadataReader.getAnnotationMetadata();// getClassMetadata(); MultiValueMap&lt;String, Object&gt; orderAttrs = annotationMetadata.getAllAnnotationAttributes(ORDER_ANNOTATION); if (orderAttrs != null) &#123; List&lt;Object&gt; values = orderAttrs.get("value"); int order = (int) values.get(0); List&lt;Resource&gt; resourceList = map.get(order); if (resourceList == null) &#123; resourceList = new ArrayList&lt;Resource&gt;(); map.put(order, resourceList); &#125; resourceList.add(resource); &#125; else &#123; List&lt;Resource&gt; resourceList = map.get(DEFAULT_ORDER); if (resourceList == null) &#123; resourceList = new ArrayList&lt;Resource&gt;(); map.put(DEFAULT_ORDER, resourceList); &#125; resourceList.add(resource); &#125; &#125; NavigableSet&lt;Integer&gt; set = map.descendingKeySet(); for (Integer key : set) &#123; ret.addAll(map.get(key)); &#125; return ret.toArray(new Resource[ret.size()]); &#125;&#125; 第五步，创建上面的parser需要的注解类Mapping.java和ExcludeMapping.java12345678910111213import java.lang.annotation.Documented;import java.lang.annotation.ElementType;import java.lang.annotation.Inherited;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Documented@Inherited@Target(&#123; ElementType.METHOD, ElementType.TYPE &#125;)@Retention(RetentionPolicy.RUNTIME)public @interface Mapping &#123; String value() default "/**";&#125; 12345678910111213import java.lang.annotation.Documented;import java.lang.annotation.ElementType;import java.lang.annotation.Inherited;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Documented@Inherited@Target(&#123;ElementType.METHOD,ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)public @interface ExcludeMapping &#123; String[] value();&#125; 第五步 在springMVC配置文件中配置命名空间及包扫描1234567xmlns:custom="http://www.mgl.com/schema/tools" xsi:schemaLocation="http://www.mgl.com/schema/tools http://www.mgl.com/schema/custom/interceptor-scan.xsd"&lt;mvc:annotation-driven /&gt;&lt;custom:interceptor-scan base-package="com.mgl.interceptor" base-class="org.springframework.web.servlet.handler.HandlerInterceptorAdapter" /&gt; 好了，我们只要将Interceptor放入com.mgl.interceptor包目录下，就可以自动注入了，还可以根据@Order进行拦截器的调用顺序控制]]></content>
      <categories>
        <category>经典</category>
      </categories>
      <tags>
        <tag>Interceptor</tag>
        <tag>自动扫描</tag>
        <tag>注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Filter实现响应结果打印]]></title>
    <url>%2F2018%2F06%2F10%2F2018-06-10Filter%E5%AE%9E%E7%8E%B0%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E5%93%8D%E5%BA%94%E7%BB%93%E6%9E%9C%E6%89%93%E5%8D%B0%2F</url>
    <content type="text"><![CDATA[在实际业务开发中，我们经常需要打印响应结果日志，方便以后问题跟踪和处理，但是我们是不能直接从response的输出流中获取结果的，为了解决这个问题，我们可以使用Filter包装一下HttpServletResponse，将输出的结果保存下来，然后在日志打印的地方直接将结果拿出来打印就可以了 以下是java代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274import com.jzg.api.config.PropertyConfigurer;import org.apache.commons.lang3.StringUtils;import org.springframework.web.filter.OncePerRequestFilter;import javax.servlet.FilterChain;import javax.servlet.ServletException;import javax.servlet.ServletOutputStream;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletRequestWrapper;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpServletResponseWrapper;import java.io.ByteArrayOutputStream;import java.io.IOException;import java.io.PrintWriter;import java.nio.charset.StandardCharsets;import java.util.*;/** * 实现HttpServletRequest获取参数值时参数名大小写不敏感 * @author menggl */public class ParameterRepositoryFilter extends OncePerRequestFilter &#123; @Override protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException &#123; String caseInsensitive = PropertyConfigurer.getContextPropString("request.parameter.case.insensitive"); //如果参数大小写不敏感 if("true".equalsIgnoreCase(caseInsensitive))&#123; filterChain.doFilter(new ParameterRepositoryRequestWrapper(request), new ResponseWrapper(response)); &#125;else&#123; filterChain.doFilter(request, new ResponseWrapper(response)); &#125; &#125; private final class ParameterRepositoryRequestWrapper extends HttpServletRequestWrapper&#123; private Map&lt;String,String[]&gt; params = new HashMap&lt;&gt;(); private Set&lt;String&gt; upperNames = new HashSet&lt;&gt;(); private boolean repeatKey = false; public ParameterRepositoryRequestWrapper(HttpServletRequest request) &#123; super(request); Enumeration&lt;String&gt; names = request.getParameterNames(); while(names.hasMoreElements())&#123; String name = names.nextElement(); String nameUpper = name.toUpperCase(); if(!upperNames.add(nameUpper))&#123; this.repeatKey = true; break; &#125;else&#123; this.params.put(nameUpper, request.getParameterValues(name)); &#125; &#125; &#125; @Override public String getParameter(String name) &#123;//super.getParameter(name); if(this.repeatKey)&#123; return super.getParameter(name); &#125; String[] values = this.params.get(name.toUpperCase()); if(values == null || values.length==0)&#123; return null; &#125; return values[0]; &#125; &#125; public final class ResponseWrapper extends HttpServletResponseWrapper&#123; ResponsePrintWriter writer; ResponseServletOutputStream output; String content = null; public ResponseWrapper(HttpServletResponse response) &#123; super(response); this.writer = new ResponsePrintWriter(new ByteArrayOutputStream(),response); this.output = new ResponseServletOutputStream(response); &#125; @Override protected void finalize() throws Throwable &#123; super.finalize(); this.writer.close(); &#125; public String getContent() throws IOException&#123; try &#123; if(content == null)&#123; this.writer.flush(); ByteArrayOutputStream output = this.writer.getOutput(); content = new String(output.toByteArray()); &#125; if(StringUtils.isEmpty(content))&#123; this.output.flush(); content = this.output.getContent(); &#125; return content; &#125; catch (Exception e) &#123; return "UnsupportedEncoding"; &#125; &#125; @Override public PrintWriter getWriter() throws IOException &#123; return writer; &#125; @Override public ServletOutputStream getOutputStream() throws IOException &#123; return this.output; &#125; &#125; public final class ResponsePrintWriter extends PrintWriter&#123; ByteArrayOutputStream output; HttpServletResponse response; boolean hasWrited = false; public ResponsePrintWriter(ByteArrayOutputStream output,HttpServletResponse response) &#123; super(output); this.output=output; this.response = response; &#125; public ByteArrayOutputStream getOutput() &#123; return this.output; &#125; @Override public void write(String s) &#123; super.write(s); if(!hasWrited)&#123; try &#123; this.response.setContentLength(-1); this.response.getWriter().write(s); &#125; catch (IOException e) &#123; logger.error("write failed,",e); &#125; &#125; hasWrited = true; &#125; @Override public void write(String s, int off, int len) &#123; super.write(s, off, len); if(!hasWrited)&#123; try &#123; this.response.setContentLength(-1); this.response.getWriter().write(s, off, len); &#125; catch (IOException e) &#123; logger.error("write failed,",e); &#125; &#125; hasWrited = true; &#125; @Override public void write(char[] buf) &#123; super.write(buf); if(!hasWrited)&#123; try &#123; this.response.setContentLength(-1); this.response.getWriter().write(buf); &#125; catch (IOException e) &#123; logger.error("write failed,",e); &#125; &#125; hasWrited = true; &#125; @Override public void write(char[] buf, int off, int len) &#123; super.write(buf, off, len); if(!hasWrited)&#123; try &#123; this.response.setContentLength(-1); this.response.getWriter().write(buf, off, len); &#125; catch (IOException e) &#123; logger.error("write failed,",e); &#125; &#125; hasWrited = true; &#125; @Override public void write(int c) &#123; super.write(c); if(!hasWrited)&#123; try &#123; this.response.setContentLength(-1); this.response.getWriter().write(c); &#125; catch (IOException e) &#123; logger.error("write failed,",e); &#125; &#125; hasWrited = true; &#125; &#125; public final class ResponseServletOutputStream extends ServletOutputStream&#123; HttpServletResponse response; boolean hasWrited = false; String content; byte[] bytes; public ResponseServletOutputStream(HttpServletResponse response)&#123; this.response = response; &#125; @Override public void write(int b) throws IOException &#123; this.response.getOutputStream().write(b); &#125; @Override public void print(String s) throws IOException &#123; this.content=s; if(!hasWrited)&#123; try &#123; this.response.setContentLength(-1); this.response.getOutputStream().print(s); &#125; catch (IOException e) &#123; logger.error("write failed,",e); &#125; &#125; hasWrited = true; &#125; @Override public void println(String s) throws IOException &#123; this.content=s; if(!hasWrited)&#123; try &#123; this.response.setContentLength(-1); this.response.getOutputStream().println(s); &#125; catch (IOException e) &#123; logger.error("write failed,",e); &#125; &#125; hasWrited = true; &#125; @Override public void write(byte[] b) throws IOException &#123; this.content = new String(b); if(!hasWrited)&#123; try &#123; this.response.setContentLength(-1); this.response.getOutputStream().write(b); &#125; catch (IOException e) &#123; logger.error("write failed,",e); &#125; &#125; hasWrited = true; &#125; @Override public void write(byte[] b, int off, int len) throws IOException &#123; if(!hasWrited)&#123; this.response.setContentLength(-1); &#125; if (b == null) &#123; throw new NullPointerException(); &#125; else if ((off &lt; 0) || (off &gt; b.length) || (len &lt; 0) || ((off + len) &gt; b.length) || ((off + len) &lt; 0)) &#123; throw new IndexOutOfBoundsException(); &#125; else if (len == 0) &#123; return; &#125; len = Math.min(b.length-off, len); int oldLen = bytes==null?0:bytes.length; byte[] dest = new byte[oldLen+len]; if(bytes!=null &amp;&amp; bytes.length&gt;0)&#123; System.arraycopy(bytes, 0, dest, 0, oldLen); &#125; bytes = dest; for(int i=0;i&lt;len;i++)&#123; bytes[oldLen+i] = b[off+i]; &#125; try &#123; this.response.getOutputStream().write(b, off, len); &#125; catch (IOException e) &#123; logger.error("write failed,",e); &#125; hasWrited = true; &#125; public String getContent()&#123; return this.content==null?(this.bytes==null?"":new String(bytes,StandardCharsets.UTF_8)):this.content; &#125; &#125;&#125; web.xml配置12345678&lt;filter&gt; &lt;filter-name&gt;parameterRepositoryFilter&lt;/filter-name&gt; &lt;filter-class&gt;com.menggl.api.filter.ParameterRepositoryFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;parameterRepositoryFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 使用方法12345if(ResponseWrapper.class.isAssignableFrom(response.getClass()))&#123; ResponseWrapper resp = (ResponseWrapper)response; responseStr = resp.getContent(); logger.info("返回信息：&#123;&#125;",responseStr);&#125;]]></content>
      <categories>
        <category>经典</category>
      </categories>
      <tags>
        <tag>Filter</tag>
        <tag>Log</tag>
        <tag>响应结果打印</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[zookeeper实现分布式锁和热备]]></title>
    <url>%2F2018%2F05%2F18%2F2018-05-18zookeeper%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%2F</url>
    <content type="text"><![CDATA[使用zookeeper实现分布式锁可以完美解决Redis实现分布式锁带来的弊端 基本流程： 往zookeeper中的某个永久节点上创建一个临时节点 判断创建的临时节点是否是最小的节点 如果是最小的节点，说明当前节点拿到了锁 如果不是最小节点，监听当前节点的上一个节点，如果上一个节点被删除，触发当前节点的线程去获取锁 下面是zookeeper实现分布式锁的具体代码逻辑 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656import com.google.common.collect.Maps;import com.jzg.api.util.StringUtil;import com.jzg.api.util.ThreadLocalUtil;import org.apache.commons.lang3.StringUtils;import org.apache.curator.framework.CuratorFramework;import org.apache.curator.framework.CuratorFrameworkFactory;import org.apache.curator.framework.recipes.cache.TreeCache;import org.apache.curator.framework.recipes.cache.TreeCacheEvent;import org.apache.curator.framework.recipes.cache.TreeCacheListener;import org.apache.curator.retry.ExponentialBackoffRetry;import org.apache.zookeeper.CreateMode;import org.apache.zookeeper.KeeperException;import org.apache.zookeeper.data.Stat;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.util.CollectionUtils;import javax.annotation.PostConstruct;import java.util.Collections;import java.util.List;import java.util.Map;import java.util.UUID;import java.util.concurrent.CountDownLatch;import java.util.concurrent.TimeUnit;public class ZKLock &#123; private static Logger logger = LoggerFactory.getLogger(ZKLock.class); private static final String LOCK_BASE_PATH = "/ZKLOCK"; private static final String EXECUTE_PERMISSION_BASE_PATH = "/ZKLOCK/ACTIVE/CURRENT"; private static final String EXECUTE_PERMISSION_NODE_NAME = "EPHEMERAL_NODE"; private boolean executePermission = false; private String executePermissionLockVal; private Map&lt;Integer, String&gt; currNodeNameAndIndexMap = Maps.newConcurrentMap(); private String ipPort; private int connectionTimeoutMs; private String appName = ""; private CuratorFramework client; @PostConstruct public void init() &#123; this.client = CuratorFrameworkFactory.builder().connectString(ipPort).connectionTimeoutMs(connectionTimeoutMs).retryPolicy(new ExponentialBackoffRetry(1000, 3)).build(); this.client.start(); this.executePermissionLockVal = UUID.randomUUID().toString().replaceAll("-",""); &#125; /** * 对某个key键进行尝试加锁，如果加锁失败，需要设置监听事件 * * @param lockKey * @return * @throws Exception */ public boolean tryLock(String lockKey) throws Exception &#123; try &#123; createParentNodeIfNotExists(lockKey); String currQueueNodeName = this.createCurrQueueNodeIfNotExists(lockKey); if (StringUtils.isEmpty(currQueueNodeName)) &#123; return false; &#125; return checkQueue(lockKey); &#125; catch (Exception e) &#123; String exceptionTimeTLKey = this.getExceptionTimeTLKey(lockKey); String exceptionTime = ThreadLocalUtil.getMapValue(exceptionTimeTLKey); if (StringUtils.isEmpty(exceptionTime)) &#123; ThreadLocalUtil.setMapValue(exceptionTimeTLKey, "1"); &#125; else &#123; int time = Integer.parseInt(exceptionTime); if (time &gt; 3) &#123; throw e; &#125; ThreadLocalUtil.setMapValue(exceptionTimeTLKey, new Integer(time+1).toString()); &#125; return false; &#125; &#125; private boolean checkQueue(String lockKey) throws Exception &#123; String parentNodePath = this.getParentPath(lockKey); List&lt;String&gt; childrenNodePath = findAllChildrenQueueNodeName(parentNodePath); if (CollectionUtils.isEmpty(childrenNodePath)) &#123; throw new Exception("当前占队集合为空！"); &#125; Collections.sort(childrenNodePath); String currQueueNodeName = this.getCurrQueueNameFromThreadLocal(lockKey); int idx = searchCurrQueueNodeIndex(childrenNodePath, currQueueNodeName); if (idx &lt; 0) &#123; this.resetCurrQueueNodeName(lockKey); this.resetLastQueueNodeName(lockKey); return false; &#125; else if (idx &gt; 0) &#123; String lastNodeName = this.findLastQueueNodeName(childrenNodePath, idx); String lastNodeNameTLKey = getLastNodeNameTLKey(lockKey); putThreadLocal(lastNodeNameTLKey, lastNodeName); return false; &#125; else &#123; this.resetLastQueueNodeName(lockKey); return true; &#125; &#125; /** * 创建父节点，如果父节点不存在的话 * * @param lockKey * @return * @throws Exception */ private void createParentNodeIfNotExists(String lockKey) throws Exception &#123; try &#123; String parentPath = getParentPath(lockKey); Stat stat = this.client.checkExists().forPath(parentPath); if (stat == null) &#123; try &#123; this.client.create().creatingParentsIfNeeded().withMode(CreateMode.PERSISTENT).forPath(parentPath); &#125; catch (KeeperException.NodeExistsException e) &#123; System.out.println("父节点已经创建"); &#125; &#125; &#125; catch (Exception e) &#123; logger.error("zookeeper 连接失败或无法创建节点！", e); throw e; &#125; &#125; /** * 父节点路径的ThreadLocal的key * * @param lockKey * @return */ private String getParentNodePathTLKey(String lockKey) &#123; return lockKey + "_parent_node_path"; &#125; /** * 父节点全路径的ThreadLocal的key * * @param lockKey * @return */ private String getParentNodeFullPathTLKey(String lockKey) &#123; return lockKey + "_parent_node_full_path"; &#125; /** * 记录获取锁抛出异常的次数 * * @param lockKey * @return */ private String getExceptionTimeTLKey(String lockKey) &#123; return lockKey + "_exception_time"; &#125; /** * 获取父节点路径，最后没有/ * * @param lockKey * @return */ private String getParentPath(String lockKey) &#123; String parentNodePathTLKey = getParentNodePathTLKey(lockKey); String parentNodePath = ThreadLocalUtil.getMapValue(parentNodePathTLKey); if (!StringUtils.isEmpty(parentNodePath)) &#123; return parentNodePath; &#125; else &#123; if (lockKey.startsWith("/")) &#123; if (lockKey.endsWith("/")) &#123; parentNodePath = LOCK_BASE_PATH + lockKey.substring(0, lockKey.length() - 1); &#125; else &#123; parentNodePath = LOCK_BASE_PATH + lockKey; &#125; &#125; else &#123; if (lockKey.endsWith("/")) &#123; parentNodePath = LOCK_BASE_PATH + "/" + lockKey.substring(0, lockKey.length() - 1); &#125; else &#123; parentNodePath = LOCK_BASE_PATH + "/" + lockKey; &#125; &#125; putThreadLocal(parentNodePathTLKey, parentNodePath); return parentNodePath; &#125; &#125; /** * 获取父节点路径，最后带/ * * @param lockKey * @return */ private String getParentFullPath(String lockKey) &#123; String parentNodeFullPathTLKey = this.getParentNodeFullPathTLKey(lockKey); String parentNodeFullPath = ThreadLocalUtil.getMapValue(parentNodeFullPathTLKey); if (!StringUtils.isEmpty(parentNodeFullPath)) &#123; return parentNodeFullPath; &#125; else &#123; if (lockKey.startsWith("/")) &#123; if (lockKey.endsWith("/")) &#123; parentNodeFullPath = LOCK_BASE_PATH + lockKey; &#125; else &#123; parentNodeFullPath = LOCK_BASE_PATH + lockKey + "/"; &#125; &#125; else &#123; if (lockKey.endsWith("/")) &#123; parentNodeFullPath = LOCK_BASE_PATH + "/" + lockKey; &#125; else &#123; parentNodeFullPath = LOCK_BASE_PATH + "/" + lockKey + "/"; &#125; &#125; putThreadLocal(parentNodeFullPathTLKey, parentNodeFullPath); return parentNodeFullPath; &#125; &#125; /** * 当前节点名称的ThreadLocal的key * * @param lockKey * @return */ private String getCurrNodeNameTLKey(String lockKey) &#123; return lockKey + "_curr_node_name"; &#125; /** * 获取当前排队节点的名称，如果没有，排队去获取 * * @param lockKey * @return * @throws Exception */ private String createCurrQueueNodeIfNotExists(String lockKey) throws Exception &#123; try &#123; // 对这个路径进行加锁操作 String currNodeNameTLKey = getCurrNodeNameTLKey(lockKey); String currQueueNodeName = ThreadLocalUtil.getMapValue(currNodeNameTLKey); if (StringUtil.isNullOrEmpty(currQueueNodeName)) &#123; String fullPath = getParentFullPath(lockKey); // 排队，创建临时节点 String currQueueNodePath = this.client.create().creatingParentsIfNeeded().withMode(CreateMode.EPHEMERAL_SEQUENTIAL).forPath(fullPath, "lock".getBytes()); currQueueNodeName = currQueueNodePath.substring(fullPath.length()); ThreadLocalUtil.setMapValue(currNodeNameTLKey, currQueueNodeName); &#125; return currQueueNodeName; &#125; catch (Exception e) &#123; logger.error("创建父节点：：zookeeper连接失败！", e); throw e; &#125; &#125; /** * 从当前线程获取排队节点，如果没排队抛出异常 * * @param lockKey * @return * @throws Exception */ public String getCurrQueueNameFromThreadLocal(String lockKey) &#123; String currNodeNameTLKey = getCurrNodeNameTLKey(lockKey); String currQueueName = ThreadLocalUtil.getMapValue(currNodeNameTLKey); if (StringUtils.isEmpty(currQueueName)) &#123; throw new RuntimeException("当前线程没有排队获取锁！"); &#125; return currQueueName; &#125; /** * 获取当前排队节点的路径 * * @param lockKey * @return */ private String getCurrQueueNodePath(String lockKey) &#123; String currQueueNodeName = this.getCurrQueueNameFromThreadLocal(lockKey); String parentFullPath = this.getParentFullPath(lockKey); return parentFullPath + currQueueNodeName; &#125; /** * 上一节点名称的ThreadLocal的key * * @param lockKey * @return */ private String getLastNodeNameTLKey(String lockKey) &#123; return lockKey + "_last_node_name"; &#125; /** * 获取上一个排队节点的全路径名称 * * @param lockKey * @param lastQueueNodeName * @return */ private String getLastQueueNodePath(String lockKey, String lastQueueNodeName) &#123; return this.getParentPath(lockKey) + "/" + lastQueueNodeName; &#125; /** * 当前排队节点的上一个节点名称 * * @param children * @param idx * @return */ private String findLastQueueNodeName(List&lt;String&gt; children, int idx) &#123; return children.get(idx - 1); &#125; /** * 获取上一节点名称 * * @param lockKey * @return */ private String getLastQueueNodeName(String lockKey) &#123; String lastNodeNameTLKey = this.getLastNodeNameTLKey(lockKey); if (!StringUtils.isEmpty(lastNodeNameTLKey)) &#123; return ThreadLocalUtil.getMapValue(lastNodeNameTLKey); &#125; return null; &#125; private void clean(String lockKey, boolean lockSuccess) &#123; this.resetLastQueueNodeName(lockKey); if (!lockSuccess) &#123; this.resetParentNodeFullPath(lockKey); this.resetParentNodePath(lockKey); this.resetCurrQueueNodeName(lockKey); &#125; &#125; /** * 绑定监听事件，并没有时间限制的一直等待 * * @param lockKey */ @SuppressWarnings("resource") private void waitForLock(String lockKey) &#123; CountDownLatch cdl = new CountDownLatch(1); TreeCache cache = null; TreeCacheListener listener = null; try &#123; String lastNodeName = this.getLastQueueNodeName(lockKey); if (StringUtils.isEmpty(lastNodeName)) &#123; return; &#125; String lastQueueNodePath = this.getLastQueueNodePath(lockKey, lastNodeName); cache = new TreeCache(this.client, lastQueueNodePath); listener = new TreeCacheListener() &#123; @Override public void childEvent(CuratorFramework client, TreeCacheEvent event) throws Exception &#123; if (event.getData() != null &amp;&amp; event.getType() == TreeCacheEvent.Type.NODE_REMOVED) &#123; cdl.countDown(); &#125; &#125; &#125;; try &#123; try &#123; cache.start(); &#125; catch (Exception e) &#123; return; &#125; cache.getListenable().addListener(listener); if (this.checkQueue(lockKey)) &#123; return; &#125; cdl.await(1000, TimeUnit.MILLISECONDS); &#125; catch (Exception e) &#123; logger.info("监听排队节点失败！", e); &#125; &#125; finally &#123; try &#123; cdl.countDown(); if (cache != null &amp;&amp; listener != null) &#123; cache.getListenable().removeListener(listener); &#125; &#125; catch (Exception e) &#123; logger.warn("监听节点退出异常！", e); &#125; &#125; &#125; /** * 将当前节点从缓存中清除，从zookeeper中删除 * * @param lockKey */ private void resetCurrQueueNodeName(String lockKey) &#123; String currNodeName = this.getCurrQueueNameFromThreadLocal(lockKey); if (!StringUtils.isEmpty(currNodeName)) &#123; try &#123; this.client.delete().forPath(this.getCurrQueueNodePath(lockKey)); &#125; catch (Exception e) &#123; logger.warn("删除当前节点失败，currNodeName=&#123;&#125;", currNodeName, e); &#125; &#125; String currNodeNameTLKey = this.getCurrNodeNameTLKey(lockKey); removeFromThreadLocal(currNodeNameTLKey); &#125; private void resetLastQueueNodeName(String lockKey) &#123; String lastNodeNameTLKey = this.getLastNodeNameTLKey(lockKey); removeFromThreadLocal(lastNodeNameTLKey); &#125; private void resetParentNodePath(String lockKey) &#123; String parentNodePathTLKey = this.getParentFullPath(lockKey); removeFromThreadLocal(parentNodePathTLKey); &#125; private void resetParentNodeFullPath(String lockKey) &#123; String parentNodeFullPathTLKey = this.getParentNodeFullPathTLKey(lockKey); removeFromThreadLocal(parentNodeFullPathTLKey); &#125; private boolean removeFromThreadLocal(String currNodeNameTLKey) &#123; return ThreadLocalUtil.removeMapValue(currNodeNameTLKey); &#125; /** * 对某个key键进行加锁，一直等待，直到加锁成功 * * @param lockKey * @return * @throws Exception */ public boolean acquire(String lockKey) &#123; boolean result = false; try &#123; while (!tryLock(lockKey)) &#123; waitForLock(lockKey); &#125; result = true; &#125; catch (Exception e) &#123; logger.info("获取zk锁异常或超时！", e); result = false; &#125; finally &#123; clean(lockKey, result); &#125; return result; &#125; /** * 只加锁一次，如果加锁失败，立马返回失败信息 * * @param lockKey * @return */ public boolean acquireOnce(String lockKey) &#123; boolean result = false; try &#123; result = tryLock(lockKey); &#125; catch (Exception e) &#123; logger.info("获取zk锁异常或超时！", e); return false; &#125; finally &#123; clean(lockKey, result); &#125; return result; &#125; /** * 等待一段时间还没等到，就返回失败 * * @param lockKey * @param timeoutMs * @return */ public boolean acquire(String lockKey, int timeoutMs) &#123; boolean result = false; long start = System.currentTimeMillis(); try &#123; while (!tryLock(lockKey)) &#123; if (System.currentTimeMillis() - start &gt; timeoutMs) &#123; return false; &#125; waitForLock(lockKey); &#125; if (System.currentTimeMillis() - start &gt; timeoutMs) &#123; result = false; return false; &#125; result = true; &#125; catch (Exception e) &#123; logger.info("获取zk锁异常或超时！", e); return false; &#125; finally &#123; clean(lockKey, result); &#125; return result; &#125; /** * 释放掉锁，删除缓存(当前节点，上一节点，父节点缓存)，删除zookeeper中当前节点数据 * * @param lockKey */ public void unlock(String lockKey) &#123; try &#123; String currNodeName = this.getCurrQueueNameFromThreadLocal(lockKey); if (!StringUtils.isEmpty(currNodeName)) &#123; this.resetCurrQueueNodeName(lockKey); this.resetLastQueueNodeName(lockKey); this.resetParentNodeFullPath(lockKey); this.resetParentNodePath(lockKey); &#125; &#125; catch (Exception e) &#123; logger.error("释放锁失败，删除节点失败！"); &#125; &#125; /** * 查找所有排队子节点 * * @param parentNodePath * @return * @throws Exception */ private List&lt;String&gt; findAllChildrenQueueNodeName(String parentNodePath) throws Exception &#123; try &#123; return this.client.getChildren().forPath(parentNodePath); &#125; catch (Exception e) &#123; logger.error("zookeeper连接失败，或查找不到子节点！path=&#123;&#125;", parentNodePath, e); throw e; &#125; &#125; /** * 将当前线程的当前key赋值 * * @param tlKey * @param currNodeName */ private void putThreadLocal(String tlKey, String currNodeName) &#123; ThreadLocalUtil.setMapValue(tlKey, currNodeName); &#125; /** * 查询当前节点排在第几号位置 * * @param childrenNodePath * @param currQueueNodeName * @return */ private int searchCurrQueueNodeIndex(List&lt;String&gt; childrenNodePath, String currQueueNodeName) &#123; return Collections.binarySearch(childrenNodePath, currQueueNodeName); &#125; /** * 获取运行权限 */ public boolean acquireActive()&#123; try&#123; // 如果保存的是自己已经拿到锁了，还得去校验一遍，为了解决脑列问题 if(this.executePermission)&#123; String value = getExecutePermissionValue(); if(value != null &amp;&amp; value.equals(this.executePermissionLockVal))&#123; return true; &#125; &#125; // 如果没有拿到锁，就将当前zkLock保存的状态修改一下 this.executePermission = false; return this.createEphemeralNode(); &#125;catch (Exception e)&#123; return false; &#125; &#125; public boolean removeExecutePermission() &#123; try&#123; this.client.delete().forPath(this.getEphemeralNodePath()); return true; &#125;catch (Exception e)&#123; logger.error("模拟连接断掉失败！"); return false; &#125; &#125; private String getExecutePermissionValue() throws Exception&#123; try &#123; return new String(this.client.getData().forPath(this.getEphemeralNodePath()),"UTF-8"); &#125; catch (KeeperException.NoNodeException e) &#123; return null; &#125;catch(Exception e)&#123; logger.info("获取临时节点Value失败！",e); throw e; &#125; &#125; private Stat getExecutePermissionStat() throws Exception &#123; try&#123; return this.client.checkExists().forPath(this.getEphemeralNodePath()); &#125;catch (Exception e)&#123; logger.error("获取临时节点状态失败！"); throw e; &#125; &#125; private String getEphemeralNodePath() &#123; return EXECUTE_PERMISSION_BASE_PATH + "_" + this.appName + "/" + EXECUTE_PERMISSION_NODE_NAME; &#125; private boolean createEphemeralNode() throws Exception &#123; try &#123; Stat stat = this.getExecutePermissionStat(); if (stat == null) &#123; try &#123; this.client.create().creatingParentsIfNeeded().withMode(CreateMode.EPHEMERAL).forPath(this.getEphemeralNodePath(),this.executePermissionLockVal.getBytes("UTF-8")); stat = this.getExecutePermissionStat(); if(stat != null)&#123; this.executePermission = true; System.out.println("加锁成功:::"+this.executePermission+",,,"+this.executePermissionLockVal+",,,"); return true; &#125;else&#123; return false; &#125; &#125; catch (KeeperException.NodeExistsException e) &#123; return false; &#125; &#125;else&#123; return false; &#125; &#125; catch (Exception e) &#123; logger.error("zookeeper 连接失败或无法创建节点！", e); throw e; &#125; &#125; public String getIpPort() &#123; return ipPort; &#125; public void setIpPort(String ipPort) &#123; this.ipPort = ipPort; &#125; public int getConnectionTimeoutMs() &#123; return connectionTimeoutMs; &#125; public void setConnectionTimeoutMs(int connectionTimeoutMs) &#123; this.connectionTimeoutMs = connectionTimeoutMs; &#125; public String getAppName() &#123; return appName; &#125; public void setAppName(String appName) &#123; this.appName = appName; &#125;&#125; spring中配置12345&lt;bean id="zkLock" class="com.api.lock.ZKLock"&gt; &lt;property name="ipPort" value="$&#123;lock.zk.ipPort&#125;"/&gt; &lt;property name="connectionTimeoutMs" value="$&#123;lock.zk.timeout&#125;"/&gt; &lt;property name="appName" value="$&#123;lock.zk.appName&#125;"/&gt;&lt;/bean&gt;]]></content>
      <categories>
        <category>经典</category>
      </categories>
      <tags>
        <tag>分布式锁</tag>
        <tag>zookeeper</tag>
        <tag>curator</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis实现分布式锁]]></title>
    <url>%2F2018%2F05%2F17%2F2018-05-17redis%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%2F</url>
    <content type="text"><![CDATA[redis实现分布式锁redis分布式锁是通过setNx，getset原子性操作实现的 基本流程是： 使用setNx命令给给定的锁Key（比如要给OrderNo=1234加锁，key值就为lock_1234）设置值（System.currentTimeMillis()+UUID） 如果设置成功了，就表明加锁成功 如果设置失败了，就表明有其它线程在占用该锁，获取占用锁线程设置的值（System.currentTimeMillis()+UUID） 判断当前占用锁的进程占用锁是否超时，如果超时，使用getset抢着去赋新值，如果赋值后返回的结果是之前超时线程赋的值，则表明占用锁成功，否则占用锁失败，等待一段时间重新尝试获取锁 下面是具体的代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110import java.util.UUID;import org.apache.commons.lang3.StringUtils;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Component;/** * 分布式锁 CAS * @author menggl */@Componentpublic class RedisLock &#123; private static Logger logger = LoggerFactory.getLogger(RedisLock.class); @Autowired private RedisCache redis; private static final String CLK_PREFIX = "lock_"; private static final int HOLD_LOCK_EXPIRE_MILL_SECOND = 50 * 1000; // 持有锁有效时长为50秒，50秒之后锁自动释放 private static final int DEFAULT_TIME_OUT_MILL_SECOND = 5 * 1000; // 获取锁超时时长默认值5秒 private static final long LOCK_VALUE_EXPIRE = 60*60; // 锁值有效时长，1小时 /** * lockKey可以是当前订单号或者VIN码，对订单号或VIN码加锁 * @param lockKey * @param timeOutSeconds 获取锁超时时间，毫秒,-1:没有超时限制，谨慎使用 * @return */ public boolean tryLock(String lockKey,long timeOutMillSeconds)&#123; try &#123; ThreadLocalUtil.removeMapValue(lockKey); String redisKey = CLK_PREFIX + lockKey; long startTime = System.currentTimeMillis(); String uuid = UUID.randomUUID().toString().replaceAll("-", ""); while(true)&#123; long currentTime = System.currentTimeMillis(); String newVal = currentTime+"_"+uuid; boolean setnx = redis.setNx(redisKey, newVal); if(!setnx)&#123; // 锁被占用 String oldVal = redis.get(redisKey); if(oldVal == null)&#123; continue; &#125; String[] oldArr = oldVal.split("_",2); long expireTime = Long.parseLong(oldArr[0])+HOLD_LOCK_EXPIRE_MILL_SECOND; // 锁有效期判定 if(System.currentTimeMillis() &gt;= expireTime)&#123; String getStr = redis.getSet(redisKey, newVal); if(getStr == null || oldVal.equals(getStr))&#123; logger.debug("trylock successed, getSet, key=&#123;&#125;, newValue=&#123;&#125;, oldValue=&#123;&#125;, expireTime=&#123;&#125;, currentTime=&#123;&#125;, &#123;&#125;, interval=&#123;&#125; millseconds",redisKey,newVal,oldVal,expireTime,currentTime,currentTime-expireTime,HOLD_LOCK_EXPIRE_MILL_SECOND); ThreadLocalUtil.setMapValue(lockKey, System.currentTimeMillis()+""); this.redis.expire(redisKey, LOCK_VALUE_EXPIRE); return true; &#125; &#125; try &#123; Thread.sleep(200); &#125; catch (InterruptedException e) &#123; logger.error("Thread sleep error:",e); &#125; &#125;else&#123; // 正常获取到锁 logger.debug("trylock successed, key=&#123;&#125;, value=&#123;&#125;",redisKey,newVal); ThreadLocalUtil.setMapValue(lockKey, System.currentTimeMillis()+""); this.redis.expire(redisKey, LOCK_VALUE_EXPIRE); return true; &#125; // 获取锁时长超时判定 long costTime = System.currentTimeMillis() - startTime; if(timeOutMillSeconds != -1 &amp;&amp; costTime &gt; timeOutMillSeconds)&#123; logger.warn("获取锁超时，timeout= &#123;&#125; millseconds",costTime); return false; &#125; &#125; &#125; catch (Exception e) &#123; logger.error("trylock error, msg:",e); return false; &#125; &#125; /** * lockKey可以是当前订单号或者VIN码，对订单号或VIN码加锁 * @param lockKey * @return */ public boolean tryLock(String lockKey)&#123; return this.tryLock(lockKey,DEFAULT_TIME_OUT_MILL_SECOND); &#125; /** * 释放锁，lockKey可以是当前订单号或者VIN码 * @param lockKey * @return */ public boolean unlock(String lockKey)&#123; String millSecondsStr = ThreadLocalUtil.getMapValue(lockKey); if(!StringUtils.isBlank(millSecondsStr))&#123; try&#123; long millSeconds = Long.parseLong(millSecondsStr); if(millSeconds + HOLD_LOCK_EXPIRE_MILL_SECOND - 200 &gt; System.currentTimeMillis())&#123; String redisKey = CLK_PREFIX + lockKey; return this.redis.del(redisKey); &#125; &#125;finally&#123; ThreadLocalUtil.removeMapValue(lockKey); &#125; &#125; return true; &#125;&#125; 问题： 没有使用redis的超时机制，因为如果setNx成功，setExpire失败，那么这把锁就永远不能被别的线程拿到，所以使用服务器时间判断超时 各个服务器使用的时间不一致时，会导致这台服务器获刚获取到锁，另一台服务器就判定超时，然后就拿到了锁 如果占用锁的线程崩掉，没有释放锁，就只能一直等待，直到锁超时，没有一个监控拿到锁线程的机制 拿到锁的线程处理业务时间不确定，如果业务没处理完，锁就超时了，就会出现同时拿到锁的情况 不是公平锁，都是随机获取锁 综上所述： 只有在有界的网络延迟、有界的程序中断、有界的时钟错误范围，Redlock才能正常工作，但是这三种场景的边界又是无法确认的，所以专家不建议使用Redlock。对于正确性要求高的场景，专家推荐了Zookeeper，关于使用Zookeeper作为分布式锁后面再讨论。]]></content>
      <categories>
        <category>经典</category>
      </categories>
      <tags>
        <tag>redis</tag>
        <tag>分布式锁</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Interceptor中解决跨域问题]]></title>
    <url>%2F2018%2F05%2F07%2F2018-05-07Interceptor%E4%B8%AD%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[在项目开发过程中，我们会遇到浏览器跨域请求资源的场景，跨域的时候有时候还需要携带cookie，我们发现配置上SpringMVC自带的mvc:cors后我们自己写的业务校验拦截器Interceptor还会被调用两次，如果业务拦截器中有校验cookie中字段的逻辑也会校验失败，这样跨域问题就没有解决 导致这个问题出现的原因是使用SpringMVC自带的mvc:cors实现跨域，也是使用的Interceptor，但是这个Interceptor是在所有Interceptor都调用完成之后才调用的，这就导致业务拦截时校验失败，调用不到Cors的拦截器就返回了，导致跨域授权失败，资源请求失败 我们看一下源码：所有请求都会走DispatchServlet.doDispatch()方法12345678910// Determine handler for the current request.mappedHandler = getHandler(processedRequest);// 这里会顺序调用所有的Interceptor，直到有一个拦截器返回false或者抛出异常或者所有拦截器都调用完毕if (!mappedHandler.applyPreHandle(processedRequest, response)) &#123; return;&#125;// Actually invoke the handler.mv = ha.handle(processedRequest, response, mappedHandler.getHandler()); 解决方案：在所有的业务拦截器的前面判断是否为OPTIONS权限请求，如果是OPTIONS请求，不进行业务拦截12345678910public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; ServletServerHttpRequest serverRequest = new ServletServerHttpRequest(request); if (serverRequest != null &amp;&amp; serverRequest.getMethod() != null) &#123; if ("OPTIONS".equalsIgnoreCase(serverRequest.getMethod().name())) &#123; return true; &#125; &#125; // ...业务逻辑 return true;&#125; 简单跨域请求（1) 请求方法是以下三种方法之一： HEAD GET POST （2）HTTP的头信息不超出以下几种字段： Accept Accept-Language Content-Language Last-Event-ID Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain 凡是不满足上面要求的都是不简单跨域请求 浏览器对这两种情况，处理的方式是不一样的 简单请求只有一次http调用，消息头中携带Referer: http://localhost:8080/cross-domain1/和Origin: http://localhost:8080信息，表示跨域的请求来自http://localhost:8080。 复杂请求会有两次http调用，第一次http请求是OPTIONS请求，跨域权限请求，第二次才是真正的资源访问请求 跨域解决方案如下：第一种：使用CorsFilter 定义跨域请求过滤器CORSFilter 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import java.io.IOException;import javax.servlet.Filter;import javax.servlet.FilterChain;import javax.servlet.FilterConfig;import javax.servlet.ServletException;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;import javax.servlet.http.HttpServletResponse;public class CORSFilter implements Filter &#123; public CORSFilter() &#123; &#125; public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; HttpServletResponse httpServletResponse = (HttpServletResponse) response; // 允许哪些域名下的网页可以进行跨域请求 httpServletResponse.setHeader("Access-Control-Allow-Origin", "http://localhost:8080"); // 跨域请求时允许的请求头信息 httpServletResponse.setHeader("Access-Control-Allow-Headers", "User-Agent,Origin,Cache-Control,Content-type,Date,Server,withCredentials,AccessToken,X-Custom-Header"); // 服务端控制的是否允许跨域请求携带cookie // 若客户端想发送带cookie的跨域请求，使用withCredentials控制打开，如下所示 // js代码：var xhr = new XMLHttpRequest();xhr.withCredentials = true; // ajax代码： xhrFields:&#123;withCredentials:true,&#125; httpServletResponse.setHeader("Access-Control-Allow-Credentials", "true"); // 允许的请求类型 httpServletResponse.setHeader("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS, HEAD"); httpServletResponse.setHeader("Access-Control-Max-Age", "5"); // 该字段可选，浏览器可以拿到哪些字段信息，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma，如果想拿到其它字段，就必须在这里指定 httpServletResponse.setHeader("Access-Control-Expose-Headers", "accesstoken"); // 资源过期时间，秒 httpServletResponse.setHeader("Expires", "-1"); // 控制浏览器缓存，不缓存 httpServletResponse.setHeader("Cache-Control", "no-cache"); // http1.0使用的浏览器缓存控制 httpServletResponse.setHeader("pragma", "no-cache"); chain.doFilter(request, response); &#125; public void init(FilterConfig fConfig) throws ServletException &#123; &#125; public void destroy() &#123; &#125;&#125; 在web.xml配置上这个过滤器 12345678&lt;filter&gt; &lt;filter-name&gt;corsFilter&lt;/filter-name&gt; &lt;filter-class&gt;com.test.filter.CORSFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;corsFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 在业务校验拦截器Interceptor中将OPTIONS请求过滤 123456789101112131415161718192021222324252627public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; ServletServerHttpRequest serverRequest = new ServletServerHttpRequest(request); logger.debug(serverRequest.getMethod().name()); if (serverRequest != null &amp;&amp; serverRequest.getMethod() != null) &#123; if ("OPTIONS".equalsIgnoreCase(serverRequest.getMethod().name())) &#123; logger.debug("OPTIONS请求不进行业务拦截校验！"); return true; &#125; &#125; if ("/test/setCookies".equals(request.getServletPath())) &#123; return true; &#125; // 模拟业务使用cookie中的参数 Cookie[] cookies = request.getCookies(); String token = null; if (cookies != null &amp;&amp; cookies.length &gt; 0) &#123; for (Cookie c : cookies) &#123; if (c.getName().equals("token")) &#123; token = c.getValue(); &#125; &#125; &#125; if (token == null) &#123; throw new Exception("参数token不能为空！"); &#125; return true;&#125; 第二种：使用mvc:cors 添加springMVC的cors配置 12345678&lt;mvc:cors&gt; &lt;mvc:mapping path="/**" allowed-origins="*" allow-credentials="true" allowed-methods="GET,POST,PUT,DELETE,OPTIONS,HEAD" max-age="3600" allowed-headers="User-Agent,Origin,Cache-Control,Content-type,Date,Server,withCredentials,AccessToken,X-Custom-Header"/&gt;&lt;/mvc:cors&gt; 在业务拦截器Interceptor中将OPTIONS请求过滤 123456789101112131415161718192021222324252627public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; ServletServerHttpRequest serverRequest = new ServletServerHttpRequest(request); logger.debug(serverRequest.getMethod().name()); if (serverRequest != null &amp;&amp; serverRequest.getMethod() != null) &#123; if ("OPTIONS".equalsIgnoreCase(serverRequest.getMethod().name())) &#123; logger.debug("OPTIONS请求不进行业务拦截校验！"); return true; &#125; &#125; if ("/test/setCookies".equals(request.getServletPath())) &#123; return true; &#125; // 模拟业务使用cookie中的参数 Cookie[] cookies = request.getCookies(); String token = null; if (cookies != null &amp;&amp; cookies.length &gt; 0) &#123; for (Cookie c : cookies) &#123; if (c.getName().equals("token")) &#123; token = c.getValue(); &#125; &#125; &#125; if (token == null) &#123; throw new Exception("参数token不能为空！"); &#125; return true;&#125; 第三种：使用@CrossOrigin1234567891011@Controller@RequestMapping("/test")@CrossOrigin(origins = &#123; "http://localhost:8080" &#125;, allowCredentials = "true", maxAge = 5, allowedHeaders = &#123; "User-Agent", "Origin", "Cache-Control", "Content-type", "Date", "Server", "withCredentials", "AccessToken", "X-Custom-Header" &#125;)public class TestController &#123; @RequestMapping(name = "/crossDomain", method = &#123; RequestMethod.GET, RequestMethod.POST, RequestMethod.PUT &#125;) @ResponseBody public String testCrossDomain() &#123; return "success OK!"; &#125; 这个对于简单跨域请求是没问题的，对于非简单跨域请求权限校验失败。 测试demo创建web项目：cross-domain1(localhost:8080)和cross-domain2(localhost:8081) 我们将要从localhost:8080项目下的网页访问localhost:8081项目下的请求 cross-domain1项目创建test.html12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;html&gt;&lt;!-- 这个html是在http://localhost:8080项目下 --&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;script src="static/js/jquery-1.8.1.min.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;input type="button" id="testBtn1" value="简单跨域"/&gt;&lt;input type="button" id="testBtn2" value="非简单跨域"/&gt;&lt;script type="text/javascript"&gt;$(document).ready(function()&#123; $("#testBtn2").click(function()&#123; $.ajax(&#123; url:'http://localhost:8081/cross-domain2/test/crossDomain', type: "GET",// 请求方式 async: false,// 默认为true，异步方式请求 contentType: 'application/x-www-form-urlencoded', // 内容编码格式，默认是application/x-www-form-urlencoded crossDomain: true, cache:false, data: &#123;token:"abc"&#125;, dataType: 'json',// 预期服务器返回的数据类型 beforeSend:function(XMLHttpReqeust)&#123; XMLHttpReqeust.withCredentials = true;// 可以附带cookie信息,同时服务端配置权限的时Access-Control-Allow-Origin就不能设置为*，必须设置指定的域了 XMLHttpReqeust.setRequestHeader("X-Custom-Header","session=xxxxyyyyzzzz");// 新增消息头 &#125;, complete:function(XMLHttpRequest, textStatus)&#123; console.log('complete'); &#125;, success:function(data, textStatus)&#123; console.log(data); &#125;, error:function(XMLHttpRequest, textStatus, errorThrown)&#123; console.log(errorThrown); &#125;, &#125;) &#125;); $("#testBtn1").click(function()&#123; $.ajax(&#123; url:'http://localhost:8081/cross-domain2/test/crossDomain', type: "GET",// 请求方式 async: false,// 默认为true，异步方式请求 contentType: 'application/x-www-form-urlencoded', // 内容编码格式，默认是application/x-www-form-urlencoded crossDomain: true, cache:false, data: &#123;token:"abc"&#125;, dataType: 'json',// 预期服务器返回的数据类型 complete:function(XMLHttpRequest, textStatus)&#123; console.log('complete'); &#125;, success:function(data, textStatus)&#123; console.log(data); &#125;, error:function(XMLHttpRequest, textStatus, errorThrown)&#123; console.log(errorThrown); &#125;, &#125;) &#125;);&#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; cross-domain2项目，创建Controller123456789101112131415161718192021222324252627import javax.servlet.http.Cookie;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;@Controller@RequestMapping("/test")public class TestController &#123; @RequestMapping("/crossDomain") @ResponseBody public String testCrossDomain() &#123; return "success OK!"; &#125; @RequestMapping("/setCookies") @ResponseBody public String setCookies(HttpServletRequest request, HttpServletResponse response) &#123; Cookie token = new Cookie("token", "123456"); token.setPath("/"); token.setMaxAge(86400); response.addCookie(token); return "success OK!"; &#125;&#125;]]></content>
      <categories>
        <category>经典</category>
      </categories>
      <tags>
        <tag>Cors</tag>
        <tag>CrossOrigin</tag>
        <tag>简单跨域</tag>
        <tag>cookie</tag>
        <tag>ajax跨域</tag>
        <tag>spring跨域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA虚拟机之运行时数据区]]></title>
    <url>%2F2018%2F03%2F20%2F2018-03-20JAVA%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%2F</url>
    <content type="text"><![CDATA[JAVA运行时数据区域(runtime data area)java运行时数据区可以分为6个区域 Java堆 Java虚拟机栈 本地方法栈 方法区 运行时常量池 程序计数器 线程私有的有： 程序计数器 本地方法栈 java虚拟机栈 线程共有的有： java堆 方法区 运行时常量池 PC程序计数器可以理解为一块较小的内存空间，可以看做是当前线程执行字节码的行号计数器，一个线程分配一小块，以便记录当前线程执行的上线文环境，多线程切换时将上线文环境数据保存和加载。如果线程执行到本地方法，则PC程序计数器不会记录本地方法的上下文（没有字节码可以记录啊）。 Java虚拟机栈每个java线程都会拥有一块Java虚拟机栈的内存空间，Java虚拟机栈记录的是每个JAVA方法执行时候的内存模型，每调用一个JAVA方法的时候都会在Java虚拟机栈里面创建一个栈帧每个栈帧都会包含下面几个部分： 局部变量表 操作数栈 动态链接 方法返回地址 下面我们解释一下栈帧中各个部分都是干什么用的 局部变量表 作用：保存方法中的参数、局部变量等 如果这个栈帧是实例的方法栈帧，这个局部变量表第0个Slot肯定就是this（当前的实例），然后方法中的局部变量从第1个Slot开始 局部变量表以变量槽Slot为基本单位，在32位虚拟机中一个变量槽可以保存一个32位以内的数据类型（boolean、byte、char、short、int、float、reference和returnAddress八种），对于64位的数据用连续的两个变量槽来记录 如果方法中的某个变量的作用域结束了，那么这个变量对应的slot内存就可以被其它变量覆盖重用了 returnAddress类型是为字节码指令：jsr、jsr_w、ret服务的，它指向了一条字节码指令的地址（返回上一个调用该方法的字节码地址？） 引用类型reference没有明确规定它的长度 在java程序被编译成class文件时，就在方法的Code属性的max_locals数据项中确定该方法需要分配的局部变量表的内存大小 操作数栈 就像汇编一样，jvm也有指令集，java指令集是由一个字节表示的，也就是说指令集不超过256个，现在的java指令集也就200多条 指令运行时需要读取数据，处理完成后需要保存数据，这个操作数栈就是用来保存这些指令执行中需要的参数数据和结果数据的 操作数分两种，一种直接嵌入到指令中，可以叫做是嵌入操作数；还有一种是会压入操作数栈，这种可以叫做栈中操作数 嵌入操作数在编译期就已经确定好了，比如putstatic指令，将数据赋值给一个静态变量，该静态变量就是一个嵌入式操作数，它会紧跟指令，用两个字节表示，这个操作数是一个索引值，索引值指向的是运行时常量池中该静态字段对应的符号引用，由于符号引用中包含了这个静态变量的基本信息，如所属类、简单名称、描述符，这样指令就知道要给哪个类的哪个字段赋值了 栈中操作数是在运行期动态确定的数据，比如一个指令需要两个参数，需要先把两个参数放入操作数栈中，使用后出栈，将运行结果再入栈 动态链接 静态链接是在类加载的时候或者第一次使用的时候就将符号引用确定下来直接引用的过程 动态链接是在代码执行的时候才会确定符号引用对应的直接引用地址的过程 方法返回地址这个应该就保存在局部变量表中吧 本地方法栈与java虚拟机栈类似，为Java使用到的本地方法提供服务用的。 当java线程调用了一个本地方法时，它就会进入一个全新的不受java虚拟机限制的世界，本地方法还可以反过来通过本地方法接口来访问虚拟机的运行时数据区 如果某个虚拟机实现的本地方法接口是使用C连接模型的话，那么它的本地方法栈就是C栈 下面是定义了一个java的Native Method，类似于定义了一个接口123456public class IHaveNatives&#123; native public void Native1( int x ) ; native static public long Native2() ; native synchronized private float Native3( Object o ) ; native void Native4( int[] ary ) throws Exception ;&#125; Java堆 java堆是被所有线程共享的一块内存区域 所有的对象和数组的内存分配都在堆上面 为了垃圾收集方便，java堆又可以分为新生代、老年代和永久代（也叫方法区，jdk1.8中没有永久代，用metaspace实现）三块区域 方法区 保存虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码Class等数据 jdk6时，字符串常量是保存在方法区中的，jdk7开始，已将其移到堆中了 常量池配置参数-Xss // 设置JVM栈的大小-Xms // 初始堆内存大小-Xmx // 最大堆内存大小 -Xmn // 年轻代的内存大小 虚拟机调优]]></content>
      <categories>
        <category>经典</category>
      </categories>
      <tags>
        <tag>虚拟机</tag>
        <tag>性能调优</tag>
        <tag>JVM参数</tag>
        <tag>垃圾回收</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA虚拟机之类加载器]]></title>
    <url>%2F2018%2F03%2F16%2F2018-03-16JAVA%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B9%8B%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%2F</url>
    <content type="text"><![CDATA[java虚拟机组成： 类加载器：加载类用的 执行引擎：执行java代码用的 运行时数据区：相当于操作系统内存，保存虚拟机运行时的缓存数据用的，是一块需要优化的部分 类加载器将java的.class文件按照规范加载到运行时数据区的方法区中，以供执行引擎解释执行 每个类加载器将class文件加载完之后，都会将全限定名(包名+类名)保存起来，也就是说每一个类加载器只能加载一份全限定名的class文件不同的类加载器可以加载相同的全限定名文件 java类加载器是分层级的，最顶级的类加载器是BootstrapClassLoader，其次的类加载器是ExtClassLoader，最后才是AppClassLoader结构如下所示：12345--BootstrapClassLoader 加载$JAVA_HOME$/lib/rt.jar下的类----ExtClassLoader 加载$JAVA_HOME$/lib/ext.jar下的类------AppClassLoader--------URLClassLoader spring中的类加载器----------WebappClassLoader 在tomcat中部署的每个项目都会创建一个类加载器，以保证加载的相同命名空间（不同项目、不同实现）的类加载后不同，以实现隔离项目冲突的目的 各个类加载器之间是组合的关系，不是继承的关系 双亲委派模型当一个classLoader想加载一个class文件的时候，首先从当前ClassLoader查找有没有加载过这个class，如果没有加载过就去父加载器里查有没有加载过这个class，最后直到BootstrapClassLoader顶级加载器也没有加载过这个class，才会从顶级加载器开始尝试加载这个class，然后是子加载器，最后直到当前ClassLoader都加载class失败，这个类才是加载失败! 下面是ClassLoader.loadClass的代码实现1234567891011121314151617181920212223242526272829303132333435363738protected Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException&#123; // 加载一个类的时候需要加锁，防止并发加载同一个类时出现冲突 synchronized (getClassLoadingLock(name)) &#123; // 看看这个类是否已经被当前类加载器加载过 Class&lt;?&gt; c = findLoadedClass(name); // 如果没有被加载过会返回null if (c == null) &#123; long t0 = System.nanoTime(); try &#123; // 找到当前类加载器的父类加载器加载这个命名空间下的class if (parent != null) &#123; c = parent.loadClass(name, false); &#125; else &#123;// 如果父加载器是null，则说明当前委托的类加载器已经到顶了，到BootstrapClassLoader了 c = findBootstrapClassOrNull(name); &#125; &#125; catch (ClassNotFoundException e) &#123; // ClassNotFoundException thrown if class not found // from the non-null parent class loader &#125; // 如果父加载器没有加载过这个class，并且也不能加载这个class，则只能当前类加载器尝试去加载这个类了 if (c == null) &#123; // If still not found, then invoke findClass in order // to find the class. long t1 = System.nanoTime(); c = findClass(name); // this is the defining class loader; record the stats sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0); sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1); sun.misc.PerfCounter.getFindClasses().increment(); &#125; &#125; if (resolve) &#123; resolveClass(c); &#125; return c; &#125;&#125; 测试类加载器加载顺序No1.创建下面的类，并将编译好的class文件及命名空间文件夹放到D:\temp目录下面12345public class HelloLoader &#123; public void print() &#123; System.out.println("I am in BootstrapClassLoader!"); &#125;&#125; 然后修改本地HelloLoader类中的代码为：12345public class HelloLoader &#123; public void print() &#123; System.out.println("I am in AppClassLoader!"); &#125;&#125; 测试类定义：123456public class FindClassOrder &#123; public static void main(String[] args) &#123; HelloLoader helloLoader = new HelloLoader(); helloLoader.print(); &#125;&#125; 正常情况下会输出：I am in AppClassLoader! //ClassLoader加载的是本地HelloLoader定义的类 添加虚拟机运行参数：-Xbootclasspath/a:D:\temp（添加BootstrapClassLoader加载类路径的范围D:\temp） 再次运行时输出变成了：I am in BootstrapClassLoader! //ClassLoader加载的是D:\temp目录下定义的类 No2.即使配置了运行参数：-Xbootclasspath/a:D:\temp，如果AppClassLoader强行加载某个类，创建对象的时候也不会用到父加载器加载到的同命名空间下的类1234567891011121314151617181920212223242526272829303132import java.io.File;import java.io.FileInputStream;import java.lang.reflect.Method;import org.apache.commons.io.IOUtils;public class FindClassOrder &#123; public static void main(String[] args) throws Exception &#123; // 使用appClassLoader强行加载HelloLoader这个class ClassLoader classLoader = FindClassOrder.class.getClassLoader(); byte[] bHelloLoader = loadClassBytes("D:\\temp\\com\\test\\HelloLoader.class"); Method defineClassMethod = ClassLoader.class.getDeclaredMethod("defineClass", byte[].class,int.class,int.class); defineClassMethod.setAccessible(true); defineClassMethod.invoke(classLoader, new Object[]&#123;bHelloLoader,0,bHelloLoader.length&#125;); defineClassMethod.setAccessible(false); // 当前AppClassLoader强行加载了HelloLoader这个类，就不会再使用父加载器加载的这个类了 HelloLoader helloLoader = new HelloLoader(); helloLoader.print(); &#125; public static byte[] loadClassBytes(String filePath) throws Exception &#123; return IOUtils.toByteArray(new FileInputStream(new File(filePath))); &#125; /* &lt;!-- https://mvnrepository.com/artifact/commons-io/commons-io --&gt; IOUtils使用到的jar包 &lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.6&lt;/version&gt; &lt;/dependency&gt; */&#125; 双亲委托模型的弊端：父类加载器无法访问子类加载器的对象。比如父类加载器定义一个接口，同时绑定一个工厂方法，由于接口实现类不在父加载器中，所以无法访问和创建实例 No3.父加载器加载的类，不能访问加载子加载器加载的类1.编译下面java，将class文件放入D:\temp目录下面1234567public class HelloLoader &#123; public void print() &#123; System.out.println("I am in BootstrapClassLoader!"); System.out.println(Thread.currentThread().getContextClassLoader()); new HelloChildLoader().print(); &#125;&#125; 2.本地java1234567public class HelloLoader &#123; public void print() &#123; System.out.println("I am in AppClassLoader!"); System.out.println(Thread.currentThread().getContextClassLoader()); new HelloChildLoader().print(); &#125;&#125; 12345public class HelloChildLoader &#123; public void print() &#123; System.out.println("I am HelloChildLoader!"); &#125;&#125; 123456public class FindClassOrder &#123; public static void main(String[] args) &#123; HelloLoader helloLoader = new HelloLoader(); helloLoader.print(); &#125;&#125; 上面的main方法运行之后输出结果：12345I am in BootstrapClassLoader! sun.misc.Launcher$AppClassLoader@c387f44 &lt;br&gt;Exception in thread "main" java.lang.NoClassDefFoundError: com/test/HelloChildLoader at com.test.HelloLoader.print(HelloLoader.java:7)at com.test.FindClassOrder.main(FindClassOrder.java:6) 修改main方法：1234567891011121314151617181920212223import java.io.File;import java.io.FileInputStream;import java.lang.reflect.Method;import org.apache.commons.io.IOUtils;public class FindClassOrder &#123; public static void main(String[] args) throws Exception &#123; // 使用appClassLoader强行加载HelloLoader这个class ClassLoader classLoader = FindClassOrder.class.getClassLoader(); byte[] bHelloLoader = loadClassBytes("D:\\tmp\\com\\test\\HelloLoader.class"); Method defineClassMethod = ClassLoader.class.getDeclaredMethod("defineClass", byte[].class,int.class,int.class); defineClassMethod.setAccessible(true); defineClassMethod.invoke(classLoader, new Object[]&#123;bHelloLoader,0,bHelloLoader.length&#125;); defineClassMethod.setAccessible(false); // 当前AppClassLoader强行加载了HelloLoader这个类，就不会再使用父加载器加载的这个类了 HelloLoader helloLoader = new HelloLoader(); helloLoader.print(); &#125; public static byte[] loadClassBytes(String filePath) throws Exception &#123; return IOUtils.toByteArray(new FileInputStream(new File(filePath))); &#125;&#125; 运行上面代码，结果如下：123I am in BootstrapClassLoader!sun.misc.Launcher$AppClassLoader@c387f44I am HelloChildLoader! 以上结果表明： 父类加载器加载的class不能直接创建子类加载器加载的类，因为父类加载器没有访问子类加载器加载的类的权限 解决方法： 父类加载器使用Thread.currentThread().getContextClassLoader()可以获取到子类加载器ClassLoader，进而可以创建子类加载器加载的对象 以下是测试用例：创建一个待被应用类加载器加载的类HelloChildLoader12345public class HelloChildLoader &#123; public void print() &#123; System.out.println("this is HelloChildLoader!"); &#125;&#125; 将下面编译后的class拷贝到D:\temp目录下123456public class HelloLoader &#123; public void print() throws Exception &#123; System.out.println("I am in BootstrapClassLoader!"); new HelloChildLoader().print(); &#125;&#125; 本地HelloLoader实现如下123456public class HelloLoader &#123; public void print() throws Exception &#123; System.out.println("I am in AppClassLoader!"); new HelloChildLoader().print(); &#125;&#125; 测试类代码如下：123456public class FindClassOrder &#123; public static void main(String[] args) throws Exception &#123; HelloLoader helloLoader = new HelloLoader(); helloLoader.print(); &#125;&#125; 配置虚拟机运行时参数：-Xbootclasspath/a:D:\temp运行后结果如下：1234I am in BootstrapClassLoader!Exception in thread &quot;main&quot; java.lang.NoClassDefFoundError: com/test/classloader/HelloChildLoader at com.test.classloader.HelloLoader.print(HelloLoader.java:6) at com.test.classloader.FindClassOrder.main(FindClassOrder.java:6) 以上运行结果表明，启动类加载器不能直接加载和创建应用类加载器的类对象 修改D:\temp目录下的类实现：1234567891011public class HelloLoader &#123; public void print() throws Exception &#123; System.out.println("I am in BootstrapClassLoader!"); ClassLoader classLoader = Thread.currentThread().getContextClassLoader(); Class&lt;?&gt; helloChildLoaderClazz = Class.forName("com.test.classloader.HelloChildLoader", false, classLoader); // 这里如果启动类加载器定义了HelloChildLoader的接口，就直接用接口接收就可以了，不用反射调用了 Object helloChildLoader = helloChildLoaderClazz.newInstance(); Method printMethod = helloChildLoaderClazz.getDeclaredMethod("print",new Class[]&#123;&#125;); printMethod.invoke(helloChildLoader, new Object[]&#123;&#125;); &#125;&#125; 执行main方法运行结果如下：12I am in BootstrapClassLoader!this is HelloChildLoader! 上面运行结果表明： 启动类加载器加载的类中，我们可以通过应用类加载器(通过Thread.currentThread().getContextClassLoader()获取)和要加载应用类的全限定名，我们就可以得到应用类加载器的实例对象 热部署自定义一个ClassLoader，用于实现热部署12345678910111213141516171819202122232425262728public class MyClassLoader extends ClassLoader &#123; private String fileName; public MyClassLoader(String fileName) &#123; this.fileName = fileName; &#125; @Override protected Class&lt;?&gt; findClass(String className) throws ClassNotFoundException &#123; Class&lt;?&gt; clazz = this.findLoadedClass(className); // 如果当前类被加载过，就不会重复去加载 if (clazz == null) &#123; try &#123; String classFile = getClassFile(className); byte[] bytes = IOUtils.toByteArray(new FileInputStream(new File(classFile))); return super.defineClass(className, bytes, 0, bytes.length); &#125; catch (FileNotFoundException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; return clazz; &#125; private String getClassFile(String classFile) &#123; return this.fileName + "/" + classFile.replaceAll("[.]", "/") + ".class"; &#125;&#125; 定义一个需要热部署的类12345public class DemoA &#123; public void hot()&#123; System.out.println("OldDemoA is Running!"); &#125;&#125; 测试类代码123456789101112131415161718192021public class DoopRun &#123; public static void main(String[] args) &#123; while(true)&#123; try &#123; // 每次循环都重新创建MyClassLoader保证没有加载过DemoA这个类 MyClassLoader loader = new MyClassLoader("D:\\temp"); Class&lt;?&gt; clazz = loader.loadClass("com.test.classloader.DemoA"); Object demoA = clazz.newInstance(); Method m = demoA.getClass().getMethod("hot", new Class[]&#123;&#125;); m.invoke(demoA, new Object[]&#123;&#125;); &#125; catch (Exception e) &#123; System.out.println("not find!"); &#125; try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 将DemoA.class文件放入D:\temp目录下面，并保证当前main启动环境下没有这个类定义启动main，每隔一段时间输出打印”OldDemoA is Running!”，结果如下：123OldDemoA is Running!OldDemoA is Running!OldDemoA is Running! 修改D:\temp目录下的DemoA类定义为下面代码：12345public class DemoA &#123; public void hot()&#123; System.out.println("NewDemoA is Running!"); &#125;&#125; 然后覆盖到D:\temp目录下面，输出打印变成如下：1234OldDemoA is Running!NewDemoA is Running!NewDemoA is Running!NewDemoA is Running!]]></content>
      <categories>
        <category>经典</category>
      </categories>
      <tags>
        <tag>虚拟机</tag>
        <tag>类加载器</tag>
        <tag>classloader</tag>
        <tag>双亲委派模型</tag>
      </tags>
  </entry>
</search>
