<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Dubbo服务]]></title>
    <url>%2F2018%2F10%2F15%2F2018-10-15Dubbo%E6%9C%8D%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[pom.xml配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110&lt;build&gt; &lt;finalName&gt;insurance-order-provider&lt;/finalName&gt; &lt;sourceDirectory&gt;src/main/java&lt;/sourceDirectory&gt; &lt;!-- 资源路径配置 --&gt; &lt;resources&gt; &lt;!-- build时资源文件拷贝 --&gt; &lt;resource&gt; &lt;targetPath&gt;$&#123;project.build.directory&#125;/classes&lt;/targetPath&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;includes&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;!-- build时环境配置文件拷贝 --&gt; &lt;resource&gt; &lt;targetPath&gt;$&#123;project.build.directory&#125;/classes/conf&lt;/targetPath&gt; &lt;directory&gt;src/main/resources/env/$&#123;env&#125;&lt;/directory&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;includes&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;!-- build时spring配置文件拷贝 --&gt; &lt;resource&gt; &lt;targetPath&gt;$&#123;project.build.directory&#125;/classes/META-INF/spring&lt;/targetPath&gt; &lt;directory&gt;src/main/resources/spring&lt;/directory&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;includes&gt; &lt;include&gt;spring-context.xml&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;plugins&gt; &lt;!-- 打包jar文件时，配置manifest文件，加入lib包的jar依赖 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;classesDirectory&gt;target/classes/&lt;/classesDirectory&gt; &lt;archive&gt; &lt;manifest&gt; &lt;mainClass&gt;com.alibaba.dubbo.container.Main&lt;/mainClass&gt; &lt;!-- 打包时 MANIFEST.MF文件不记录的时间戳版本 --&gt; &lt;useUniqueVersions&gt;false&lt;/useUniqueVersions&gt; &lt;addClasspath&gt;true&lt;/addClasspath&gt; &lt;classpathPrefix&gt;lib/&lt;/classpathPrefix&gt; &lt;/manifest&gt; &lt;manifestEntries&gt; &lt;Class-Path&gt;.&lt;/Class-Path&gt; &lt;/manifestEntries&gt; &lt;/archive&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-dependency-plugin&lt;/artifactId&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;copy-dependencies&lt;/id&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;copy-dependencies&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;type&gt;jar&lt;/type&gt; &lt;includeTypes&gt;jar&lt;/includeTypes&gt; &lt;!--&lt;useUniqueVersions&gt;false&lt;/useUniqueVersions&gt;--&gt; &lt;outputDirectory&gt; $&#123;project.build.directory&#125;/lib &lt;/outputDirectory&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;!-- 配置assembly插件 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;make-assembly&lt;/id&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;single&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;descriptor&gt;src/main/assembly/assembly.xml&lt;/descriptor&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;!-- 解决资源文件的编码问题 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-deploy-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; assembly.xml配置123456789101112131415161718192021&lt;assembly&gt; &lt;id&gt;assembly&lt;/id&gt; &lt;formats&gt; &lt;format&gt;tar.gz&lt;/format&gt; &lt;/formats&gt; &lt;includeBaseDirectory&gt;true&lt;/includeBaseDirectory&gt; &lt;fileSets&gt; &lt;fileSet&gt; &lt;directory&gt;src/main/assembly/bin&lt;/directory&gt; &lt;outputDirectory&gt;bin&lt;/outputDirectory&gt; &lt;fileMode&gt;0755&lt;/fileMode&gt; &lt;/fileSet&gt; &lt;/fileSets&gt; &lt;dependencySets&gt; &lt;dependencySet&gt; &lt;useProjectArtifact&gt;true&lt;/useProjectArtifact&gt; &lt;outputDirectory&gt;lib&lt;/outputDirectory&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependencySet&gt; &lt;/dependencySets&gt;&lt;/assembly&gt; bin目录下的start.sh和stop.sh脚本start.sh1234567891011121314151617181920212223242526#!/bin/bashcd `dirname $0`BIN_DIR=`pwd`cd ..DEPLOY_DIR=`pwd`CONF_DIR=$DEPLOY_DIR/confLOGS_DIR=""if [ -n "$LOGS_FILE" ]; then LOGS_DIR=`dirname $LOGS_FILE`else LOGS_DIR=$DEPLOY_DIR/logsfiif [ ! -d $LOGS_DIR ]; then mkdir $LOGS_DIRfiSTDOUT_FILE=$LOGS_DIR/stdout.logLIB_DIR=$DEPLOY_DIR/libLIB_JARS=`ls $LIB_DIR|grep .jar|awk '&#123;print "'$LIB_DIR'/"$0&#125;'|tr "\n" ":"`JAVA_OPTS=" -Djava.awt.headless=true -Djava.net.preferIPv4Stack=true "JAVA_MEM_OPTS=" -server -Xmx2g -Xms128m -Xmn256m -XX:PermSize=128m -Xss256k -XX:+DisableExplicitGC -XX:+UseConcMarkSweepGC -XX:+CMSParallelRemarkEnabled -XX:+UseCMSCompactAtFullCollection -XX:LargePageSizeInBytes=128m -XX:+UseFastAccessorMethods -XX:+UseCMSInitiatingOccupancyOnly -XX:CMSInitiatingOccupancyFraction=70 "java $JAVA_OPTS $JAVA_MEM_OPTS $JAVA_DEBUG_OPTS $JAVA_JMX_OPTS -classpath $CONF_DIR:$LIB_JARS com.alibaba.dubbo.container.Main# nohup java $JAVA_OPTS $JAVA_MEM_OPTS $JAVA_DEBUG_OPTS $JAVA_JMX_OPTS -classpath $CONF_DIR:$LIB_JARS com.alibaba.dubbo.container.Main &gt;&gt; $STDOUT_FILE 2&gt;&amp;1 &amp; stop.sh12345678910111213141516171819202122232425262728293031323334353637383940414243#!/bin/bashcd `dirname $0`BIN_DIR=`pwd`cd ..DEPLOY_DIR=`pwd`CONF_DIR=$DEPLOY_DIR/confSERVER_NAME=`sed '/dubbo.application.name/!d;s/.*=//' conf/dubbo.properties | tr -d '\r'`if [ -z "$SERVER_NAME" ]; then SERVER_NAME=`hostname`fiPIDS=`ps -f | grep java | grep "$CONF_DIR" |awk '&#123;print $2&#125;'`if [ -z "$PIDS" ]; then echo "ERROR: The $SERVER_NAME does not started!" exit 1fiif [ "$1" != "skip" ]; then $BIN_DIR/dump.shfiecho -e "Stopping the $SERVER_NAME ...\c"for PID in $PIDS ; do kill $PID &gt; /dev/null 2&gt;&amp;1doneCOUNT=0while [ $COUNT -lt 1 ]; do echo -e ".\c" sleep 1 COUNT=1 for PID in $PIDS ; do PID_EXIST=`ps -f -p $PID | grep java` if [ -n "$PID_EXIST" ]; then COUNT=0 break fi donedoneecho "OK!"echo "PID: $PIDS"]]></content>
      <categories>
        <category>整理</category>
      </categories>
      <tags>
        <tag>dubbo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA设计模式]]></title>
    <url>%2F2018%2F10%2F11%2F2018-10-11JAVA%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[单例模式懒汉式,线程不安全1234567891011public class SingleDemo &#123; private static SingleDemo single; private SingleDemo() &#123; &#125; public static SingleDemo getInstance() &#123; if (single == null) &#123; single = new SingleDemo(); &#125; return single; &#125;&#125; 懒汉式，线程安全1234567891011public class SingleDemo &#123; private static SingleDemo single; private SingleDemo() &#123; &#125; public static synchronized SingleDemo getInstance() &#123; if (single == null) &#123; single = new SingleDemo(); &#125; return single; &#125;&#125; 懒汉式，双重校验锁123456789101112131415public class SingleDemo &#123; private static SingleDemo single; private SingleDemo() &#123; &#125; public static SingleDemo getInstance() &#123; if (single == null) &#123; synchronized (SingleDemo.class) &#123; if (single == null) &#123; single = new SingleDemo(); &#125; &#125; &#125; return single; &#125;&#125; 双重校验锁看起来很完美，其实有缺陷，问题出在single = new SingleDemo()上，这不是一个原子性的操作，其操作分为下面几步 给instance分配内存 调用single的构造函数来初始化内存 将instance赋值给变量single但是在jvm中有可能会发生指令重排序，导致第3步执行发生在第1、2步之前，导致当前线程还没有初始化这个单例，别的线程就校验这个对象不为null，就直接使用，报错了 解决方案如下：将instance设置成volatile限制，禁止new SingleDemo()进行指令重排，并且这个single初始化后对别的线程立即可见123456789101112131415public class SingleDemo &#123; private volatile static SingleDemo single; private SingleDemo() &#123; &#125; public static SingleDemo getInstance() &#123; if (single == null) &#123; synchronized (SingleDemo.class) &#123; if (single == null) &#123; single = new SingleDemo(); &#125; &#125; &#125; return single; &#125;&#125; 恶汉式,在类加载后就创建单例模式12345678public class SingleDemo &#123; private static SingleDemo single = new SingleDemo(); private SingleDemo() &#123; &#125; public static SingleDemo getInstance() &#123; return single; &#125;&#125; 静态内部类使用类加载时候的锁机制12345678910public class SingleDemo &#123; private SingleDemo() &#123; &#125; private static class SingleDemoHolder &#123; public static final SingleDemo INSTANCE = new SingleDemo(); &#125; public static final SingleDemo getInstance() &#123; return SingleDemoHolder.INSTANCE; &#125;&#125; 枚举123public enum Singleton&#123; INSTANCE;&#125; 工厂模式简单工厂模式，静态工厂方法模式1234567891011121314151617181920212223242526272829303132333435public class SimpleFactory &#123; public static void main(String[] args) &#123; BMWFactory factory = new BMWFactory(); BMW bmw320 = factory.createBMW(320); BMW bmw523 = factory.createBMW(523); &#125; public static abstract class BMW &#123; public BMW() &#123; &#125; &#125; public static class BMW320 extends BMW &#123; public BMW320() &#123; System.out.println("创建了BMW320对象。。"); &#125; &#125; public static class BMW523 extends BMW &#123; public BMW523() &#123; System.out.println("创建了BMW523对象。。"); &#125; &#125; public static class BMWFactory &#123; public BMW createBMW(int type) &#123; switch (type) &#123; case 320: return new BMW320(); case 523: return new BMW523(); default: break; &#125; return null; &#125; &#125;&#125; 在每次增加产品的时候，工厂类也得变动。这样违背了开闭原则，我们成这种工厂类为上帝类或全能类，解决方式是使用下面的工厂方法模式 工厂方法模式一个产品对象分配一个工厂类来生产12345678910111213141516171819202122232425262728293031323334353637383940import java.util.HashMap;import java.util.Map;public class FactoryDemo &#123; private static final Map&lt;Integer, Factory&gt; factoryMap = new HashMap&lt;&gt;(); static &#123; factoryMap.put(320, new FactoryBMW320()); factoryMap.put(523, new FactoryBMW523()); &#125; public static abstract class BMW &#123; public BMW() &#123; &#125; &#125; public static class BMW320 extends BMW &#123; public BMW320() &#123; System.out.println("创建了BMW320对象。。"); &#125; &#125; public static class BMW523 extends BMW &#123; public BMW523() &#123; System.out.println("创建了BMW523对象。。"); &#125; &#125; public static interface Factory &#123; public BMW createBMW(); &#125; public static class FactoryBMW320 implements Factory &#123; public BMW createBMW() &#123; return new BMW320(); &#125; &#125; public static class FactoryBMW523 implements Factory &#123; public BMW createBMW() &#123; return new BMW523(); &#125; &#125; public static void main(String[] args) &#123; factoryMap.get(320).createBMW(); factoryMap.get(523).createBMW(); &#125;&#125; 抽象工厂模式同一类型产品对象分配一个工厂类生产1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768import java.util.HashMap;import java.util.Map;public class FactoryDemo &#123; private static final Map&lt;Integer, Factory&gt; factoryMap = new HashMap&lt;&gt;(); static &#123; factoryMap.put(320, new FactoryBMW320()); factoryMap.put(523, new FactoryBMW523()); &#125; public static abstract class BMW &#123; public BMW() &#123; &#125; &#125; public static class BMW320 extends BMW &#123; public BMW320() &#123; System.out.println("创建了BMW320对象。。"); &#125; &#125; public static class BMW523 extends BMW &#123; public BMW523() &#123; System.out.println("创建了BMW523对象。。"); &#125; &#125; public static abstract class Aircondition &#123; public Aircondition() &#123; &#125; &#125; public static class AirconditionBMW320 extends Aircondition &#123; public AirconditionBMW320() &#123; System.out.println("创建了AirconditionBMW320对象。。"); &#125; &#125; public static class AirconditionBMW523 extends Aircondition &#123; public AirconditionBMW523() &#123; System.out.println("创建了AirconditionBMW523对象。。"); &#125; &#125; public static interface Factory &#123; public BMW createBMW(); public Aircondition createAirc(); &#125; public static class FactoryBMW320 implements Factory &#123; public BMW createBMW() &#123; return new BMW320(); &#125; public Aircondition createAirc() &#123; return new AirconditionBMW320(); &#125; &#125; public static class FactoryBMW523 implements Factory &#123; public BMW createBMW() &#123; return new BMW523(); &#125; public Aircondition createAirc() &#123; return new AirconditionBMW523(); &#125; &#125; public static void main(String[] args) &#123; Factory factory320 = factoryMap.get(320); factory320.createBMW(); factory320.createAirc(); Factory factory523 = factoryMap.get(523); factory523.createBMW(); factory523.createAirc(); &#125;&#125; 工厂模式的优点 解耦，符合开闭原则 如果初始化需要配置多种参数和环境，可以降低代码重复，易于管理维护 封装了创建对象的逻辑，减少使用者因为创建逻辑导致的错误 可以使用不同的工厂方法，返回不同构造函数（参数不同）创建的对象工厂模式的缺点： 各个产品族需要抽离出稳定的相同的纬度 增加一个新的产品等级结构很复杂，需要修改抽象工厂和所有具体的工厂实现类，对开闭原则的支持沉陷倾斜性 策略模式实现同一个接口的不同算法逻辑实现12345678910111213141516171819202122232425262728293031323334353637public class StrategyDemo &#123; public static interface Strategy &#123; public void show(); &#125; public static class StrategyA implements Strategy &#123; public void show() &#123; System.out.println("为春节准备的促销活动A"); &#125; &#125; public static class StrategyB implements Strategy &#123; public void show() &#123; System.out.println("为春节准备的促销活动B"); &#125; &#125; public static class StrategyC implements Strategy &#123; public void show() &#123; System.out.println("为春节准备的促销活动C"); &#125; &#125; public static Strategy getStrategy(String type) &#123; switch (type) &#123; case "A": return new StrategyA(); case "B": return new StrategyB(); case "C": return new StrategyC(); default: return null; &#125; &#125; public static void main(String[] args) &#123; getStrategy("A").show(); getStrategy("B").show(); getStrategy("C").show(); &#125;&#125; 享元模式享元模式一般都会与工厂模式整合在一起 就是一个收集所有工厂实现类的集合类工具，传入一个工厂类外部状态，返回一个工厂实现类，如果工厂实现类不存在，就新创建一个，保存到集合中，然后再返回给调用者 代码示例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182import java.util.HashMap;import java.util.Map;public class FactoryDemo &#123; public static void main(String[] args) &#123; BMWFactory factory1 = FactoryCollector.getFactory("320"); Engine enginA = factory1.createEngine(); Aircondition airconditionA = factory1.createAircondition(); BMWFactory factory2 = FactoryCollector.getFactory("523"); Engine enginB = factory2.createEngine(); Aircondition airconditionB = factory2.createAircondition(); &#125; // 享元模式 public static class FactoryCollector &#123; private static final Map&lt;String, BMWFactory&gt; map = new HashMap&lt;String, BMWFactory&gt;(); public static BMWFactory getFactory(String type) &#123; BMWFactory factory = map.get(type); if (factory == null) &#123; String factoryName = "com.test.FactoryDemo$FactoryBMW" + type; try &#123; Class&lt;?&gt; clazz = Class.forName(factoryName); BMWFactory newFact = (BMWFactory) clazz.newInstance(); map.put(type, newFact); return newFact; &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (InstantiationException | IllegalAccessException e) &#123; e.printStackTrace(); &#125; &#125; return null; &#125; &#125; public static interface BMWFactory &#123; Engine createEngine(); Aircondition createAircondition(); &#125; public static class FactoryBMW320 implements BMWFactory &#123; public Engine createEngine() &#123; return new EngineA(); &#125; public Aircondition createAircondition() &#123; return new AirconditionA(); &#125; &#125; public static class FactoryBMW523 implements BMWFactory &#123; public Engine createEngine() &#123; return new EngineB(); &#125; public Aircondition createAircondition() &#123; return new AirconditionB(); &#125; &#125; public static abstract class Engine &#123; &#125; public static class EngineA extends Engine &#123; public EngineA() &#123; System.out.println("发动机型号A"); &#125; &#125; public static class EngineB extends Engine &#123; public EngineB() &#123; System.out.println("发动机型号B"); &#125; &#125; public static abstract class Aircondition &#123; &#125; public static class AirconditionA extends Aircondition &#123; public AirconditionA() &#123; System.out.println("空调型号A"); &#125; &#125; public static class AirconditionB extends Aircondition &#123; public AirconditionB() &#123; System.out.println("空调型号B"); &#125; &#125;&#125; 适配器模式类适配器12345678910111213141516171819public class AdapterDemo &#123; public static class Adaptee &#123; public void print220V() &#123; System.out.println("输出220V电压.."); &#125; &#125; public static interface Target &#123; public void print110V(); &#125; public static class Adapter extends Adaptee implements Target &#123; @Override public void print110V() &#123; super.print220V(); &#125; &#125; public static void main(String[] args) &#123; new Adapter().print110V(); &#125;&#125; 对象适配器12345678910111213141516171819202122232425public class AdapterDemo &#123; public static class Adaptee &#123; public void print220V() &#123; System.out.println("输出220V电压.."); &#125; &#125; public static interface Target &#123; public void print110V(); &#125; public static class Adapter implements Target &#123; private Adaptee adaptee; public Adapter(Adaptee adaptee) &#123; this.adaptee = adaptee; &#125; @Override public void print110V() &#123; adaptee.print220V(); &#125; &#125; public static void main(String[] args) &#123; new Adapter(new Adaptee()).print110V(); &#125;&#125; 装饰器模式拿到传进来的对象，调用对象的方法获取数据，对数据进行改装一下，典型应用场景IO Stream123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class DecorateDemo &#123; public static interface Basket &#123; public void show(); &#125; public static class Original implements Basket &#123; public void show() &#123; System.out.print("这个篮子里包含："); &#125; &#125; public static class AppleDecorate implements Basket &#123; private Basket basket; public AppleDecorate(Basket basket) &#123; this.basket = basket; &#125; @Override public void show() &#123; this.basket.show(); System.out.print("苹果 "); &#125; &#125; public static class BananaDecorate implements Basket &#123; private Basket basket; public BananaDecorate(Basket basket) &#123; this.basket = basket; &#125; @Override public void show() &#123; this.basket.show(); System.out.print("香蕉 "); &#125; &#125; public static class OrangeDecorate implements Basket &#123; private Basket basket; public OrangeDecorate(Basket basket) &#123; this.basket = basket; &#125; @Override public void show() &#123; this.basket.show(); System.out.print("橘子 "); &#125; &#125; public static void main(String[] args) &#123; Original origin = new Original(); Basket basket = new OrangeDecorate(new BananaDecorate(new AppleDecorate(origin))); basket.show(); &#125;&#125; 观察者模式12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import java.util.Observable;import java.util.Observer;public class ObserverDemo &#123; public static class Subject1 extends Observable &#123; private int state; public int getState() &#123; return this.state; &#125; public void setState(int state) &#123; this.state = state; setChanged(); notifyObservers(this); &#125; &#125; public static class Subject2 extends Observable &#123; private int state; public int getState() &#123; return this.state; &#125; public void setState(int state) &#123; this.state = state; setChanged(); notifyObservers(this); &#125; &#125; public static class ReaderA implements Observer &#123; @Override public void update(Observable o, Object arg) &#123; if (o instanceof Subject1) &#123; Subject1 subject = (Subject1) o; System.out.println("ReaderA 订阅到了Subject1的数据变化,state=" + subject.getState()); &#125; else if (o instanceof Subject2) &#123; Subject2 subject = (Subject2) o; System.out.println("ReaderA 订阅到了Subject2的数据变化,state=" + subject.getState()); &#125; &#125; &#125; public static class ReaderB implements Observer &#123; @Override public void update(Observable o, Object arg) &#123; if (o instanceof Subject1) &#123; Subject1 subject = (Subject1) o; System.out.println("ReaderB 订阅到了Subject1的数据变化,state=" + subject.getState()); &#125; else if (o instanceof Subject2) &#123; Subject2 subject = (Subject2) o; System.out.println("ReaderB 订阅到了Subject2的数据变化,state=" + subject.getState()); &#125; &#125; &#125; public static void main(String[] args) &#123; Subject1 subject1 = new Subject1(); subject1.addObserver(new ReaderA()); subject1.addObserver(new ReaderB()); subject1.setState(1); Subject2 subject2 = new Subject2(); subject2.addObserver(new ReaderA()); subject2.addObserver(new ReaderB()); subject2.setState(2); &#125;&#125; 建造者模式创建复杂对象的时候使用，比如多个部分的人（不同角色的人身体部位不同），多个部件的电脑（不同电脑各个部件不一样）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879import java.util.ArrayList;import java.util.List;public class BuilderDemo &#123; public static class Computer &#123; private List&lt;String&gt; parts = new ArrayList&lt;&gt;(); public void addPart(String part) &#123; this.parts.add(part); &#125; public void show() &#123; for (String part : parts) &#123; System.out.println(part); &#125; System.out.println("Computer组装完成，请验收!"); &#125; &#125; public static interface Builder &#123; public void buildCPU(); public void buildMainBoard(); public void buildHD(); public Computer get(); &#125; public static class PCBuilder implements Builder &#123; private Computer computer = new Computer(); @Override public void buildCPU() &#123; this.computer.addPart("台式机CPU装上了"); &#125; @Override public void buildMainBoard() &#123; this.computer.addPart("台式机主板装上了"); &#125; @Override public void buildHD() &#123; this.computer.addPart("台式机硬盘装上了"); &#125; @Override public Computer get() &#123; return this.computer; &#125; &#125; public static class PhoneBuilder implements Builder &#123; private Computer computer = new Computer(); @Override public void buildCPU() &#123; this.computer.addPart("手机CPU装上了"); &#125; @Override public void buildMainBoard() &#123; this.computer.addPart("手机主板装上了"); &#125; @Override public void buildHD() &#123; this.computer.addPart("手机硬盘装上了"); &#125; @Override public Computer get() &#123; return this.computer; &#125; &#125; public static class Director &#123; public void construct(Builder builder) &#123; builder.buildCPU(); builder.buildHD(); builder.buildMainBoard(); &#125; &#125; public static void main(String[] args) &#123; Director director = new Director(); Builder builder = new PCBuilder(); director.construct(builder); Computer computer = builder.get(); computer.show(); Builder builder2 = new PhoneBuilder(); director.construct(builder2); Computer computer2 = builder2.get(); computer2.show(); &#125;&#125; 代理模式静态代理java实现静态代理，需要提供公用的接口，以便静态代理类和被代理类的方法都一样1234567891011121314151617181920212223242526public class StaticProxy &#123; public static interface Subject &#123; public void sayHello(); &#125; public static class RealSubject implements Subject &#123; @Override public void sayHello() &#123; System.out.println("this is RealSubject say hello!"); &#125; &#125; public static class ProxySubject implements Subject &#123; private Subject subject; public ProxySubject(Subject subject) &#123; this.subject = subject; &#125; public void sayHello() &#123; System.out.println("log..."); this.subject.sayHello(); System.out.println("log..."); &#125; &#125; public static void main(String[] args) &#123; // 怎么这么像装饰器模式？ new ProxySubject(new RealSubject()).sayHello(); &#125;&#125; 动态代理java动态代理12345678910111213141516171819202122232425262728293031import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;public class JDKDynamicProxy &#123; public static interface Subject &#123; public void syaHallo(); &#125; public static class RealSubject implements Subject &#123; @Override public void syaHallo() &#123; System.out.println("this is RealSubject say hello!"); &#125; &#125; public static class ProxyHandler implements InvocationHandler &#123; private Subject subject; public ProxyHandler(Subject subject) &#123; this.subject = subject; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println("init logging...."); Object result = method.invoke(subject, args); System.out.println("end logging..."); return result; &#125; &#125; public static void main(String[] args) &#123; Subject proxySubject = (Subject) Proxy.newProxyInstance(RealSubject.class.getClassLoader(), RealSubject.class.getInterfaces(), new ProxyHandler(new RealSubject())); proxySubject.syaHallo(); &#125;&#125; cglib动态代理12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import java.lang.reflect.Method;import net.sf.cglib.proxy.Callback;import net.sf.cglib.proxy.CallbackFilter;import net.sf.cglib.proxy.Enhancer;import net.sf.cglib.proxy.MethodInterceptor;import net.sf.cglib.proxy.MethodProxy;import net.sf.cglib.proxy.NoOp;public class CglibDynamicProxy &#123; public static class Subject &#123; public void syaHello() &#123; System.out.println("this is Subject sayHello!"); &#125; &#125; public static class ProxyCreator &#123; public static Object createProxy(Object obj, CallbackFilter callbackFilter, Callback... callbacks) &#123; Enhancer enhancer = new Enhancer(); enhancer.setSuperclass(obj.getClass()); List&lt;Callback&gt; list = new ArrayList&lt;&gt;(Arrays.asList(NoOp.INSTANCE)); list.addAll(Arrays.asList(callbacks)); enhancer.setCallbacks(list.toArray(new Callback[list.size()])); enhancer.setCallbackFilter(callbackFilter); return enhancer.create(); &#125; &#125; public static void main(String[] args) &#123; Object subject = new Subject(); // 创建代理拦截器 MethodInterceptor methodInterceptor = new MethodInterceptor() &#123; @Override public Object intercept(Object obj, Method method, Object[] args, MethodProxy methodProxy) throws Throwable &#123; System.out.println("init logging..."); Object result = method.invoke(subject, args); System.out.println("end logging..."); return result; &#125; &#125;; // 指定不同的方法使用不同的拦截器 // 生成代理类增加拦截过滤功能,拦截器返回值0：使用空操作代理器代理，n：使用数组下标为n的拦截器元素 CallbackFilter callbackFilter = new CallbackFilter() &#123; @Override public int accept(Method method) &#123; // 默认所有的方法都会走第一个拦截器（上面的methodInterceptor） return 1; &#125; &#125;; Subject proxySubject = (Subject) ProxyCreator.createProxy(subject, callbackFilter, methodInterceptor); proxySubject.syaHello(); &#125;&#125; Cglib实现另类多继承12345678910111213141516171819202122232425262728293031323334import net.sf.cglib.proxy.Mixin;public class CglibMultipleInheritance &#123; public static interface Interface1 &#123; public void sayHello1(); &#125; public static interface Interface2 &#123; public void sayHello2(); &#125; public static interface Interface3 &#123; public void sayHello3(); &#125; public static class Interface1Impl implements Interface1 &#123; public void sayHello1() &#123; System.out.println("this is interface1"); &#125; &#125; public static class Interface2Impl implements Interface2 &#123; public void sayHello2() &#123; System.out.println("this is interface2"); &#125; &#125; public static class Interface3Impl implements Interface3 &#123; public void sayHello3() &#123; System.out.println("this is interface3"); &#125; &#125; public static void main(String[] args) &#123; Object obj = Mixin.create(new Object[] &#123; new Interface1Impl(), new Interface2Impl(), new Interface3Impl() &#125;); ((Interface1) obj).sayHello1(); ((Interface2) obj).sayHello2(); ((Interface3) obj).sayHello3(); // ((Interface3Impl) obj).sayHello3();// 这是不允许的，会报异常 &#125;&#125; Cglib实现Bean属性值拷贝12345678910111213141516171819202122232425262728293031323334353637import net.sf.cglib.beans.BeanCopier;public class CglibBeanCopy &#123; public static class Person &#123; private String name; private int age; private String sex; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getSex() &#123; return sex; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125; &#125; public static void main(String[] args) &#123; Person p1 = new Person(); p1.name = "zhangsan"; p1.age = 24; p1.sex = "男"; Person p2 = new Person(); // 这个类需要用到getter、setter方法 BeanCopier copier = BeanCopier.create(Person.class, Person.class, false); copier.copy(p1, p2, null); System.out.println(p2.name + "," + p2.age + "," + p2.sex); &#125;&#125;]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TreeMap树状打印输出]]></title>
    <url>%2F2018%2F09%2F29%2F2018-09-29TreeMap%E6%A0%91%E7%8A%B6%E6%89%93%E5%8D%B0%2F</url>
    <content type="text"><![CDATA[实现了一个小功能，可以将二叉树可视化的打印出来，请看下面代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328import com.alibaba.dubbo.common.utils.StringUtils;import sun.reflect.generics.tree.Tree;import javax.swing.tree.TreeNode;import java.io.*;import java.lang.reflect.Field;import java.text.SimpleDateFormat;import java.util.*;import java.util.concurrent.ConcurrentHashMap;public class TestTask &#123; public static void main(String[] args) throws Exception &#123; int[] temp = new int[]&#123;452, 867, 829, 222, 293, 573, 143, 856, 435, 585&#125;; Random rd = new Random(); TreeMap&lt;Integer, Object&gt; treeMap = new TreeMap&lt;&gt;(); for (int i = 0; i &lt; temp.length; i++) &#123; treeMap.put(temp[i], temp[i]); new TreeHandler(transfer(treeMap), " ").printTree(); System.out.println("------"+temp[i]+"------------------------------------------"); &#125;// for (int i = 0; i &lt; 20; i++) &#123;// int num = rd.nextInt(1000);// treeMap.put(num, num);// new TreeHandler(transfer(treeMap), " ").printTree();// System.out.println("------"+num+"------------------------------------------");// &#125; &#125; private static TreeHandler.Node&lt;Object&gt; transfer(TreeMap treeMap) throws Exception &#123; Stack&lt;Object&gt; mapEntryStack = new Stack&lt;&gt;(); Stack&lt;TreeHandler.Node&gt; localStack = new Stack&lt;&gt;(); Field rootEntryField = treeMap.getClass().getDeclaredField("root"); rootEntryField.setAccessible(true); Object node = rootEntryField.get(treeMap); TreeHandler.Node&lt;Object&gt; root = new TreeHandler.Node&lt;&gt;(); TreeHandler.Node&lt;Object&gt; localNode = root; while (true) &#123; while (node != null) &#123; Object key = getEntryKey(node); boolean isBlack = getEntryColor(node); localNode.value = key + (isBlack ? "_b" : "_r"); if (getLeftEntry(node) != null || getRightEntry(node) != null) &#123; mapEntryStack.push(node); localStack.push(localNode); &#125; node = getLeftEntry(node); if (node != null) &#123; TreeHandler.Node&lt;Object&gt; newLocalLeftNode = new TreeHandler.Node&lt;&gt;(); newLocalLeftNode.parent = localNode; localNode.left = newLocalLeftNode; localNode = newLocalLeftNode; &#125; &#125; if (mapEntryStack.isEmpty()) &#123; break; &#125; node = mapEntryStack.pop(); node = node == null ? null : getRightEntry(node); localNode = localStack.pop(); if (node != null) &#123; TreeHandler.Node&lt;Object&gt; newLocalRightNode = new TreeHandler.Node&lt;&gt;(); newLocalRightNode.parent = localNode; localNode.right = newLocalRightNode; localNode = newLocalRightNode; &#125; &#125; return root; &#125; private static Object getLeftEntry(Object rootEntry) throws Exception &#123; Field leftEntryField = rootEntry.getClass().getDeclaredField("left"); leftEntryField.setAccessible(true); return leftEntryField.get(rootEntry); &#125; private static Object getRightEntry(Object rootEntry) throws Exception &#123; Field rightEntryField = rootEntry.getClass().getDeclaredField("right"); rightEntryField.setAccessible(true); return rightEntryField.get(rootEntry); &#125; private static Object getEntryValue(Object rootEntry) throws Exception &#123; Field valueField = rootEntry.getClass().getDeclaredField("value"); valueField.setAccessible(true); return valueField.get(rootEntry); &#125; private static Object getEntryKey(Object rootEntry) throws Exception &#123; Field keyField = rootEntry.getClass().getDeclaredField("key"); keyField.setAccessible(true); return keyField.get(rootEntry); &#125; private static Boolean getEntryColor(Object rootEntry) throws Exception &#123; Field colorField = rootEntry.getClass().getDeclaredField("color"); colorField.setAccessible(true); return (Boolean) colorField.get(rootEntry); &#125; private static void testPrint() &#123; TreeHandler.Node&lt;String&gt; root = new TreeHandler.Node&lt;String&gt;(null, null, null, "1"); TreeHandler.Node&lt;String&gt; left1 = new TreeHandler.Node&lt;String&gt;(root, null, null, "2"); root.left = left1; TreeHandler.Node&lt;String&gt; right1 = new TreeHandler.Node&lt;String&gt;(root, null, null, "3"); root.right = right1; TreeHandler.Node&lt;String&gt; left11 = new TreeHandler.Node&lt;String&gt;(left1, null, null, "4"); left1.left = left11; TreeHandler.Node&lt;String&gt; left12 = new TreeHandler.Node&lt;String&gt;(left1, null, null, "5"); left1.right = left12; TreeHandler.Node&lt;String&gt; right12 = new TreeHandler.Node&lt;String&gt;(right1, null, null, "11"); right1.right = right12; TreeHandler.Node&lt;String&gt; right121 = new TreeHandler.Node&lt;String&gt;(right12, null, null, "24"); right12.left = right121; new TreeHandler(root, "_____").printTree(); &#125; public static class TreeHandler &#123; // 遍历所有节点，查找深度最大的那个 private Stack&lt;Node&gt; stack; private int maxDeepth; private boolean hasInit; private int maxValLen; private String base; private Node root; public TreeHandler(Node root) &#123; this(root, " "); &#125; public TreeHandler(Node root, String base) &#123; this.root = root; stack = new Stack&lt;Node&gt;(); this.maxValLen = base.length(); this.base = base; &#125; private void init() &#123; setHeight(root); setEmptyCount(root); hasInit = true; &#125; private void printTree() &#123; checkInit(); Node node = root; Map&lt;Integer, StringBuilder&gt; map = new HashMap&lt;&gt;(); while (true) &#123; while (node != null) &#123; StringBuilder sb = map.get(node.height); if (sb == null) &#123; sb = new StringBuilder(); map.put(node.height, sb); &#125; appendStr(sb, node); if (node.left != null || node.right != null) &#123; stack.push(node); &#125; node = node.left; &#125; if (stack.isEmpty()) &#123; break; &#125; node = stack.pop(); node = node == null ? null : node.right; &#125; for (int i = 1; i &lt;= maxDeepth; i++) &#123; System.out.println(map.get(i).toString()); System.out.println(); &#125; &#125; private void checkInit() &#123; if (!hasInit) &#123; init(); &#125; &#125; private void appendStr(StringBuilder sb, Node node) &#123; int empty = node.idx; String baseVal = node.value.toString(); if (baseVal.length() &lt; maxValLen) &#123; baseVal = base.substring(baseVal.length()) + node.value; &#125; if (sb.length() &lt; (node.idx + 1) * maxValLen) &#123; for (int i = sb.length(); i &lt; (node.idx + 1) * maxValLen; i++) &#123; sb.append(" "); &#125; &#125; sb.replace(node.idx * maxValLen, (node.idx + 1) * maxValLen, baseVal); &#125; // 计算某个节点的深度 public static int height(Node curr) &#123; int height = 0; if (curr == null) &#123; return height; &#125; do &#123; height++; curr = curr.parent; &#125; while (curr != null); return height; &#125; public int setHeight(Node node) &#123; while (true) &#123; // 如果拿出来的右边叶子节点是null，则会跳过下面while逻辑块，继续拿栈中其它父节点的右边叶子节点 while (node != null) &#123; // 遍历父节点及左边节点，将父节点保存起来 // 如果父节点（也可能没有子节点）不是null节点，顺便将其遍历吧 node.height = height(node); maxDeepth = maxDeepth &gt; node.height ? maxDeepth : node.height;// node.index = index(node); // 当前节点不是叶子节点，将其放入栈中，现在会遍历左边节点，以后会将其从栈中取出来并遍历右边节点 if (node.left != null || node.right != null) &#123; stack.push(node); &#125; node = node.left; &#125; // 通过父节点拿到右边子节点，这样父节点保存在栈中的使命就完成了（就是为了方便拿到右边子节点），可以从栈中剔除掉了 if (stack.isEmpty()) &#123; break; &#125; node = stack.pop(); // 如果再也拿不出父节点来了，就说明遍历结束了 node = node == null ? null : node.right; &#125; return maxDeepth; &#125; public void setEmptyCount(Node node) &#123; while (true) &#123; while (node != null) &#123; node.idx = paddingCount(node); if (node.left != null || node.right != null) &#123; stack.push(node); &#125; node = node.left; &#125; if (stack.isEmpty()) &#123; break; &#125; node = stack.pop(); node = node == null ? null : node.right; &#125; &#125; private int paddingCount(Node node) &#123; int[] trace = trace(node); int count = 0; int height = node.height; for (int i = 0; i &lt; trace.length; i++) &#123; if (trace[i] &gt; 0) &#123; count += 1 &lt;&lt; (maxDeepth - 1 - i); &#125; &#125; // 2的(maxDeepth-1)次方再减一 count += (1 &lt;&lt; (maxDeepth - node.height)) - 1; return count; &#125; public int[] trace(Node l) &#123; int[] temp = new int[l.height - 1]; int tmp = temp.length - 1; while (l.parent != null) &#123; Node parent = l.parent; if (parent.left == l) &#123; temp[tmp--] = -1; &#125; else &#123; temp[tmp--] = 1; &#125; l = parent; &#125; return temp; &#125; // 该层级有多少个元素 public int number(int height) &#123; return 1 &lt;&lt; (height - 1); &#125; // 该节点是该层级的第几个元素 public int index(Node node) &#123; Node l = node; int[] temp = trace(node); int index = 0; for (int i = 0; i &lt; temp.length; i++) &#123; if (temp[i] &gt; 0) &#123; index += (1 &lt;&lt; (node.height - 1 - i)) / 2; &#125; &#125; return index; &#125; public static class Node&lt;T&gt; &#123; private Node left; private Node right; private Node parent; private T value; private int height;// private int index; private int idx; public Node() &#123; &#125; public Node(Node parent, Node left, Node right, T value) &#123; this.parent = parent; this.left = left; this.right = right; this.value = value; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
        <tag>打印</tag>
        <tag>红黑树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BIO-NIO-AIO-Netty实例解析]]></title>
    <url>%2F2018%2F08%2F21%2F2018-08-21BIO-NIO-AIO-Netty%E5%AE%9E%E4%BE%8B%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[同步异步、阻塞非阻塞的概念 同步异步（本地客户端是否主动找代理人处理） 描述的是访问数据的机制，由于IO资源服务器端的原因，本地客户端主动选择的处理方案 同步：是指客户端根据IO资源端的处理时间太长，自己选择等待IO操作完成的一种机制 异步：是指客户端根据IO资源端的处理时间太久，自己选择不等待IO操作完成，去处理别的事务之后再来处理这些数据 阻塞和非阻塞（IO资源服务端是否把客户端给锁住了） 描述的是进程在请求IO资源时，由于IO资源服务器端的原因，本地客户端不得不被动处理的方案 阻塞：一直等待数据资源返回完成（服务端不偷懒） 非阻塞：调用的资源服务端立刻返回响应结果，不会等IO资源准备结束才返回结果（服务端偷懒） 老王烧开水Demo 普通水壶烧水：老王被壶锁住了，不得不站在附近（阻塞），主动的去盯着水是否烧开（同步） 普通水壶烧水：老王没有被壶锁住（非阻塞），但每次都得主动的去观察水有没有烧开（同步） 普通水壶烧水：老王被壶锁住了，不得不站在附近（阻塞），老王给壶安了一个响哨，水开了就告诉他（异步） 普通水壶烧水：老王没被壶锁足（非阻塞），老王还是给壶安了一个响哨，水开了就告诉他（异步） 传统BIO模型传统BIO模型是通过ServerSocket和Socket实现的同步阻塞IO模型 下面直接上demo代码 BIO的Server端代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.io.OutputStreamWriter;import java.io.PrintWriter;import java.net.ServerSocket;import java.net.Socket;public class BioServer &#123; public static void main(String[] args) &#123; int port = 8080; ServerSocket serverSocket = null; try &#123; serverSocket = new ServerSocket(port); System.out.println("启动了服务，端口号为：" + port); while (true) &#123; // 等待客户端的连接请求（阻塞） Socket socket = serverSocket.accept(); System.out.println("服务器端接收到一个连接请求！"); new Thread() &#123; public void run() &#123; BufferedReader reader = null; PrintWriter writer = null; try &#123; // 自己去亲自拿数据（同步） reader = new BufferedReader(new InputStreamReader(socket.getInputStream())); // 自己去亲自响应数据（同步） writer = new PrintWriter(new OutputStreamWriter(socket.getOutputStream())); System.out.println("服务器端开始接收数据！"); while (true) &#123; String line = reader.readLine(); System.out.println("服务器端接收到请求数据：============= " + line); String rlt = "您好，" + line; writer.println(rlt); writer.flush(); System.out.println("服务器端响应请求数据： ============= " + rlt); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; reader.close(); writer.close(); socket.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;; &#125;.start(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if (serverSocket != null) &#123; System.out.println("关闭了服务！"); try &#123; serverSocket.close(); serverSocket = null; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; BIO的Client端代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.io.OutputStreamWriter;import java.io.PrintWriter;import java.net.Socket;import java.util.Scanner;public class BioClient &#123; public static void main(String[] args) throws Exception &#123; String ip = "127.0.0.1"; int port = 8080; Socket socket = null; try &#123; // 必须等服务端连接成功才能离开（阻塞） socket = new Socket(ip, port); socket.setSoTimeout(100000); Scanner sc = new Scanner(System.in); BufferedReader reader = null; PrintWriter writer = null; try &#123; // 自己亲自去获取数据 reader = new BufferedReader(new InputStreamReader(socket.getInputStream())); // 自己亲自去发送数据 writer = new PrintWriter(new OutputStreamWriter(socket.getOutputStream())); while (true) &#123; String line = sc.nextLine(); writer.println(line); writer.flush(); System.out.println("客户端发送请求数据：============= " + line); String rlt = reader.readLine(); System.out.println("客户端接收响应数据： ============= " + rlt); &#125; &#125; finally &#123; sc.close(); reader.close(); writer.close(); &#125; &#125; finally &#123; if (socket != null) &#123; try &#123; socket.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 总结同步阻塞IO就是，自己被IO操作缠住，自己必须亲自去收发信息 伪异步IO模型自己还是被绑起来，但是自己可以通过一个线程池（专门负责收发信息的机构）去收发信息，但是线程池收发信息时自己也得亲自去操作啊，就相当于找了个外包公司去干活，但是活还是一样多，占用人的资源还是一样多。 NIO模型NIO的Server端123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114import java.net.InetSocketAddress;import java.nio.ByteBuffer;import java.nio.channels.SelectableChannel;import java.nio.channels.SelectionKey;import java.nio.channels.Selector;import java.nio.channels.ServerSocketChannel;import java.nio.channels.SocketChannel;import java.util.HashMap;import java.util.Iterator;import java.util.Map;public class NioServers &#123; public static void main(String[] args) throws Exception &#123; int port = 8080; // 创建server通道实例，相当于Bio中的ServerSockets，不过这个可以绑定事件监听 ServerSocketChannel serverChannel = ServerSocketChannel.open(); // 设置这个通道为异步IO，也就是有数据过来，异步进行处理 serverChannel.configureBlocking(false); // 设置socket连接的端口号 serverChannel.bind(new InetSocketAddress(port)); // 创建一个多路服务器，用于通知请求数据到达 Selector selector = Selector.open(); // 将这个通道注册到多路复用监听器上面，监听动作是请求socket连接 serverChannel.register(selector, SelectionKey.OP_ACCEPT); System.out.println("连接通道已经注册了监听事件，服务启动完成！"); // 一个Socket连接拥有同一个SelectionKey，只不过在不同时间段，这个SelectionKey的状态位是不一样的 Map&lt;SelectionKey, String&gt; msgMap = new HashMap&lt;SelectionKey, String&gt;(); ByteBuffer readBuffer = ByteBuffer.allocate(1024); ByteBuffer writeBuffer = ByteBuffer.allocate(1024); // 开始处理连接请求 dowork: while (true) &#123; // 看看有没有连接请求进来 int eventCount = selector.select(); if (eventCount &lt;= 0) &#123;// 这里会一直消耗CPU资源，如果没有连接消息传递的话 continue; &#125; // 拿到所有的连接请求事件句柄 Iterator&lt;SelectionKey&gt; it = selector.selectedKeys().iterator(); while (it.hasNext()) &#123; SelectionKey key = null; // 这里的try_catch是为了防止连接中断 try &#123; // 拿到这个事件句柄就可以干任何事情了 key = it.next(); // 如果事件句柄有效 if (key.isValid()) &#123; // 如果事件句柄状态是接收连接请求 if (key.isAcceptable()) &#123; // 对这个channel操作跟对ServerSocket操作是相似的 ServerSocketChannel serverChannel1 = (ServerSocketChannel) key.channel(); SocketChannel clientChannel = serverChannel1.accept(); // 这个客户端socket也设置成非阻塞的，这样就能绑定到多路复用监听器上了 clientChannel.configureBlocking(false); // 监听客户端socket发送请求数据 clientChannel.register(selector, SelectionKey.OP_READ); &#125; // 如果事件句柄状态是读取数据 else if (key.isReadable()) &#123; readBuffer.clear(); SocketChannel clientChannel = (SocketChannel) key.channel(); int len = clientChannel.read(readBuffer); if (len &gt; 0) &#123; readBuffer.flip(); byte[] bytes = new byte[readBuffer.remaining()]; readBuffer.get(bytes); String requestData = new String(bytes, "UTF-8"); System.out.println("服务器端获取到的数据是：&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; " + requestData); // 将信息和Socket进行绑定保存 msgMap.put(key, requestData); // 然后绑定一个Socket响应事件,接收完请求数据后就可以写数据了 clientChannel.register(selector, SelectionKey.OP_WRITE); &#125; &#125; // 如果事件句柄状态是写出数据 else if (key.isWritable()) &#123; // 如果没有请求数据，就不会响应数据 if (!msgMap.containsKey(key)) &#123; return; &#125; SocketChannel clientChannel = (SocketChannel) key.channel(); writeBuffer.clear(); String responseStr = "你好，" + msgMap.get(key); System.out.println("服务器端返回的数据是：&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; " + responseStr); writeBuffer.put(responseStr.getBytes("UTF-8")); // clear()方法是重置这个缓冲区，使他可以以最大容量接收数据，position-&gt;0,limit-&gt;capacity // flip()是将写入缓冲区数据状态改成读取缓冲区数据状态，position-&gt;0,limit-&gt;原position writeBuffer.flip(); clientChannel.write(writeBuffer); // 重新将channel绑定上读取数据的事件 clientChannel.register(selector, SelectionKey.OP_READ); &#125; &#125; &#125; catch (Exception e) &#123; // 如果socket连接断掉，就必须将socket关闭，否则有可能一直会有socket读事件被加载到事件触发队列里面 System.out.println("远程Socket连接中断！"); if (key != null &amp;&amp; key.isValid()) &#123; SelectableChannel channel = key.channel(); if (channel instanceof ServerSocketChannel) &#123; break dowork; &#125; else if (channel instanceof SocketChannel) &#123; SocketChannel clientChannel = (SocketChannel) channel; clientChannel.close();// 这个地方很重要，关闭客户端连接 &#125; &#125; &#125; finally &#123; it.remove();// 这个地方很重要，移除事件 &#125; &#125; &#125; &#125;&#125; NIO的client端123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990import java.net.InetSocketAddress;import java.net.StandardSocketOptions;import java.nio.ByteBuffer;import java.nio.channels.SelectionKey;import java.nio.channels.Selector;import java.nio.channels.SocketChannel;import java.util.Iterator;import java.util.Scanner;public class NioClients &#123; // 相对于服务器端，客户端就不需要多路复用器了吧，如果想用也可以，那么我们就来实现客户端的多路复用器Nio public static void main(String[] args) throws Exception &#123; String ip = "127.0.0.1"; int port = 8080; SocketChannel clientChannel = SocketChannel.open(); Selector selector = Selector.open(); // 也设置成异步IO，必须在connect之前执行 clientChannel.configureBlocking(false); // 保持长连接 clientChannel.setOption(StandardSocketOptions.SO_KEEPALIVE, true); clientChannel.setOption(StandardSocketOptions.SO_RCVBUF, 128 * 1024); clientChannel.setOption(StandardSocketOptions.SO_SNDBUF, 128 * 1024); boolean connected = clientChannel.connect(new InetSocketAddress(ip, port)); // 如果已经连接上了 if (connected) &#123; clientChannel.finishConnect(); clientChannel.register(selector, SelectionKey.OP_WRITE); &#125; else &#123; // 如果还没有连接成功，向多路复用监听器注册Connect状态 clientChannel.register(selector, SelectionKey.OP_CONNECT); &#125; ByteBuffer readBuffer = ByteBuffer.allocate(1024); ByteBuffer writeBuffer = ByteBuffer.allocate(1024); Scanner sc = new Scanner(System.in); while (true) &#123; int eventCount = selector.select(); if (eventCount &lt;= 0) &#123;// 这里会一直消耗CPU资源，如果没有连接消息传递的话 continue; &#125; Iterator&lt;SelectionKey&gt; it = selector.selectedKeys().iterator(); while (it.hasNext()) &#123; SelectionKey key = it.next(); if (key.isValid()) &#123; // 如果channel处于待连接状态，下面就执行连接动作，直到完成连接 if (key.isConnectable()) &#123; if (clientChannel.finishConnect()) &#123; System.out.println("客户端连接成功！"); clientChannel.register(selector, SelectionKey.OP_WRITE); &#125; else &#123; System.exit(1); &#125; &#125; // 如果是从服务器端接收响应数据事件 else if (key.isReadable()) &#123; readBuffer.clear(); SocketChannel clientChannel1 = (SocketChannel) key.channel(); int len = clientChannel1.read(readBuffer); if (len &gt; 0) &#123; readBuffer.flip(); byte[] bytes = new byte[readBuffer.remaining()]; readBuffer.get(bytes); String responseData = new String(bytes, "UTF-8"); System.out.println("响应信息：" + responseData); clientChannel1.register(selector, SelectionKey.OP_WRITE); &#125; &#125; // 如果客户端可以写数据了，那这个可以写是怎么触发的呢，接收完服务端的数据就触发么？试试吧，看看能用不 else if (key.isWritable()) &#123; writeBuffer.clear(); String line = sc.nextLine(); writeBuffer.put(line.getBytes("UTF-8")); writeBuffer.flip(); SocketChannel clientChannel1 = (SocketChannel) key.channel(); clientChannel1.write(writeBuffer); clientChannel1.register(selector, SelectionKey.OP_READ); &#125; else &#123; // 一直都没有发现别的类型的事件，也就是说OP_CONNECT不会捕捉到？ System.out.println(key.readyOps()); &#125; &#125; else &#123; // 一直都没有发现有无效的key System.out.println(key); &#125; it.remove();// 这个地方很重要 &#125; &#125; &#125;&#125; 总结同步非阻塞IO，终于没有把自己给绑起来了，自己可以去处理别的事情了，但是还得自己去亲自去看看有没有数据准备好，这个定期去看看的频率不好控制，要是看的频繁了会消耗体力消耗CPU，唉，还是愁人 AIO模型AIO的Server端代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158import java.io.IOException;import java.io.UnsupportedEncodingException;import java.net.InetSocketAddress;import java.net.StandardSocketOptions;import java.nio.ByteBuffer;import java.nio.channels.AsynchronousServerSocketChannel;import java.nio.channels.AsynchronousSocketChannel;import java.nio.channels.CompletionHandler;import java.util.concurrent.CountDownLatch;public class AioServer &#123; private static ServerSocketAcceptHandler serverHandler = new ServerSocketAcceptHandler(); private static ClientSocketReadHander clientReadHandler = new ClientSocketReadHander(); private static ClientSocketWriteHandler clientWriteHandler = new ClientSocketWriteHandler(); public static void main(String[] args) &#123; try (AsynchronousServerSocketChannel serverSocketChannel = AsynchronousServerSocketChannel.open().bind(new InetSocketAddress("127.0.0.1", 8080))) &#123; if (serverSocketChannel.isOpen()) &#123; // 设置TCP套接字处于TIME_WAIT状态下的socket，可以重复绑定端口使用，其使用场景是在重启服务的时候，操作系统并不会立刻把端口释放掉，会导致绑定端口失败的情况 serverSocketChannel.setOption(StandardSocketOptions.SO_REUSEADDR, true); // 只需要将接收连接请求的事件处理类注册上就可以了 serverSocketChannel.accept(serverSocketChannel, serverHandler); System.out.println("服务端启动成功！"); // 下面功能就是保持主线程不关闭 CountDownLatch latch = new CountDownLatch(1); latch.await(); &#125; &#125; catch (Exception e) &#123; System.out.println("服务启动异常！" + e.getMessage()); &#125; &#125; // 服务器端接收到连接请求处理逻辑 public static class ServerSocketAcceptHandler implements CompletionHandler&lt;AsynchronousSocketChannel, AsynchronousServerSocketChannel&gt; &#123; @Override public void completed(AsynchronousSocketChannel socketChannel, AsynchronousServerSocketChannel serverSocketChannel) &#123; // 这个地方很重要，接收到socket连接后，要继续绑定监听器，以便继续接受socket连接 serverSocketChannel.accept(serverSocketChannel, serverHandler); System.out.println("当前Socket连接的处理线程是：" + Thread.currentThread().getName()); // 包装一个attachment ReadWriteChannelHandler clientSocketChannelAttachment = new ReadWriteChannelHandler(ByteBuffer.allocate(1024), ByteBuffer.allocate(1024), socketChannel); // 注册一个处理read事件的handler socketChannel.read(clientSocketChannelAttachment.getReadBuffer(), clientSocketChannelAttachment, clientReadHandler); &#125; @Override public void failed(Throwable exc, AsynchronousServerSocketChannel serverSocketChannel) &#123; System.out.println("ServerSocketAcceptHandler failed!"); try &#123; serverSocketChannel.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; // Socket连接处理读取数据的处理逻辑 public static class ClientSocketReadHander implements CompletionHandler&lt;Integer, ReadWriteChannelHandler&gt; &#123; @Override public void completed(Integer len, ReadWriteChannelHandler handler) &#123; System.out.println("当前Socket写入的处理线程是：" + Thread.currentThread().getName()); try &#123; if (len &gt; 0) &#123; // 将接收客户端的请求数据转换成字符串 ByteBuffer readBuffer = handler.getReadBuffer(); readBuffer.flip(); byte[] bytes = new byte[readBuffer.remaining()]; readBuffer.get(bytes); String requestData = new String(bytes, "UTF-8"); System.out.println("请求的数据为：&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; " + requestData); ByteBuffer writeBuffer = handler.getWriteBuffer(); String responseData = new String("你好，") + requestData; System.out.println("请求响应数据为：&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; " + responseData); // 将响应数据返回给客户端 writeBuffer.clear(); writeBuffer.put(responseData.getBytes("UTF-8")); writeBuffer.flip(); AsynchronousSocketChannel socketChannel = handler.getSocketChannel(); socketChannel.write(writeBuffer, handler, clientWriteHandler); &#125; &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; &#125; @Override public void failed(Throwable exc, ReadWriteChannelHandler handler) &#123; System.out.println("ClientSocketReadHander failed!"); AsynchronousSocketChannel socketChannel = handler.getSocketChannel(); try &#123; if (socketChannel != null) &#123; socketChannel.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; // Socket连接处理写入数据的逻辑处理 public static class ClientSocketWriteHandler implements CompletionHandler&lt;Integer, ReadWriteChannelHandler&gt; &#123; @Override public void completed(Integer len, ReadWriteChannelHandler handler) &#123; System.out.println("当前Socket写出的处理线程是：" + Thread.currentThread().getName()); ByteBuffer writeBuffer = handler.getWriteBuffer(); AsynchronousSocketChannel socketChannel = handler.getSocketChannel(); if (writeBuffer.hasRemaining()) &#123; // 如果还有数据没有写完，继续写完 socketChannel.write(writeBuffer, handler, clientWriteHandler); &#125; else &#123; // 如果响应数据发送完成，继续读取客户端的请求数据 ByteBuffer readBuffer = handler.getReadBuffer(); readBuffer.clear(); socketChannel.read(readBuffer, handler, clientReadHandler); &#125; &#125; @Override public void failed(Throwable exc, ReadWriteChannelHandler handler) &#123; System.out.println("ClientSocketWriteHandler failed!"); AsynchronousSocketChannel socketChannel = handler.getSocketChannel(); try &#123; if (socketChannel != null) &#123; socketChannel.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; public static class ReadWriteChannelHandler &#123; private ByteBuffer readBuffer; private ByteBuffer writeBuffer; private AsynchronousSocketChannel socketChannel; public ReadWriteChannelHandler(ByteBuffer readBuffer, ByteBuffer writeBuffer, AsynchronousSocketChannel socketChannel) &#123; this.readBuffer = readBuffer; this.writeBuffer = writeBuffer; this.socketChannel = socketChannel; &#125; public ByteBuffer getReadBuffer() &#123; return readBuffer; &#125; public void setReadBuffer(ByteBuffer readBuffer) &#123; this.readBuffer = readBuffer; &#125; public ByteBuffer getWriteBuffer() &#123; return writeBuffer; &#125; public void setWriteBuffer(ByteBuffer writeBuffer) &#123; this.writeBuffer = writeBuffer; &#125; public AsynchronousSocketChannel getSocketChannel() &#123; return socketChannel; &#125; public void setSocketChannel(AsynchronousSocketChannel socketChannel) &#123; this.socketChannel = socketChannel; &#125; &#125;&#125; AIO的Client端123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138import java.io.IOException;import java.io.UnsupportedEncodingException;import java.net.InetSocketAddress;import java.net.StandardSocketOptions;import java.nio.ByteBuffer;import java.nio.channels.AsynchronousSocketChannel;import java.nio.channels.CompletionHandler;import java.util.Scanner;import java.util.concurrent.CountDownLatch;public class AioClient &#123; private static ClientSocketReadHander clientReadHandler = new ClientSocketReadHander(); private static ClientSocketWriteHandler clientWriteHandler = new ClientSocketWriteHandler(); private static Scanner sc = new Scanner(System.in); public static void main(String[] args) &#123; try (AsynchronousSocketChannel clientChannel = AsynchronousSocketChannel.open()) &#123; clientChannel.connect(new InetSocketAddress("127.0.0.1", 8080)).get(); clientChannel.setOption(StandardSocketOptions.SO_KEEPALIVE, true); // 发送数据消息给服务器 ReadWriteChannelHandler handler = new ReadWriteChannelHandler(ByteBuffer.allocate(1024), ByteBuffer.allocate(1024), clientChannel); String line = sc.nextLine(); ByteBuffer writeBuffer = handler.getWriteBuffer(); writeBuffer.clear(); writeBuffer.put(line.getBytes()); writeBuffer.flip(); clientChannel.write(writeBuffer, handler, clientWriteHandler); // 下面的代码是为了维持main线程持续运行 CountDownLatch cdl = new CountDownLatch(1); cdl.await(); &#125; catch (Exception e) &#123; System.out.println("客户端Socket连接异常！"); &#125; &#125; // Socket连接处理读取数据的处理逻辑 public static class ClientSocketReadHander implements CompletionHandler&lt;Integer, ReadWriteChannelHandler&gt; &#123; @Override public void completed(Integer len, ReadWriteChannelHandler handler) &#123; System.out.println("当前Socket写入的处理线程是：" + Thread.currentThread().getName()); try &#123; if (len &gt; 0) &#123; // 接收服务器端返回的响应数据 ByteBuffer readBuffer = handler.getReadBuffer(); readBuffer.flip(); byte[] bytes = new byte[readBuffer.remaining()]; readBuffer.get(bytes); String responseData = new String(bytes, "UTF-8"); System.out.println("客户端收到响应数据为：&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; " + responseData); // 接收到服务器端的响应数据，继续发送请求数据 String line = sc.nextLine(); ByteBuffer writeBuffer = handler.getWriteBuffer(); writeBuffer.clear(); writeBuffer.put(line.getBytes("UTF-8")); writeBuffer.flip(); AsynchronousSocketChannel socketChannel = handler.getSocketChannel(); socketChannel.write(writeBuffer, handler, clientWriteHandler); &#125; &#125; catch (UnsupportedEncodingException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; @Override public void failed(Throwable exc, ReadWriteChannelHandler handler) &#123; System.out.println("ClientSocketReadHander failed!"); AsynchronousSocketChannel socketChannel = handler.getSocketChannel(); try &#123; if (socketChannel != null) &#123; socketChannel.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; // Socket连接处理写入数据的逻辑处理 public static class ClientSocketWriteHandler implements CompletionHandler&lt;Integer, ReadWriteChannelHandler&gt; &#123; @Override public void completed(Integer len, ReadWriteChannelHandler handler) &#123; System.out.println("当前Socket写出的处理线程是：" + Thread.currentThread().getName()); ByteBuffer writeBuffer = handler.getWriteBuffer(); AsynchronousSocketChannel socketChannel = handler.getSocketChannel(); if (writeBuffer.hasRemaining()) &#123; // 如果还有数据没有写完，继续写完 socketChannel.write(writeBuffer, handler, clientWriteHandler); &#125; else &#123; // 发送请求数据完成，开始等待服务器端的响应数据 ByteBuffer readBuffer = handler.getReadBuffer(); readBuffer.clear(); socketChannel.read(readBuffer, handler, clientReadHandler); &#125; &#125; @Override public void failed(Throwable exc, ReadWriteChannelHandler handler) &#123; System.out.println("ClientSocketWriteHandler failed!"); AsynchronousSocketChannel socketChannel = handler.getSocketChannel(); try &#123; if (socketChannel != null) &#123; socketChannel.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; public static class ReadWriteChannelHandler &#123; private ByteBuffer readBuffer; private ByteBuffer writeBuffer; private AsynchronousSocketChannel socketChannel; public ReadWriteChannelHandler(ByteBuffer readBuffer, ByteBuffer writeBuffer, AsynchronousSocketChannel socketChannel) &#123; this.readBuffer = readBuffer; this.writeBuffer = writeBuffer; this.socketChannel = socketChannel; &#125; public ByteBuffer getReadBuffer() &#123; return readBuffer; &#125; public void setReadBuffer(ByteBuffer readBuffer) &#123; this.readBuffer = readBuffer; &#125; public ByteBuffer getWriteBuffer() &#123; return writeBuffer; &#125; public void setWriteBuffer(ByteBuffer writeBuffer) &#123; this.writeBuffer = writeBuffer; &#125; public AsynchronousSocketChannel getSocketChannel() &#123; return socketChannel; &#125; public void setSocketChannel(AsynchronousSocketChannel socketChannel) &#123; this.socketChannel = socketChannel; &#125; &#125;&#125; 总结自己终于不用被锁住了，而且有任务来了直接去通知小弟去处理了，自己就啥都不用操心了，管理好小弟去接收任务和处理任务就可以了，这就是管理的终极目的，资源有效分配 Buffer缓冲区知识Buffer缓冲区，顾名思义就是一个容器，一个连续的数组，有容量大小，就相当于一个码头里的一个仓库,仓库可以存放的集装箱是有限制的 Channel就相当于火车、轮船等运输工具。 首先码头里的仓库需要准备好商品（数据），准备好之后通知火车轮船(Channel)通过固定的线路将仓库(Buffer)里准备好的集装箱(数据)运送到另一个地方码头的仓库(Buffer)里 下面是buffer的三个属性 capacity： buffer的整个容量，一直都是固定的，仓库的容量大小 position： 当前读写的指针位置，当前正在摆放或者正在提取货物的位置 limit： 当前读写的限制位置，能提取或摆放货物到哪里为止的位置 往buffer中写数据的两种方法：12int size = channel.read(buffer);// 从channel中读取数据写入缓冲区buffer.put(bytes);// 将byte数组里的数据写入缓冲区 从buffer中读取数据的三种方式:1234int size = channel.write(buffer);// 将缓冲区里的数据写入channel中byte bt = buffer.get(); // 从buffer中读取一个bytebyte[] bytes = new byte[1024];buffer.get(bytes); Buffer缓冲区切换状态的方法： flip() 写-&gt;读 将写入buffer模式转换成读取buffer模式 调用之前：0—————–&gt;position————&gt;capacity/limit 调用之后：position———-&gt;limit—————&gt;capacity rewind() 读-&gt;读 调用之前：0—————-&gt;position–&gt;limit——-&gt;capacity 调用之后：position———————&gt;limit——-&gt;capacity clear() 读-&gt;写 不会将数据真的清除 调用之前：0————–&gt;position—&gt;limit———-&gt;capacity 调用之后：position————————————-&gt;capacity/limit compact() 读-&gt;写 将所有未读取的数据拷贝到buffer起始处，将position设置到最后一个未读元素之后 调用之前：0————–&gt;position—&gt;limit———–&gt;capacity 调用之后：0—&gt;position——————————-&gt;capacity/limit mark() 读-&gt;读 标记某个重要的下标 调用之前：0————-&gt;position————-&gt;limit————&gt;capacity 调用之后：0————-&gt;position/mark——–&gt;limit———–&gt;capacity reset() 读-&gt;读 返回重要的下标重新读 调用之前：0————-&gt;mark—-&gt;position—-&gt;limit———–&gt;capacity 调用之后：0————-&gt;position/mark——–&gt;limit———–&gt;capacity Nettynetty是java的开源框架，提供异步的、事件驱动的网络应用程序框架和工具，用以快速开发高性能、高可靠性的网络服务器和客户端程序 netty是一个NIO客户端，服务端框架，可以快速简单的开发稳定的网络应用程序，例如服务端和客户端的协议，它简化了网络编程规范 下面是一个netty测试实例 server端代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071import io.netty.bootstrap.ServerBootstrap;import io.netty.buffer.ByteBuf;import io.netty.buffer.Unpooled;import io.netty.channel.ChannelHandlerContext;import io.netty.channel.ChannelInboundHandlerAdapter;import io.netty.channel.ChannelInitializer;import io.netty.channel.ChannelOption;import io.netty.channel.EventLoopGroup;import io.netty.channel.nio.NioEventLoopGroup;import io.netty.channel.socket.SocketChannel;import io.netty.channel.socket.nio.NioServerSocketChannel;import io.netty.handler.codec.LineBasedFrameDecoder;import io.netty.handler.codec.string.StringDecoder;import java.util.Date;public class NettyServer &#123; public static void main(String[] args) throws InterruptedException &#123; // 分发任务的Boss线程 EventLoopGroup bossGroup = new NioEventLoopGroup(); // 执行上面boss分发的任务的工作线程 EventLoopGroup workerGroup = new NioEventLoopGroup(); try &#123; // server启动器 ServerBootstrap serverBootstrap = new ServerBootstrap(); // 设置NIO的分发线程和工作线程 serverBootstrap.group(bossGroup, workerGroup); // 设置为NIOchannel serverBootstrap.channel(NioServerSocketChannel.class); // 设置重用地址 // serverBootstrap.option(ChannelOption.SO_REUSEADDR, true); // 设置传输的大小 serverBootstrap.option(ChannelOption.SO_BACKLOG, 2048); serverBootstrap.childOption(ChannelOption.SO_KEEPALIVE, true); // 设置数据传输过来之后的处理Handler serverBootstrap.childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123; @Override protected void initChannel(SocketChannel socketChannel) throws Exception &#123; socketChannel.pipeline().addLast(new NettyServerInChannel()); &#125; &#125;); System.out.println("服务器已经启动，端口号：" + 8080); serverBootstrap.bind(8080).channel().closeFuture().sync();// 阻塞主线程 &#125; finally &#123; workerGroup.shutdownGracefully(); bossGroup.shutdownGracefully(); &#125; &#125; public static class NettyServerInChannel extends ChannelInboundHandlerAdapter &#123;// ChannelHandlerAdapter @Override public void channelActive(ChannelHandlerContext ctx) throws Exception &#123; super.channelActive(ctx); &#125; @Override public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123; ByteBuf buffer = (ByteBuf) msg; byte[] msgBytes = new byte[buffer.readableBytes()]; buffer.readBytes(msgBytes); buffer.release(); String msgStr = new String(msgBytes); System.out.println(Thread.currentThread().toString()+"，服务器接收到请求："+msgStr); String response = new Date().toString(); ByteBuf responseBuf = Unpooled.copiedBuffer(response.getBytes("utf-8")); ctx.writeAndFlush(responseBuf); &#125; @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123; ctx.close(); &#125; &#125;&#125; client端代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869import java.util.Scanner;import io.netty.bootstrap.Bootstrap;import io.netty.buffer.ByteBuf;import io.netty.buffer.Unpooled;import io.netty.channel.ChannelHandlerContext;import io.netty.channel.ChannelInboundHandlerAdapter;import io.netty.channel.ChannelInitializer;import io.netty.channel.ChannelOption;import io.netty.channel.EventLoopGroup;import io.netty.channel.nio.NioEventLoopGroup;import io.netty.channel.socket.SocketChannel;import io.netty.channel.socket.nio.NioSocketChannel;import io.netty.handler.codec.LineBasedFrameDecoder;import io.netty.handler.codec.string.StringDecoder;public class NettyClient &#123; public static void main(String[] args) &#123; EventLoopGroup workerGroup = new NioEventLoopGroup(); try &#123; Bootstrap bootstrap = new Bootstrap(); bootstrap.group(workerGroup); bootstrap.channel(NioSocketChannel.class); bootstrap.option(ChannelOption.SO_KEEPALIVE, true); bootstrap.handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123; @Override protected void initChannel(SocketChannel socketChannel) throws Exception &#123; socketChannel.pipeline().addLast(new ClientHandler()); &#125; &#125;); bootstrap.connect("127.0.0.1", 8080).channel().closeFuture().sync(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; workerGroup.shutdownGracefully(); &#125; &#125; public static class ClientHandler extends ChannelInboundHandlerAdapter &#123; private Scanner sc = null; public ClientHandler() &#123; sc = new Scanner(System.in); &#125; @Override public void channelActive(ChannelHandlerContext ctx) throws Exception &#123; byte[] requestBytes = "QUERY SERVER TIME".getBytes(); ByteBuf buf = Unpooled.buffer(requestBytes.length); buf.writeBytes(requestBytes); ctx.writeAndFlush(buf); &#125; @Override public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123; ByteBuf buf = (ByteBuf) msg; byte[] bytes = new byte[buf.readableBytes()]; buf.readBytes(bytes); buf.release(); String responseStr = new String(bytes, "utf-8"); System.out.println("RECEIVE SERVER TIME：" + responseStr); Thread.sleep(1000); String line = "QUERY SERVER TIME\n"; ByteBuf writeBuf = Unpooled.copiedBuffer(line.getBytes("utf-8")); ctx.writeAndFlush(writeBuf); &#125; @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123; ctx.close(); &#125; &#125;&#125; 粘包/拆包 因为netty使用的是socket进行字节数据的传输，多个请求同时发送过来的时候就不能确定哪些字节是第一个请求的，哪些字节是第二个请求的，这就导致了粘包的情况发生，要解决这个问题，就需要使用不同的方案进行拆包了 换行拆包，在服务端和客户端代码的Channel初始化方法中将LineBasedFrameDecoder拆包方案配置上，可以实现按回车换行符进行拆包1234567bootstrap.handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123; @Override protected void initChannel(SocketChannel socketChannel) throws Exception &#123; socketChannel.pipeline().addLast(new LineBasedFrameDecoder(1024));// 按换行符进行拆包 socketChannel.pipeline().addLast(new ClientHandler()); &#125;&#125;); 传送数据的时候就需要在发送的字符串数据后面添加上回车换行符了1String response = new Date().toString()+System.getProperty("line.separator"); 字节转字符串，在服务端和客户端代码的Channel初始化方法中将StringDecoder拆包方案配置上，可以实现将字节数据转换成字符串数据12345678serverBootstrap.childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123; @Override protected void initChannel(SocketChannel socketChannel) throws Exception &#123; socketChannel.pipeline().addLast(new LineBasedFrameDecoder(1024));// 按换行符进行拆包 socketChannel.pipeline().addLast(new StringDecoder());// 将byte转换成String socketChannel.pipeline().addLast(new NettyServerInChannel()); &#125;&#125;); 在handler处理类中就可以直接将Object msg强转成String类型的了123456789@Overridepublic void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123; String msgStr = (String)msg; System.out.println(Thread.currentThread().toString()+"，服务器接收到请求："+msgStr); String response = new Date().toString()+System.getProperty("line.separator"); ByteBuf responseBuf = Unpooled.copiedBuffer(response.getBytes("utf-8")); ctx.writeAndFlush(responseBuf);&#125; 自定义拆包分隔符123456789serverBootstrap.childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123; @Override protected void initChannel(SocketChannel socketChannel) throws Exception &#123; ByteBuf delimiter = Unpooled.copiedBuffer("$_$".getBytes()); socketChannel.pipeline().addLast(new DelimiterBasedFrameDecoder(1024,delimiter)); socketChannel.pipeline().addLast(new StringDecoder());// 将byte转换成String socketChannel.pipeline().addLast(new NettyServerInChannel()); &#125;&#125;); 发送信息的时候需要在信息末尾添加上拆包分隔符12345678910@Overridepublic void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123; String request = (String)msg; System.out.println("RECEIVE SERVER TIME：" + request); Thread.sleep(1000); String line = "QUERY SERVER TIME$_$"; // 这里需要添加上拆包分隔符 ByteBuf writeBuf = Unpooled.copiedBuffer(line.getBytes("utf-8")); ctx.writeAndFlush(writeBuf);&#125; IO多路复用又叫事件驱动，当IO事件放生时才会去做相应的处理，IO没有事件发生，则不会进行任何处理。IO有没有事件发生是由操作系统判断提供的 操作系统的这个功能通过select/poll/epoll/kqueue之类的系统调用函数来使用，这些调用函数可以监视多个文件描述符的读写就绪状态，这样多个文件描述符 Reactor反应堆线程模型 单线程模型 与Nio的模型一样 一个线程在处理客户端的接入（acceptor），以及对接收到的字节数据进行处理（handler），都是一个线程在处理 多线程模型 一个线程负责客户端的接入（acceptor），一个线程池负责对接收到的字节数据进行处理（handler） 主从Reactor多线程模型 一个线程池负责客户端的接入（acceptor），另一个线程池负责对接收到的字节数据进行处理（handler） 零拷贝 第一种 Unpooled.directBuffer(2048); Netty接收和发送都采用的DirectBuffer，使用堆外内存进行socket读写，不需要进行字节缓存区的二次拷贝如果使用的是传统的堆内存（HEAP BUFFERS）进行Socket读写，JVM会将堆内存拷贝一份到直接内存，然后才写入Socket中，这样的话，消息在发送过程中就多了一份缓冲区的拷贝 第二种 CompositeByteBuf，它可以将多个ByteBuf封装成一个ByteBuf，对外提供同一封装后的ByteBuf接口 第三种 文件传输领拷贝，Netty使用传输类DefaultFileRegion通过transferTo方法将文件发送到目标Channel中。可以将文件缓冲区中的内容直接发送到目标Channel，不需要我们读取文件然后再发送到Channel中了 内存池就跟线程池似的，netty使用了内存池的机制来优化内存的分配和回收的，与非内存池在性能上有很大的提升 使用方法1ByteBuf buf = PooledByteBufAllocator.DEFAULT.directBuffer(1024); 测试demo123456789101112131415161718192021222324import io.netty.buffer.ByteBuf;import io.netty.buffer.PooledByteBufAllocator;import io.netty.buffer.Unpooled;public class PooledByteBufDemo &#123; public static void main(String[] args) &#123; byte[] bytes = "测试缓冲池".getBytes(); long start = System.currentTimeMillis(); ByteBuf byteBuf; for (int i = 0; i &lt; 10000; i++) &#123; byteBuf = Unpooled.buffer(1024); byteBuf.writeBytes(bytes); byteBuf.release(); &#125; long time = System.currentTimeMillis(); for (int i = 0; i &lt; 10000; i++) &#123; byteBuf = PooledByteBufAllocator.DEFAULT.buffer(1024); byteBuf.writeBytes(bytes); byteBuf.release(); &#125; long end = System.currentTimeMillis(); System.out.println("UnpooledByteBuf use time:"+(time-start)); System.out.println("PooledByteBuf use time:"+(end-time)); &#125;&#125; 测试结果：12UnpooledByteBuf use time:1313PooledByteBuf use time:68 协程一种协作式的用户态概念 单线程进行业务处理 遇到IO阻塞的时候就将线程资源让出来（yield掉），记录当前栈上的数据 IO资源准备好后再找一个线程恢复栈并把阻塞结果放到这个线程上跑 看上去和同步代码没有任何差别 整个流程可以称为coroutine，而跑在coroutine负责调度的线程称之为fiber 所有的一切都是发生在用户态上，没有发生在内核态上，也就没有线程间的上下文切换的开销]]></content>
      <categories>
        <category>经典</category>
      </categories>
      <tags>
        <tag>BIO</tag>
        <tag>AIO</tag>
        <tag>NIO</tag>
        <tag>Netty</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AKKA的使用及原理剖析]]></title>
    <url>%2F2018%2F08%2F17%2F2018-08-17AKKA%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90%2F</url>
    <content type="text"><![CDATA[AKKA是一个在JVM上构建高并发、分布式、有弹性的消息驱动应用的工具集，AKKA中“Actor”只是AKKA工具集中的一部分，它能让我们在编写并发代码时，不用关系低层级的线程和锁。AKKA中其它的工具还包括AKKA Streams和Akka http。尽管AKKA是使用Scala语言编写的，但是它也有Java API 在AKKA中，Actor是最基本的工作单元。Actor是状态和行为的一个容器，它可以创建和监管子Actor。Actor之间都是通过异步进行相互的通讯。这个模型可以有效的保护Actor的内部状态，使其能够实现线程安全，该模型还实现了事件驱动的行为，从而不会阻塞其它的Actor。 类似收发短信，我们需要使用消息来调用Actor，消息发送之后就不可更改。不同的actor所能接收的消息类型是不一样的。actor接收到消息，然后以各种方式对其作出相应，并且还可以发送其它消息，修改自己的状态或行为、创建其它的actor AKKA使用方式 可以将jar包放入Web应用中 可以以微内核的形式使用 使用AKKA的五大好处 易于构建并行和分布式应用，AKKA在设计的时候就采用了异步通讯和分布式架构，并对上层进行了抽象，如Actors，Futures，STM等 可靠性，系统具备自愈能力，在本地和远程都有监护 高性能，在单机情况下，每秒能发送50000000个消息，内存占用小，1GB内存就可以保存2500000个Actors 弹性，无中心，自适应的负载均衡，路由，分区，配置 可扩展，可以使用AKKA扩展包进行扩展 我们看看如何使用 Tell方式调用 创建一个Actor，MessageHandler.java 1234567891011public static class MessageHandler extends AbstractActor &#123; public MessageHandler()&#123; super.getContext().setReceiveTimeout(Duration.create(10, TimeUnit.SECONDS)); &#125; @Override public AbstractActor.Receive createReceive() &#123; return super.receiveBuilder().match(Message.class,message -&gt; &#123; System.out.println("name="+message.getName()+",date="+message.getDate()); &#125;).build(); &#125;&#125; 传递的消息类型定义 12345678910111213141516public static class Message &#123; private String name; private Date date; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Date getDate() &#123; return date; &#125; public void setDate(Date date) &#123; this.date = date; &#125;&#125; main调用示例 123456789101112131415161718public static void main(String[] args) &#123; ActorSystem actorSystem = ActorSystem.create("simple1"); ActorRef counter = actorSystem.actorOf(Props.create(MessageHandler.class, new Creator&lt;MessageHandler&gt;() &#123; @Override public MessageHandler create() throws Exception &#123; return new MessageHandler(); &#125; &#125;), "Counter"); Message msg = new Message(); msg.setName("张三来电话了"); msg.setDate(new Date()); counter.tell(msg,ActorRef.noSender()); try &#123; Thread.sleep(10000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;&#125; 上面这个是tell的使用方式，没有返回的消息 Ask方式调用下面是使用ask调用，可以得到返回消息信息 MessageHandler对象变更如下 12345678910111213public static class MessageHandler extends AbstractActor &#123; public MessageHandler()&#123; super.getContext().setReceiveTimeout(Duration.create(10, TimeUnit.SECONDS)); &#125; @Override public AbstractActor.Receive createReceive() &#123; return super.receiveBuilder().match(Message.class,this::onMessage).build(); &#125; private void onMessage(Message msg)&#123; System.out.println("name="+msg.getName()+",date="+msg.getDate()); this.sender().tell("success",ActorRef.noSender()); &#125;&#125; main调用变更如下 123456789101112131415161718192021public static void main(String[] args) &#123; try &#123; ActorSystem actorSystem = ActorSystem.create("simple1"); ActorRef counter = actorSystem.actorOf(Props.create(MessageHandler.class, new Creator&lt;MessageHandler&gt;() &#123; @Override public MessageHandler create() throws Exception &#123; return new MessageHandler(); &#125; &#125;), "Counter"); Message msg = new Message(); msg.setName("张三来电话了"); msg.setDate(new Date()); Timeout timeout = new Timeout(5,TimeUnit.SECONDS); Future&lt;Object&gt; future = Patterns.ask(counter,msg,timeout); String result = (String)Await.result(future,timeout.duration()); System.out.println("result="+result); Thread.sleep(10000); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; 与spring集成 在spring的配置文件中配置如下bean定义 123&lt;bean id="actorSystem" class="akka.actor.ActorSystem" factory-method="create" scope="singleton"&gt; &lt;constructor-arg value="mgl-actor-system" /&gt;&lt;/bean&gt; 创建SpringExt.java，Actor的Props的提供者，其需要一个可以创建Actor的生产者（SpringActorProducer） 123456789101112131415161718import akka.actor.Extension;import akka.actor.Props;import org.springframework.beans.BeansException;import org.springframework.context.ApplicationContext;import org.springframework.context.ApplicationContextAware;import org.springframework.stereotype.Component;@Component("springExt")public class SpringExt implements Extension,ApplicationContextAware &#123; private ApplicationContext applicationContext; @Override public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123; this.applicationContext = applicationContext; &#125; public Props props(String actorBeanName, Object... args)&#123; return Props.create(SpringActorProducer.class,applicationContext,actorBeanName,args); &#125;&#125; 创建SpringActorProducer.java，Actor实例的生产者 1234567891011121314151617181920212223import org.springframework.context.ApplicationContext;import akka.actor.Actor;import akka.actor.IndirectActorProducer;public class SpringActorProducer implements IndirectActorProducer&#123; private final ApplicationContext applicationContext; private final String actorBeanName; private final Object[] args; public SpringActorProducer(ApplicationContext applicationContext,String actorBeanName,Object... args)&#123; this.applicationContext = applicationContext; this.actorBeanName = actorBeanName; this.args = args; &#125; @SuppressWarnings("unchecked") @Override public Class&lt;? extends Actor&gt; actorClass() &#123; return (Class&lt;? extends Actor&gt;)applicationContext.getType(this.actorBeanName); &#125; @Override public Actor produce() &#123; return (Actor)applicationContext.getBean(actorBeanName,args); &#125;&#125; 定义处理消息的Actor对象 1234567891011121314151617181920212223import akka.actor.AbstractActor;import akka.actor.ActorRef;import org.springframework.context.annotation.Scope;import org.springframework.stereotype.Component;import scala.concurrent.duration.Duration;import java.util.concurrent.TimeUnit;@Component("messageService")@Scope("prototype")public class MessageService extends AbstractActor &#123; public MessageService()&#123; getContext().setReceiveTimeout(Duration.create(10, TimeUnit.SECONDS)); &#125; @Override public Receive createReceive() &#123; return receiveBuilder().match(String.class, message -&gt; &#123; onReceive(message); &#125;).build(); &#125; private void onReceive(String message) &#123; System.out.println("message=="+message); &#125;&#125; 调用方法如下 12345678910111213141516171819202122232425import akka.actor.ActorRef;import akka.actor.ActorSystem;import com.mgl.demo.akka.SpringExt;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;@Controller@RequestMapping("/akka")public class TestController &#123; @Autowired private SpringExt springExt; @Autowired private ActorSystem actorSystem; @RequestMapping("/test") @ResponseBody public String test()&#123; ActorRef actor = actorSystem.actorOf(this.springExt.props("messageService"),"MessageService"+System.nanoTime()); actor.tell("hello zhangsan",ActorRef.noSender()); return "success"; &#125;&#125; 配置扫描器将上面的类都注入到spring容器中 1&lt;context:component-scan base-package="com.mgl.demo" /&gt;]]></content>
      <categories>
        <category>经典</category>
      </categories>
      <tags>
        <tag>AKKA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入剖析ReentrantLock加解锁中CAS和AQS的使用]]></title>
    <url>%2F2018%2F08%2F16%2F2018-08-16%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90ReentrantLock%E5%8A%A0%E8%A7%A3%E9%94%81%E4%B8%ADCAS%E5%92%8CAQS%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[我们在解决同一台服务器多线程按顺序处理同一资源时，通常需要加锁，一般我们会使用Synchronized或者ReentrantLock等加锁手段，下面我们来剖析一下ReentrantLock的加锁解锁的实现原理 ReentrantLock加锁的逻辑通常情况下都会以ReentrantLock.lock()来获取到锁123public void lock() &#123; sync.lock();&#125; ReentrantLock中会有一个NonfairSync非公平锁和FairSync公平锁的实现，下面我们先来讲解非公平锁的实现 非公平锁sync.lock会调用到非公平锁中的lock方法， 首先比较当前锁有没有被占用，没被占用就直接拿到锁 被占用了就会进入acquire(1)方法中去获取锁 1234567891011121314151617181920212223242526272829303132333435363738static final class NonfairSync extends Sync &#123; // ReentrantLock中的 private static final long serialVersionUID = 7316153563782823691L; final void lock() &#123; // 如果compareAndSetState成功了，说明当前线程拿到了锁，将当前线程设置到锁的占用线程字段上 if (compareAndSetState(0, 1)) setExclusiveOwnerThread(Thread.currentThread()); else acquire(1);// 如果锁一直被占用，则需要去排队，这个是非公平锁 &#125; // 去尝试加非公平锁，这里的acquires=1 protected final boolean tryAcquire(int acquires) &#123; // 这个是Sync中的方法 return nonfairTryAcquire(acquires); &#125;&#125;// 这个就是Sync中加非公平锁的逻辑，很简单，就是用CAS改当前ReentrantLock-Node的一个状态final boolean nonfairTryAcquire(int acquires) &#123; // ReentrantLock中的 final Thread current = Thread.currentThread(); int c = getState(); if (c == 0) &#123;// 如果当前ReentrantLock状态是0，就可以去尝试获取锁（非公平锁） if (compareAndSetState(0, acquires)) &#123; setExclusiveOwnerThread(current); return true; &#125; &#125; // 如果状态不为0，表示有线程在占用这把锁，看看占用的线程和当前线程是不是一样，如果一样，说明是重入锁 else if (current == getExclusiveOwnerThread()) &#123; int nextc = c + acquires; if (nextc &lt; 0) // overflow throw new Error("Maximum lock count exceeded"); setState(nextc); return true; &#125; return false;&#125;protected final boolean compareAndSetState(int expect, int update) &#123; // AQS中 return unsafe.compareAndSwapInt(this, stateOffset, expect, update);&#125; 这个方法中还是先去获取锁，如果获取不成功去加入到等到队列中，这个队列是个双向队列 12345public final void acquire(int arg) &#123; // AQS中的方法 if (!tryAcquire(arg) // 这个时候就去竞争锁了，肯定是非公平锁，NonfairSync类中的方法 &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt();&#125; 下面是加入到等待队列中的逻辑 1234567891011121314151617181920212223242526272829private Node addWaiter(Node mode) &#123; // AQS中的方法 // 这个mode是null，创建一个当前线程的Node Node node = new Node(Thread.currentThread(), mode); Node pred = tail; // 这个字段是public abstract class AbstractQueuedSynchronizer extends AbstractOwnableSynchronizer 中的属性 if (pred != null) &#123; // 如果当前节点不是第一个排队的节点 node.prev = pred; // 将当前节点挂到上一个排队节点上去 if (compareAndSetTail(pred, node)) &#123; // 尝试将当前节点设置成末尾节点，如果设置成功就返回当前节点，如果并发情况设置不成功，下面的enq会不断重复设置当前节点为末尾节点 pred.next = node; // 设置上一个末尾节点的下一个节点是当前节点 return node; &#125; &#125; enq(node); // 继续尝试将当前线程节点设置成末尾节点，其实完全可以将上面if那套逻辑去掉，跟下面这套逻辑重复 return node;&#125;private Node enq(final Node node) &#123; // AQS中的方法 for (;;) &#123; Node t = tail; if (t == null) &#123; if (compareAndSetHead(new Node())) // 如果没有在排队的，设置一个head tail = head; // tail=head &#125; else &#123; node.prev = t; // 和上面的addWaiter某些逻辑一样 if (compareAndSetTail(t, node)) &#123; t.next = node; return t; &#125; &#125; &#125;&#125; 加入到等待队列后就走到了acquireQueued逻辑，就需要park掉当前的线程，直到线程被unpark唤醒 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566final boolean acquireQueued(final Node node, int arg) &#123; // AQS中的方法 boolean failed = true; try &#123; boolean interrupted = false; for (;;) &#123; // 在这里一直循环，直到最终拿到锁 final Node p = node.predecessor(); // 获取当前线程节点的上一个节点 if (p == head &amp;&amp; tryAcquire(arg)) &#123;// 如果当前节点的上一个节点是head，那就说明当前节点可以去获取锁了 setHead(node);// 将当前节点设置成head，并且当前节点的prev为null，线程为null p.next = null; // 以前的头节点的next为null，以便于内存回收 failed = false; // 设置加锁成功变量 return interrupted; // 返回结果，线程没有被中断 &#125; // 如果当前节点的上一个节点不是头节点，就去下一步处理 if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) interrupted = true; &#125; &#125; finally &#123; if (failed) // 如果加锁失败 cancelAcquire(node); &#125;&#125;private void setHead(Node node) &#123; // AQS中的 head = node; node.thread = null; node.prev = null;&#125;// 取消加锁private void cancelAcquire(Node node) &#123; // AQS中的 if (node == null) return; node.thread = null; Node pred = node.prev; // 拿到当前节点的上一个节点 while (pred.waitStatus &gt; 0) // 找到一个状态&lt;=0的线程等待节点 node.prev = pred = pred.prev; Node predNext = pred.next; node.waitStatus = Node.CANCELLED; // 置为取消获取锁的状态，这个状态是唯一的大于0的状态 if (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123; // 当前节点是尾节点处理 compareAndSetNext(pred, predNext, null);// 设置pred的next节点为null &#125; else &#123; // 当前节点是中间节点处理 int ws; if (pred != head &amp;&amp; ((ws = pred.waitStatus) == Node.SIGNAL || (ws &lt;= 0 &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp; pred.thread != null) &#123;// 如果上一个节点不是头结点并且是正常等待线程节点 Node next = node.next; if (next != null &amp;&amp; next.waitStatus &lt;= 0) compareAndSetNext(pred, predNext, next);// 设置上一个节点的下一节点是当前节点的下一个节点，当前节点的下一个节点的prev没有设置？ &#125; else &#123;// 当前节点是头节点，或者上一节点已经加锁完成并释放掉了锁 unparkSuccessor(node); // 踢醒下一个等待加锁的线程 &#125; node.next = node; // help GC &#125;&#125;private void unparkSuccessor(Node node) &#123; // AQS中的 int ws = node.waitStatus; if (ws &lt; 0) compareAndSetWaitStatus(node, ws, 0); Node s = node.next; if (s == null || s.waitStatus &gt; 0) &#123; s = null; for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev) if (t.waitStatus &lt;= 0) s = t; &#125; if (s != null) LockSupport.unpark(s.thread);&#125; park之前还需要再尝试获取锁一下，如果当前线程是第一个排队的线程就去再尝试获取一下锁，如果还获取不到，就只能park掉等待unpark了 123456789101112131415private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) &#123; // AQS中的 // 上一个节点的等待状态值 0：线程已取消 -1：线程需要卸载 -2：线程正在条件下等待 -3：指示下一个获取共享应该无条件传播 int ws = pred.waitStatus; if (ws == Node.SIGNAL)// 后续需要卸载的状态，上个节点的状态是-1，那就是需要等待 return true; if (ws &gt; 0) &#123; do &#123; node.prev = pred = pred.prev; &#125; while (pred.waitStatus &gt; 0); pred.next = node; &#125; else &#123; compareAndSetWaitStatus(pred, ws, Node.SIGNAL);// 快轮到了，给一次机会去获取锁，改完状态成-1后就只能去被park掉了 &#125; return false;&#125; 这是要真正的去park掉线程了 1234567891011121314151617private final boolean parkAndCheckInterrupt() &#123; // AQS中的 LockSupport.park(this);// 将线程park掉，一直等到unpark(thread)才能继续往下走 return Thread.interrupted();&#125;public static void park(Object blocker) &#123; // LockSupport中的 Thread t = Thread.currentThread(); // 将当前的锁ReentrantLock放到到线程中 setBlocker(t, blocker); // 第一个参数，时间是绝对的还是相对的，当为true，绝对时间间隔时，等待后面的多长时间就结束，如果是false时，就一直等待直到被调用unpark(thread)方法 UNSAFE.park(false, 0L); setBlocker(t, null);&#125;private static void setBlocker(Thread t, Object arg) &#123; // LockSupport中的 // 每个线程中都会有一个parkBlocker属性，获取这个属性在线程中的偏移量parkBlockerOffset = UNSAFE.objectFieldOffset(tk.getDeclaredField("parkBlocker")); // 设置线程中的parkBlocker对象为当前的ReentrantLock UNSAFE.putObject(t, parkBlockerOffset, arg);&#125; 下面这个Node节点是AQS中定义的类，可以保存当前ReentrantLock中排队的各个线程的节点及节点当前的状态 123456789101112131415161718192021222324252627282930313233static final class Node &#123; // AQS中的 static final Node SHARED = new Node(); static final Node EXCLUSIVE = null; static final int CANCELLED = 1; static final int SIGNAL = -1; static final int CONDITION = -2; static final int PROPAGATE = -3; volatile int waitStatus; volatile Node prev; volatile Node next; volatile Thread thread; Node nextWaiter; final boolean isShared() &#123; return nextWaiter == SHARED; &#125; final Node predecessor() throws NullPointerException &#123; Node p = prev; if (p == null) throw new NullPointerException(); else return p; &#125; Node() &#123; // Used to establish initial head or SHARED marker &#125; Node(Thread thread, Node mode) &#123; // Used by addWaiter this.nextWaiter = mode; this.thread = thread; &#125; Node(Thread thread, int waitStatus) &#123; // Used by Condition this.waitStatus = waitStatus; this.thread = thread; &#125;&#125; 释放锁的逻辑释放锁的逻辑就很简单了，修改当前锁的状态标志位（AQS提供的），unpark排队队列中的第一个线程123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public void unlock() &#123; // ReentrantLock中的 sync.release(1);&#125;public final boolean release(int arg) &#123; // ReentrantLock中的 if (tryRelease(arg)) &#123; // 如果刚好释放锁成功，就踢醒等待队列中的线程去获取锁 Node h = head; if (h != null &amp;&amp; h.waitStatus != 0) // 如果队列中没有线程在排队，直接返回true了，如果队列中有线程在排队获取锁，那就踢醒第一个等待线程 unparkSuccessor(h); return true; &#125; return false;&#125;// 这个是ReentrantLock实现的AQS的抽象方法protected final boolean tryRelease(int releases) &#123; // ReentrantLock中的 int c = getState() - releases; // 现在getState()返回值肯定是1了,c=0 if (Thread.currentThread() != getExclusiveOwnerThread()) throw new IllegalMonitorStateException(); boolean free = false; if (c == 0) &#123; free = true; setExclusiveOwnerThread(null); // 设置占有锁的线程为null &#125; setState(c); // 设置锁的状态为0 return free; // 返回是否释放成功&#125;private void unparkSuccessor(Node node) &#123; // AQS中的 int ws = node.waitStatus; if (ws &lt; 0) // 等待队列的头节点一般都是-1，是0的情况就是刚进入这个方法，另一个线程就来排队获取锁了，还没来得及将waitStatus设置成-1的那一片段时间 compareAndSetWaitStatus(node, ws, 0);// 将头节点的等待状态设置为0 Node s = node.next; if (s == null || s.waitStatus &gt; 0) &#123; s = null; // 从末尾往前找等待节点，看看还有没有&lt;=0状态的线程节点，找到排在最前面的第一个节点 for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev) if (t.waitStatus &lt;= 0) s = t; &#125; if (s != null) LockSupport.unpark(s.thread);&#125;private static final boolean compareAndSetWaitStatus(Node node,int expect,int update) &#123; // AQS中的 return unsafe.compareAndSwapInt(node, waitStatusOffset,expect, update);&#125;// 将线程激活public static void unpark(Thread thread) &#123; // LockSupport中的 if (thread != null) UNSAFE.unpark(thread);// 踢醒当前线程去获取锁&#125; 公平锁如果想创建一个公平锁，可以使用下面的方法1ReentrantLock lock = new ReentrantLock(true);// true:公平锁，false:非公平锁 同样的，公平锁在ReentrantLock中也有一个实现类，FairSync 它也拥有一个lock()的方法123final void lock() &#123; acquire(1);&#125; 这个是AQS中的方法12345public final void acquire(int arg) &#123; // ReentrantLock中的 if (!tryAcquire(arg) &amp;&amp; //没有拿到锁，就去添加到等待队列了 acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt();&#125; 这里的tryAcquire方法就是FairSync中的实现方法了, 而不是NonfairSync中的方法了123456789101112131415161718192021222324252627protected final boolean tryAcquire(int acquires) &#123;// ReentrantLock中的 final Thread current = Thread.currentThread(); int c = getState(); if (c == 0) &#123; if (!hasQueuedPredecessors() &amp;&amp; // 先去判断队列中有没有等待的线程，如果没有等待的线程，可以去拿锁了 compareAndSetState(0, acquires)) &#123;// 看看能不能直接拿到锁 setExclusiveOwnerThread(current); return true; &#125; &#125; else if (current == getExclusiveOwnerThread()) &#123; // 如果锁不是在空闲状态，判断当前线程有没有持有锁 int nextc = c + acquires; if (nextc &lt; 0) throw new Error("Maximum lock count exceeded"); setState(nextc); return true; &#125; return false;&#125;// 判断队列中是否有线程public final boolean hasQueuedPredecessors() &#123; // ReentrantLock中的 Node t = tail; Node h = head; Node s; return h != t &amp;&amp; // 如果队列头不等于队列尾部，说明有线程 ((s = h.next) == null || s.thread != Thread.currentThread());// 如果队列头的next为空（还没初始化完成）或者第一个等待线程不是当前线程，说明队列里面也有线程&#125; 跟NonfairSync中用的tryAcquire方法比较一下，只是多了一个!hasQueuedPredecessors()判断语句，如果排到你了，你才能去拿锁，否则去队列排队 总结，在ReentrantLock的加锁解锁中ReentrantLock的作用如下： 实现AQS的tryAcquire方法逻辑（AQS提供的抽象方法） 提供解锁的tryRelease实现逻辑（AQS提供的抽象方法） 提供是否公平加锁的逻辑（sync = fair ? new FairSync() : new NonfairSync();） 提供修改AQS中的state状态来判断是否获取到锁的逻辑（if (getState() == 0)） 提供改AQS的state状态标志位的逻辑（if (compareAndSetState(0, acquires))） 提供保存获取到当前锁的线程的逻辑（setExclusiveOwnerThread(current)） AQS的作用如下： 提供一个Node对象定义，该节点持有当前竞争锁的线程，可以当做等待队列中的节点挂到队列中，Node对象有prevNode，nextNode可以创建双向链表，Node对象有waitStatus可以保存当前等待锁队列中各个节点线程的状态 提供维护队列的逻辑，将线程往队列里添加、取消线程的排队（addWaiter、cancelAcquire） 提供线程获取锁的总流程逻辑（acquire） 提供遍历线程队列，尝试给线程加锁的逻辑（acquireQueued） 提供将线程park掉和unpark线程的逻辑（parkAndCheckInterrupt、unparkSuccessor） CAS的作用如下： 多线程竞争条件下的乐观锁 多线程下修改锁的状态位的功能（compareAndSetState(0, 1)） 多线程下修改队列头节点的功能（compareAndSetHead(new Node())） 多线程下修改队列尾节点的功能（compareAndSetTail(node, pred)） 多线程下修改某个节点的下一节点的功能（compareAndSetNext(pred, predNext, next)） 多线程下修改某个线程节点的状态值的功能（compareAndSetWaitStatus(node, ws, 0)） LockSupport的作用如下： park掉线程的功能（LockSupport.park(this)） unpark线程的功能（LockSupport.unpark(s.thread)） UNSAFE的作用如下： 乐观锁修改某个对象的某个字段的作用（unsafe.compareAndSwapInt(this, stateOffset, expect, update)） 条件变量Condition的使用condition解决了不能唤醒指定的锁等待的功能，下面我们深入剖析一下源码是如何实现的 我们可以通过lock.newCondition()创建N多个条件变量，给各个线程使用 比如线程1调用lock()完成拿到锁后，有些条件达不到我们的要求，我们就得等到资源就位后再继续工作，那么就用到了condition1.await()功能，等资源就位后，调用condition1.signal()方法就可以让线程1继续往下执行了 await方法我们来看一下await()到底做了一些什么操作1234567891011121314151617181920212223242526272829303132333435363738394041public final void await() throws InterruptedException &#123; // ConditionObject中的 if (Thread.interrupted()) // 如果线程被中断了，抛出异常 throw new InterruptedException(); Node node = addConditionWaiter(); // 这里很重要，将当前线程节点放入到ConditionObject的waiter队列中去 int savedState = fullyRelease(node); // 这里返回的savedState就是1 int interruptMode = 0; while (!isOnSyncQueue(node)) &#123; // 判断这个节点是不是在在同步队列里面，这个节点为什么会进入同步队列里面？ LockSupport.park(this);// 不在同步队列里面就应该park掉当前线程，不让当前线程继续运行了，直到别的线程获取到锁之后unpark该线程，这里就表示await阻塞到这里了 if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)// 如果没有中断 break; &#125; // 被敲醒之后，这个节点就可以去拿锁去了 if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE) interruptMode = REINTERRUPT; if (node.nextWaiter != null) // clean up if cancelled unlinkCancelledWaiters(); if (interruptMode != 0) reportInterruptAfterWait(interruptMode);&#125;private Node addConditionWaiter() &#123; // ConditionObject中的 Node t = lastWaiter; // 拿到最后一个等待线程对象 // If lastWaiter is cancelled, clean out. if (t != null &amp;&amp; t.waitStatus != Node.CONDITION) &#123; unlinkCancelledWaiters(); t = lastWaiter; &#125; Node node = new Node(Thread.currentThread(), Node.CONDITION);// 创建当前线程的一个节点，节点状态是CONDITION=-2 if (t == null) firstWaiter = node;// 因为加锁才能操作，只能一个一个线程的调用await()方法，所以这里不用考虑并发的情况 else t.nextWaiter = node; lastWaiter = node; return node;&#125;final boolean isOnSyncQueue(Node node) &#123; if (node.waitStatus == Node.CONDITION || node.prev == null) // 不在同步队列里面 return false; if (node.next != null) // 如果next为null，表示肯定在同步队列里面 return true; return findNodeFromTail(node);// 从尾节点一个一个去判断吧&#125; 将线程的状态状态全部重置12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152final int fullyRelease(Node node) &#123; // AQS中的 boolean failed = true; try &#123; int savedState = getState();// 当前锁的状态肯定是1 if (release(savedState)) &#123; // 如果重置成功 failed = false; return savedState; &#125; else &#123; throw new IllegalMonitorStateException(); &#125; &#125; finally &#123; if (failed) // 如果重置状态位失败，设置这个节点的waitStatus为CANCELLED node.waitStatus = Node.CANCELLED; &#125;&#125;public final boolean release(int arg) &#123;// AQS中的 if (tryRelease(arg)) &#123;// 重置成功 Node h = head; // 找到AQS的队列头节点 if (h != null &amp;&amp; h.waitStatus != 0) unparkSuccessor(h);// 将等待获取锁的队列中的第一个节点的线程unpark掉，这样第一个等待线程就会 return true; &#125; return false;&#125;// 重置当前锁的状态位和占用线程字段protected final boolean tryRelease(int releases) &#123;// ReentrantLock中的 int c = getState() - releases; if (Thread.currentThread() != getExclusiveOwnerThread()) throw new IllegalMonitorStateException(); boolean free = false; if (c == 0) &#123; free = true; setExclusiveOwnerThread(null);// 设置当前锁的占用线程为null &#125; setState(c);// 设置当前锁的state=0 return free;&#125;private void unparkSuccessor(Node node) &#123; int ws = node.waitStatus; if (ws &lt; 0) compareAndSetWaitStatus(node, ws, 0); Node s = node.next; if (s == null || s.waitStatus &gt; 0) &#123; s = null; for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev) if (t.waitStatus &lt;= 0) s = t; &#125; if (s != null) LockSupport.unpark(s.thread);&#125; 我们看看当前在waiter队列里的线程被敲醒之后会如何处理，现在这个线程节点已经被signal()方法从waiter队列里移出来了 这个线程就去正常的竞争锁去了 跟lock()中的获取锁的逻辑一样123456789101112131415161718192021final boolean acquireQueued(final Node node, int arg) &#123; boolean failed = true; try &#123; boolean interrupted = false; for (;;) &#123; final Node p = node.predecessor(); if (p == head &amp;&amp; tryAcquire(arg)) &#123; setHead(node); p.next = null; // help GC failed = false; return interrupted; &#125; if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) interrupted = true; &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125;&#125; signal方法我们来看看signal()方法123456789101112131415public final void signal() &#123; if (!isHeldExclusively())// 想执行signal，自己必须得拿到锁才行 throw new IllegalMonitorStateException(); Node first = firstWaiter; // 拿到waiter队列中第一个节点 if (first != null) // 这里说明如果先调用signal()方法，是不行的，必须先调用await()才行 doSignal(first);&#125;private void doSignal(Node first) &#123; // ConditionObject中的 do &#123; if ( (firstWaiter = first.nextWaiter) == null) // 从waiter队列中移除第一个节点 lastWaiter = null; first.nextWaiter = null;// 清空第一个节点的下一个节点，这里应该是单向链表 &#125; while (!transferForSignal(first) &amp;&amp; (first = firstWaiter) != null);&#125; 传递信号并unparkwaiter队列中的第一个线程12345678910111213final boolean transferForSignal(Node node) &#123;// AQS 中的 if (!compareAndSetWaitStatus(node, Node.CONDITION, 0))// 转换第一个节点的状态位为0失败的时候就返回false return false; Node p = enq(node); // 这个地方很重要，将ConditionObject中的等待队列中的第一个重新放入AQS中的待获取锁队列中去 int ws = p.waitStatus; if (ws &gt; 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL)) LockSupport.unpark(node.thread); return true;&#125;// 从0状态转换成-1状态private static final boolean compareAndSetWaitStatus(Node node,int expect,int update) &#123; return unsafe.compareAndSwapInt(node, waitStatusOffset, expect, update);&#125; 这个调用很重要，将waiter队列中的第一个线程放入AQS等待获取锁的队列中123456789101112131415private Node enq(final Node node) &#123; // AQS中的 for (;;) &#123; Node t = tail; if (t == null) &#123; // Must initialize if (compareAndSetHead(new Node())) tail = head; &#125; else &#123; node.prev = t; if (compareAndSetTail(t, node)) &#123; t.next = node; return t; &#125; &#125; &#125;&#125; 总结一下：await()方法的作用 将当前线程放到ConditionObject中的waiter队列里去 然后当前线程就被park掉 经过下面的notify()方法的unpark操作，线程被唤醒，继续尝试着去获取锁（acquireQueued(node, savedState)），获取不到锁就继续阻塞park，获取到锁就可以继续进行业务逻辑操作了 notify()方法的作用 将waiter队列中的第一个线程节点拿出来，修改好状态，并将该节点放入AQS的等待获取锁的队列中 uppark第一个线程节点 三个线程按顺序轮流执行demo123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990import java.util.concurrent.CountDownLatch;import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.ReentrantLock;public class TestDemo &#123; public static void main(String[] args)&#123; ReentrantLock lock = new ReentrantLock(); final Condition c1 = lock.newCondition(); final Condition c2 = lock.newCondition(); final Condition c3 = lock.newCondition(); CountDownLatch cdl = new CountDownLatch(3); new Thread()&#123; @Override public void run() &#123; try&#123; lock.lock(); cdl.countDown(); System.out.println("线程1获取到锁，并去等待挨踢"); for(;;)&#123; c1.await(); System.out.println("线程1开始快乐的玩耍！"); Thread.sleep(1000); System.out.println("线程1踢了线程2一下！"); c2.signal(); &#125; &#125;catch (InterruptedException e) &#123; e.printStackTrace(); &#125;finally &#123; lock.unlock(); &#125; &#125; &#125;.start(); new Thread()&#123; @Override public void run() &#123; try&#123; lock.lock(); cdl.countDown(); System.out.println("线程2获取到锁，并去等待挨踢"); for(;;)&#123; c2.await(); System.out.println("线程2开始快乐的玩耍！"); Thread.sleep(1000); System.out.println("线程2踢了线程3一下！"); c3.signal(); &#125; &#125;catch (InterruptedException e) &#123; e.printStackTrace(); &#125;finally &#123; lock.unlock(); &#125; &#125; &#125;.start(); new Thread()&#123; @Override public void run() &#123; try&#123; lock.lock(); cdl.countDown(); System.out.println("线程3获取到锁，并去等待挨踢"); for(;;)&#123; c3.await(); System.out.println("线程3开始快乐的玩耍！"); Thread.sleep(1000); System.out.println("线程3踢了线程1一下！"); c1.signal(); &#125; &#125;catch (InterruptedException e) &#123; e.printStackTrace(); &#125;finally &#123; lock.unlock(); &#125; &#125; &#125;.start(); try &#123; try&#123; cdl.await(); lock.lock(); System.out.println("主线程看到三个线程都准备好挨踢了"); System.out.println("主线程踢了线程1一下"); c1.signal(); &#125;finally &#123; lock.unlock(); &#125; System.out.println("主线程释放掉锁，睡着了！"); Thread.sleep(1000000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 一个线程生产两个线程消费demo12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879import java.util.ArrayList;import java.util.List;import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.ReentrantLock;public class TestDemo &#123; public static void main(String[] args)&#123; ReentrantLock lock = new ReentrantLock(); List&lt;String&gt; products = new ArrayList&lt;&gt;(); final Condition c1 = lock.newCondition(); final Condition c2 = lock.newCondition(); new Thread()&#123; @Override public void run() &#123; try &#123; lock.lock(); for(;;)&#123; if(products.size() &gt;= 10)&#123; c2.signal(); c1.await(); &#125;else&#123; Thread.sleep(1000); String p = System.nanoTime()+""; products.add(p); System.out.println("线程1生产了产品："+p+",size="+products.size()); &#125; &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;finally &#123; lock.unlock(); &#125; &#125; &#125;.start(); new Thread()&#123; @Override public void run() &#123; try &#123; lock.lock(); for(;;)&#123; if(products.size() &lt;= 0 )&#123; c1.signal(); c2.await(); &#125;else&#123; Thread.sleep(1000); String p = products.remove(0); System.out.println("线程2消费了一个产品："+p+",size="+products.size()); &#125; &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;finally &#123; lock.unlock(); &#125; &#125; &#125;.start(); new Thread()&#123; @Override public void run() &#123; try &#123; lock.lock(); for(;;)&#123; if(products.size() &lt;= 0 )&#123; c1.signal(); c2.await(); &#125;else&#123; Thread.sleep(1000); String p = products.remove(0); System.out.println("线程3消费了一个产品："+p+",size="+products.size()); &#125; &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;finally &#123; lock.unlock(); &#125; &#125; &#125;.start(); &#125;&#125;]]></content>
      <categories>
        <category>经典</category>
      </categories>
      <tags>
        <tag>ReentrantLock</tag>
        <tag>CAS</tag>
        <tag>AQS</tag>
        <tag>LockSupport</tag>
        <tag>unsafe</tag>
        <tag>park</tag>
        <tag>unpark</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深度替换JavaBean属性的空值]]></title>
    <url>%2F2018%2F08%2F15%2F2018-08-15%E6%B7%B1%E5%BA%A6%E6%9B%BF%E6%8D%A2JavaBean%E5%B1%9E%E6%80%A7%E7%9A%84%E7%A9%BA%E5%80%BC%2F</url>
    <content type="text"><![CDATA[很多时候我们在提供给第三方调用的接口返回值中经常出现null值，有什么办法可以一次性的将返回对象中所有的null值替换成固定的值呢，这就用到了java中的反射，下面我们来实现一个可以深度替换我们返回JavaBean中值为null的字段为我们给定的值的方法 下面这个PropertyUtil工具类就可以解决深度替换的问题 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125import com.fasterxml.jackson.annotation.JsonIgnore;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.util.ClassUtils;import org.springframework.util.ReflectionUtils;import java.lang.annotation.Annotation;import java.lang.reflect.Field;import java.lang.reflect.Method;import java.lang.reflect.Modifier;import java.util.Arrays;import java.util.Iterator;import java.util.Map;import java.util.Optional;public class PropertyUtil &#123; private static final Logger logger = LoggerFactory.getLogger(PropertyUtil.class); public static &lt;T&gt; void transferNullVal(Object obj, Class&lt;T&gt; clazz, T value) &#123; try &#123; if (obj == null || obj.getClass().isPrimitive() || clazz.isPrimitive()) &#123; return; &#125; if(obj.getClass().isArray())&#123; Object[] objs = (Object[])obj; Optional.ofNullable(objs).map(os-&gt;&#123; Arrays.asList(os).stream().forEach(o-&gt;&#123; transferNullVal(o, clazz, value); &#125;); return os; &#125;); return; &#125;else if(Iterable.class.isAssignableFrom(obj.getClass()))&#123; Iterable&lt;?&gt; iterable = (Iterable&lt;?&gt;)obj; Optional.ofNullable(iterable).map(itr-&gt;&#123; Iterator&lt;?&gt; it = itr.iterator(); while(it.hasNext())&#123; Object ob = it.next(); Optional.ofNullable(ob).map(o-&gt;&#123; transferNullVal(o, clazz, value); return o; &#125;); &#125; return itr; &#125;); return; &#125;else if(Map.class.isAssignableFrom(obj.getClass()))&#123; Map&lt;?,?&gt; map = (Map&lt;?,?&gt;)obj; Optional.ofNullable(map).map(os-&gt;&#123; Optional.ofNullable(os.values()).map(mapVals-&gt;&#123; mapVals.stream().forEach(o-&gt;&#123; transferNullVal(o, clazz, value); &#125;); return mapVals; &#125;); return os; &#125;); return; &#125;else if(ClassUtils.isVisible(obj.getClass(), ClassUtils.getDefaultClassLoader().getParent()))&#123; return; &#125; Field[] fields = obj.getClass().getDeclaredFields(); if (fields == null || fields.length == 0) &#123; return; &#125; for (Field f : fields) &#123; if (f.getType() == clazz) &#123; if (!nullValue(f, obj)) &#123; continue; &#125; if (checkIgnore(f) || checkStaticField(f) || !checkGetMethodPublic(f, obj.getClass())) &#123; continue; &#125; boolean isAccess = f.isAccessible(); ReflectionUtils.makeAccessible(f); ReflectionUtils.setField(f, obj, value); f.setAccessible(isAccess); &#125; else &#123; boolean s = f.isAccessible(); ReflectionUtils.makeAccessible(f); Object val = ReflectionUtils.getField(f, obj); transferNullVal(val, clazz, value); f.setAccessible(s); &#125; &#125; &#125; catch (Exception e) &#123; logger.error("对象属性转换失败！", e); &#125; &#125; private static boolean nullValue(Field f, Object obj) &#123; boolean isAccess = f.isAccessible(); ReflectionUtils.makeAccessible(f); Object val = ReflectionUtils.getField(f, obj); f.setAccessible(isAccess); return val == null; &#125; private static boolean checkIgnore(Field f) &#123; Annotation anno = f.getAnnotation(JsonIgnore.class); return anno != null; &#125; private static boolean checkStaticField(Field f) &#123; return Modifier.isStatic(f.getModifiers()); &#125; private static boolean checkGetMethodPublic(Field f, Class&lt;? extends Object&gt; clazz) &#123; if (f == null) &#123; return false; &#125; String pro = f.getName(); String fuPro = String.valueOf(pro.charAt(0)).toUpperCase() + pro.substring(1); boolean isBool = f.getType() == boolean.class; try &#123; if (!isBool) &#123; String getMethodName = "get" + fuPro; Method getMethod = clazz.getMethod(getMethodName, (Class[]) null); return Modifier.isPublic(getMethod.getModifiers()); &#125; else &#123; String isMethodName = "is" + fuPro; Method isMethod = clazz.getMethod(isMethodName, (Class[]) null); return Modifier.isPublic(isMethod.getModifiers()); &#125; &#125; catch (NoSuchMethodException e) &#123; return false; &#125; &#125;&#125; 测试Demo12345678910111213141516171819202122232425import com.google.gson.Gson;public class Test &#123; public static void main(String[] args) &#123; Person p = new Person(); p.setName("张三"); PropertyUtil.transferNullVal(p, Integer.class, 28); System.out.println(new Gson().toJson(p)); &#125; public static class Person &#123; private String name; private Integer age; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; &#125;&#125; 打印结果如下： {“name”:”张三”,”age”:28}]]></content>
      <categories>
        <category>小工具</category>
      </categories>
      <tags>
        <tag>类加载器</tag>
        <tag>深度替换</tag>
        <tag>属性为空</tag>
        <tag>字段为空</tag>
        <tag>Java反射</tag>
        <tag>ClassUtils</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用注解配置Controller的拦截器]]></title>
    <url>%2F2018%2F08%2F15%2F2018-08-15%E4%BD%BF%E7%94%A8%E6%B3%A8%E8%A7%A3%E9%85%8D%E7%BD%AEController%E7%9A%84%E6%8B%A6%E6%88%AA%E5%99%A8%2F</url>
    <content type="text"><![CDATA[上篇文章我们解决了怎么使用spring的扫描注入功能将指定包下面的拦截器注入到容器中，这篇文章我们将要解决如何更细粒度的配置请求对应的拦截器，那么我们首先想到了注解，基于注解配置可以让不同的业务请求对应到不同的拦截器调用链，好了，正文开始 我们知道要定义一个拦截器需要继承HandlerInterceptorAdapter抽象类，那么我么可以在定义一个抽象类来继承这个HandlerInterceptorAdapter，其它拦截器来继承这个抽象类拦截器，以达到拦截器调用的统一控制 第一步，创建AbstractHandlerInterceptor.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166import java.lang.annotation.Annotation;import javax.annotation.PostConstruct;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.web.method.HandlerMethod;import org.springframework.web.servlet.ModelAndView;import org.springframework.web.servlet.handler.HandlerInterceptorAdapter;public abstract class AbstractHandlerInterceptor extends HandlerInterceptorAdapter &#123; private static Logger logger = LoggerFactory.getLogger(AbstractHandlerInterceptor.class); /** * 覆写afterCompletion，首先判断是否通过注解校验，通过后才执行相应的拦截器逻辑 */ @Override public final void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; if (isForAction(handler)) &#123; afterView(request, response, handler, ex); &#125; &#125; /** * 子类可以实现该方法，该方法替代原HandlerInterceptorAdapter中的afterCompletion函数 * * @param request * @param response * @param handler * @param ex * @throws Exception */ protected abstract void afterView(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception; @Override public final void afterConcurrentHandlingStarted(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; // TODO Auto-generated method stub super.afterConcurrentHandlingStarted(request, response, handler); &#125; /** * 覆写postHandle，首先判断是否通过注解校验，通过后才执行相应的拦截器逻辑 */ @Override public final void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; if (isForAction(handler)) &#123; afterHandle(request, response, handler, modelAndView); &#125; &#125; /** * 子类可以实现该方法，该方法替代原HandlerInterceptorAdapter中的postHandle函数 * * @param request * @param response * @param handler * @param modelAndView * @throws Exception */ protected abstract void afterHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception; /** * 覆写preHandle */ @Override public final boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; logger.debug("interceptor className==&#123;&#125;", this.getClass().getName()); if (!isForAction(handler)) &#123; return true; &#125; return beforeHandle(request, response, handler); &#125; /** * 子类需要重新实现该方法,设置该拦截器为RequiredAnnotation类型 * * @return */ protected abstract Class&lt;? extends Annotation&gt; getRequiredAnnotationClass(); /** * 子类需要重新实现该方法，设置该拦截器为DenyAnnotation类型 * * @return */ protected abstract Class&lt;? extends Annotation&gt; getDenyAnnotationClass(); /** * 子类可以实现该方法，该方法替代原HandlerInterceptorAdapter中的preHandle函数 * * @param request * @param response * @param handler * @return * @throws Exception */ public abstract boolean beforeHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception; /** * 判断该请求是否需要走这个拦截器校验 * * @param handler * @return */ public final boolean isForAction(Object handler) &#123; // 如果该拦截器是RequiredAnnotaion类型，那么Controller中必须有该配置才会走这个拦截器校验 if (!checkRequiredAnnotations(handler)) &#123; return false; &#125; // 如果该拦截器是DenyAnnotation类型，那么Controller中必须有该配置才会不走这个拦截器校验 if (checkDenyAnnotations(handler)) &#123; return false; &#125; return true; &#125; /** * 判断Controller中有没有RequiredAnnotation的注解 * * @param handler * @return */ private boolean checkRequiredAnnotations(Object handler) &#123; Class&lt;? extends Annotation&gt; requiredAnnotation = getRequiredAnnotationClass(); if (requiredAnnotation == null) &#123; return true; &#125; HandlerMethod handlerMethod = (HandlerMethod) handler; Class&lt;?&gt; controllerClazz = handlerMethod.getBeanType(); if (handlerMethod.getMethodAnnotation(requiredAnnotation) != null || controllerClazz.getAnnotation(requiredAnnotation) != null) &#123; return true; &#125; return false; &#125; /** * 判断Controller中有没有DenyAnnotation的注解 * * @param handler * @return */ private boolean checkDenyAnnotations(Object handler) &#123; Class&lt;? extends Annotation&gt; denyAnnotation = getDenyAnnotationClass(); if (denyAnnotation == null) &#123; return false; &#125; HandlerMethod handlerMethod = (HandlerMethod) handler; Class&lt;?&gt; controllerClazz = handlerMethod.getBeanType(); if (handlerMethod.getMethodAnnotation(denyAnnotation) != null || controllerClazz.getAnnotation(denyAnnotation) != null) &#123; return true; &#125; return false; &#125; @PostConstruct public void postConstruct() &#123; Class&lt;? extends Annotation&gt; denyAnnotation = getDenyAnnotationClass(); Class&lt;? extends Annotation&gt; requiredAnnotation = getRequiredAnnotationClass(); if (denyAnnotation != null &amp;&amp; requiredAnnotation != null) &#123; throw new RuntimeException("Only one annotation can be used for the implementation class configuration"); &#125; else if (denyAnnotation == null &amp;&amp; requiredAnnotation == null) &#123; throw new RuntimeException("Annotations for implementation class configuration cannot be empty"); &#125; &#125;&#125; 第二步，创建拦截器LoginInterceptor.java和ParamInterceptor.java123456789101112131415161718192021222324252627282930313233343536373839import java.lang.annotation.Annotation;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.web.servlet.ModelAndView;import com.mgl.interceptor.annotation.DenyLoginAnnotation;import com.mgl.interceptor.annotation.Mapping;import com.mgl.interceptor.base.AbstractHandlerInterceptor;// 可以配置Mapping，也可以不配@Mapping("/test/sayHello")public class LoginInterceptor extends AbstractHandlerInterceptor &#123; private static Logger logger = LoggerFactory.getLogger(LoginInterceptor.class); @Override protected Class&lt;? extends Annotation&gt; getRequiredAnnotationClass() &#123; return null; &#125; @Override protected Class&lt;? extends Annotation&gt; getDenyAnnotationClass() &#123; return DenyLoginAnnotation.class; &#125; @Override public boolean beforeHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; logger.debug("这里进行登录校验！"); return true; &#125; @Override protected void afterView(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; &#125; @Override protected void afterHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; // TODO Auto-generated method stub &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435import java.lang.annotation.Annotation;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.web.servlet.ModelAndView;import com.mgl.interceptor.annotation.Mapping;import com.mgl.interceptor.annotation.ParamVerifyAnnotation;import com.mgl.interceptor.base.AbstractHandlerInterceptor;// 可以配置Mapping，也可以不配@Mapping("/test/sayHello")public class ParamInterceptor extends AbstractHandlerInterceptor &#123; private static Logger logger = LoggerFactory.getLogger(ParamInterceptor.class); @Override protected Class&lt;? extends Annotation&gt; getRequiredAnnotationClass() &#123; return ParamVerifyAnnotation.class; &#125; @Override protected Class&lt;? extends Annotation&gt; getDenyAnnotationClass() &#123; return null; &#125; @Override public boolean beforeHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; logger.debug("这里进行参数校验！"); return true; &#125; @Override protected void afterView(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; &#125; @Override protected void afterHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; // TODO Auto-generated method stub &#125;&#125; 第三步，创建拦截器需要用到的注解类DenyLoginAnnotation.java和ParamVerifyAnnotation.java12345678910111213import java.lang.annotation.Documented;import java.lang.annotation.ElementType;import java.lang.annotation.Inherited;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Documented@Inherited@Target(&#123; ElementType.METHOD, ElementType.TYPE &#125;)@Retention(RetentionPolicy.RUNTIME)public @interface DenyLoginAnnotation &#123; boolean check() default true;&#125; 12345678910111213import java.lang.annotation.Documented;import java.lang.annotation.ElementType;import java.lang.annotation.Inherited;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Documented@Inherited@Target(&#123; ElementType.METHOD, ElementType.TYPE &#125;)@Retention(RetentionPolicy.RUNTIME)public @interface ParamVerifyAnnotation &#123; boolean check() default true;&#125; 第四部，Controller中配置123456789101112131415import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;import com.mgl.interceptor.annotation.DenyLoginAnnotation;@Controller@RequestMapping("/test")public class TestController &#123; @RequestMapping("/sayHello") @ResponseBody // @ParamVerifyAnnotation // 添加这个注解可以走ParamInterceptor @DenyLoginAnnotation // 添加这个注解可以控制不走LoginInterceptor public String testCrossDomain() &#123; return "hello world!"; &#125;&#125; 好了，上面代码实现完成，我们可以通过之前的拦截器扫描注入功能，将这些拦截器都注入到容器了1&lt;custom:interceptor-scan base-package="com.mgl.interceptor" base-class="org.springframework.web.servlet.handler.HandlerInterceptorAdapter,com.mgl.interceptor.base.AbstractHandlerInterceptor" /&gt;]]></content>
      <categories>
        <category>经典</category>
      </categories>
      <tags>
        <tag>Interceptor</tag>
        <tag>注解配置拦截器</tag>
        <tag>Controller配置拦截器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Interceptor自动扫描注入]]></title>
    <url>%2F2018%2F08%2F14%2F2018-08-14%E6%8B%A6%E6%88%AA%E5%99%A8%E8%87%AA%E5%8A%A8%E6%89%AB%E6%8F%8F%E6%B3%A8%E5%85%A5%2F</url>
    <content type="text"><![CDATA[在项目开发中，我们经常会用到spring的拦截器功能，但是在xml配置又很麻烦，拦截器调用顺序又不好控制，所以我们在想，是不是可以使用spring的扫描功能，将拦截器按照顺序注入进去，下面我们来实现这个功能 第一步 在resourcers目录下创建下面两个文件 spring.handlers文件 1http\://www.menggl.com/schema/tools=com.test.custom.config.handler.CustomHandler spring.schemas文件 1http\://www.menggl.com/schema/custom/interceptor-scan.xsd=com/test/custom/config/handler/interceptor-scan.xsd 第二步，在com.mgl.custom.config.handler目录下创建xsd文件12345678910111213141516171819202122&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;xsd:schema xmlns="http://www.mgl.com/schema/tools" xmlns:xsd="http://www.w3.org/2001/XMLSchema" targetNamespace="http://www.mgl.com/schema/tools" xmlns:beans="http://www.springframework.org/schema/beans" xmlns:tool="http://www.springframework.org/schema/tool" elementFormDefault="qualified" attributeFormDefault="unqualified"&gt; &lt;!-- &lt;xsd:import namespace="http://www.springframework.org/schema/beans" schemaLocation="http://www.springframework.org/schema/beans/spring-beans.xsd"/&gt; &lt;xsd:import namespace="http://www.springframework.org/schema/tool" schemaLocation="http://www.springframework.org/schema/tool/spring-tool.xsd"/&gt; --&gt; &lt;xsd:element name="interceptor-scan"&gt; &lt;xsd:complexType&gt; &lt;xsd:attribute name="base-package" type="whiteSpaceTrimType" use="required"/&gt; &lt;xsd:attribute name="base-class" type="whiteSpaceTrimType" use="required"/&gt; &lt;/xsd:complexType&gt; &lt;/xsd:element&gt; &lt;xsd:simpleType name="whiteSpaceTrimType"&gt; &lt;xsd:restriction base="xsd:string"&gt; &lt;xsd:whiteSpace value="collapse"&gt;&lt;/xsd:whiteSpace&gt; &lt;/xsd:restriction&gt; &lt;/xsd:simpleType&gt;&lt;/xsd:schema&gt; 第三步 在com.mgl.custom.config.handler目录下创建CustomHandler.java12345678import org.springframework.beans.factory.xml.NamespaceHandlerSupport;import com.mgl.custom.config.parser.CustomInterceptorParser;public class CustomHandler extends NamespaceHandlerSupport &#123; @Override public void init() &#123; registerBeanDefinitionParser("interceptor-scan", new CustomInterceptorParser()); &#125;&#125; 第四步，在com.mgl.custom.config.parser目录下创建CustomInterceptorParser.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219import java.io.IOException;import java.util.ArrayList;import java.util.List;import java.util.NavigableSet;import java.util.TreeMap;import org.springframework.beans.factory.config.BeanDefinition;import org.springframework.beans.factory.config.BeanDefinitionHolder;import org.springframework.beans.factory.parsing.BeanComponentDefinition;import org.springframework.beans.factory.parsing.CompositeComponentDefinition;import org.springframework.beans.factory.support.AbstractBeanDefinition;import org.springframework.beans.factory.support.BeanDefinitionReaderUtils;import org.springframework.beans.factory.support.ManagedList;import org.springframework.beans.factory.support.RootBeanDefinition;import org.springframework.beans.factory.xml.BeanDefinitionParser;import org.springframework.beans.factory.xml.ParserContext;import org.springframework.beans.factory.xml.XmlReaderContext;import org.springframework.context.ConfigurableApplicationContext;import org.springframework.core.env.Environment;import org.springframework.core.io.Resource;import org.springframework.core.io.ResourceLoader;import org.springframework.core.io.support.ResourcePatternResolver;import org.springframework.core.io.support.ResourcePatternUtils;import org.springframework.core.type.AnnotationMetadata;import org.springframework.core.type.ClassMetadata;import org.springframework.core.type.classreading.CachingMetadataReaderFactory;import org.springframework.core.type.classreading.MetadataReader;import org.springframework.core.type.classreading.MetadataReaderFactory;import org.springframework.util.ClassUtils;import org.springframework.util.MultiValueMap;import org.springframework.util.StringUtils;import org.springframework.web.servlet.handler.MappedInterceptor;import org.w3c.dom.Element;public class CustomInterceptorParser implements BeanDefinitionParser &#123; private static final String BASE_PACKAGE_ATTRIBUTE = "base-package"; private static final String BASE_CLASS_ATTRIBUTE = "base-class"; private static final String ORDER_ANNOTATION = "org.springframework.core.annotation.Order"; private static final String MAPPING_ANNOTATION = "com.mgl.interceptor.annotation.Mapping"; private static final String EXCLUDE_MAPPING_ANNOTATION = "com.mgl.interceptor.annotation.ExcludeMapping"; private static final String DEFAULT_MAPPING_PATTERN = "/**"; private static final String[] DEFAULT_EXCLUDE_MAPPING_PATTERN = new String[] &#123; "/static/*" &#125;; private static final String RESOURCE_PATTERN = "**/*.class"; private static final int DEFAULT_ORDER = 100; private XmlReaderContext readerContext; private ResourcePatternResolver resourcePatternResolver; private Environment environment; private ResourceLoader resourceLoader; private MetadataReaderFactory metadataReaderFactory; @Override public BeanDefinition parse(Element element, ParserContext parserContext) &#123; this.readerContext = parserContext.getReaderContext(); this.environment = this.readerContext.getEnvironment(); this.resourcePatternResolver = ResourcePatternUtils.getResourcePatternResolver(this.readerContext.getResourceLoader()); this.resourceLoader = readerContext.getResourceLoader(); this.metadataReaderFactory = new CachingMetadataReaderFactory(resourceLoader); CompositeComponentDefinition compDefinition = new CompositeComponentDefinition(element.getTagName(), parserContext.extractSource(element)); parserContext.pushContainingComponent(compDefinition); String basePackage = element.getAttribute(BASE_PACKAGE_ATTRIBUTE); basePackage = this.environment.resolvePlaceholders(basePackage); String[] basePackages = StringUtils.tokenizeToStringArray(basePackage, ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS); String baseClass = element.getAttribute(BASE_CLASS_ATTRIBUTE); List&lt;String&gt; baseTypes = this.parseBaseClass(baseClass); for (String bp : basePackages) &#123; String resolvePackage = ClassUtils.convertClassNameToResourcePath(this.environment.resolveRequiredPlaceholders(bp)); String packageSearchPath = ResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX + resolvePackage + '/' + RESOURCE_PATTERN; try &#123; Resource[] resources = this.resourcePatternResolver.getResources(packageSearchPath); resources = sort(resources); for (Resource resource : resources) &#123; MetadataReader metadataReader = metadataReaderFactory.getMetadataReader(resource); ClassMetadata classMetadata = metadataReader.getClassMetadata(); if (classMetadata.isAbstract() || classMetadata.isInterface() || !classMetadata.hasSuperClass() || !validType(classMetadata, baseTypes)) &#123; continue; &#125; String className = classMetadata.getClassName(); RootBeanDefinition mappedInterceptorDef = new RootBeanDefinition(MappedInterceptor.class); mappedInterceptorDef.setSource(resource); mappedInterceptorDef.setRole(BeanDefinition.ROLE_INFRASTRUCTURE); ManagedList&lt;String&gt; includePatterns = new ManagedList&lt;String&gt;(1); String includePattern = getIncludePattern(metadataReader); if (!StringUtils.isEmpty(includePattern)) &#123; includePatterns.add(includePattern); &#125; else &#123; includePatterns.add(DEFAULT_MAPPING_PATTERN); &#125; ManagedList&lt;String&gt; excludePatterns = new ManagedList&lt;String&gt;(2); String[] excludePattern = getExcludePatterns(metadataReader); if (excludePattern != null &amp;&amp; excludePattern.length &gt; 0) &#123; for (String ep : excludePattern) &#123; excludePatterns.add(ep); &#125; &#125; else &#123; for (String ep : DEFAULT_EXCLUDE_MAPPING_PATTERN) &#123; excludePatterns.add(ep); &#125; &#125; mappedInterceptorDef.getConstructorArgumentValues().addIndexedArgumentValue(0, includePatterns); mappedInterceptorDef.getConstructorArgumentValues().addIndexedArgumentValue(1, excludePatterns); AbstractBeanDefinition beanDefinition = BeanDefinitionReaderUtils.createBeanDefinition(null, className, this.readerContext.getBeanClassLoader()); String beanName = this.readerContext.generateBeanName(beanDefinition); String beanClassName = beanDefinition.getBeanClassName(); List&lt;String&gt; aliases = new ArrayList&lt;&gt;(); if (beanClassName != null &amp;&amp; beanName.startsWith(beanClassName) &amp;&amp; beanName.length() &gt; beanClassName.length() &amp;&amp; !this.readerContext.getRegistry().isBeanNameInUse(beanClassName)) &#123; aliases.add(beanClassName); &#125; String[] aliasesArray = StringUtils.toStringArray(aliases); BeanDefinitionHolder interceptorBean = new BeanDefinitionHolder(beanDefinition, beanName, aliasesArray); mappedInterceptorDef.getConstructorArgumentValues().addIndexedArgumentValue(2, interceptorBean); String curentBeanName = parserContext.getReaderContext().registerWithGeneratedName(mappedInterceptorDef); parserContext.registerComponent(new BeanComponentDefinition(mappedInterceptorDef, curentBeanName)); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; parserContext.popAndRegisterContainingComponent(); return null; &#125; private List&lt;String&gt; parseBaseClass(String baseClass) &#123; if (StringUtils.isEmpty(baseClass)) &#123; return new ArrayList&lt;&gt;(); &#125; String[] baseTypes = baseClass.split(","); List&lt;String&gt; retTypes = new ArrayList&lt;&gt;(); if (baseTypes != null &amp;&amp; baseTypes.length &gt; 0) &#123; for (String type : baseTypes) &#123; if (!StringUtils.isEmpty(type)) &#123; retTypes.add(type); &#125; &#125; &#125; return retTypes; &#125; private String[] getExcludePatterns(MetadataReader metadataReader) &#123; List&lt;String&gt; ret = new ArrayList&lt;&gt;(); AnnotationMetadata annotationMetadata = metadataReader.getAnnotationMetadata(); MultiValueMap&lt;String, Object&gt; excludeMappingAttrs = annotationMetadata.getAllAnnotationAttributes(EXCLUDE_MAPPING_ANNOTATION); if (excludeMappingAttrs != null &amp;&amp; excludeMappingAttrs.size() &gt; 0) &#123; List&lt;Object&gt; objs = excludeMappingAttrs.get("value"); for (Object obj : objs) &#123; ret.add((String) obj); &#125; return ret.toArray(new String[ret.size()]); &#125; return null; &#125; private String getIncludePattern(MetadataReader metadataReader) &#123; AnnotationMetadata annotationMetadata = metadataReader.getAnnotationMetadata(); MultiValueMap&lt;String, Object&gt; mappingAttrs = annotationMetadata.getAllAnnotationAttributes(MAPPING_ANNOTATION); if (mappingAttrs != null &amp;&amp; mappingAttrs.size() &gt; 0) &#123; List&lt;Object&gt; objs = mappingAttrs.get("value"); String value = (String) objs.get(0); return StringUtils.isEmpty(value) ? null : value; &#125; return null; &#125; private boolean validType(ClassMetadata classMetadata, List&lt;String&gt; baseTypes) &#123; String superClassName = classMetadata.getSuperClassName(); String[] interfaceNames = classMetadata.getInterfaceNames(); for (String type : baseTypes) &#123; if (superClassName != null) &#123; if (superClassName.contains(type)) &#123; return true; &#125; &#125; if (interfaceNames != null &amp;&amp; interfaceNames.length &gt; 0) &#123; for (String interfaceName : interfaceNames) &#123; if (type.equalsIgnoreCase(interfaceName)) &#123; return true; &#125; &#125; &#125; &#125; return false; &#125; private Resource[] sort(Resource[] resources) throws IOException &#123; List&lt;Resource&gt; ret = new ArrayList&lt;Resource&gt;(); TreeMap&lt;Integer, List&lt;Resource&gt;&gt; map = new TreeMap&lt;&gt;(); for (Resource resource : resources) &#123; MetadataReader metadataReader = this.metadataReaderFactory.getMetadataReader(resource); AnnotationMetadata annotationMetadata = metadataReader.getAnnotationMetadata();// getClassMetadata(); MultiValueMap&lt;String, Object&gt; orderAttrs = annotationMetadata.getAllAnnotationAttributes(ORDER_ANNOTATION); if (orderAttrs != null) &#123; List&lt;Object&gt; values = orderAttrs.get("value"); int order = (int) values.get(0); List&lt;Resource&gt; resourceList = map.get(order); if (resourceList == null) &#123; resourceList = new ArrayList&lt;Resource&gt;(); map.put(order, resourceList); &#125; resourceList.add(resource); &#125; else &#123; List&lt;Resource&gt; resourceList = map.get(DEFAULT_ORDER); if (resourceList == null) &#123; resourceList = new ArrayList&lt;Resource&gt;(); map.put(DEFAULT_ORDER, resourceList); &#125; resourceList.add(resource); &#125; &#125; NavigableSet&lt;Integer&gt; set = map.descendingKeySet(); for (Integer key : set) &#123; ret.addAll(map.get(key)); &#125; return ret.toArray(new Resource[ret.size()]); &#125;&#125; 第五步，创建上面的parser需要的注解类Mapping.java和ExcludeMapping.java12345678910111213import java.lang.annotation.Documented;import java.lang.annotation.ElementType;import java.lang.annotation.Inherited;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Documented@Inherited@Target(&#123; ElementType.METHOD, ElementType.TYPE &#125;)@Retention(RetentionPolicy.RUNTIME)public @interface Mapping &#123; String value() default "/**";&#125; 12345678910111213import java.lang.annotation.Documented;import java.lang.annotation.ElementType;import java.lang.annotation.Inherited;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Documented@Inherited@Target(&#123;ElementType.METHOD,ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)public @interface ExcludeMapping &#123; String[] value();&#125; 第六步 在springMVC配置文件中配置命名空间及包扫描1234567xmlns:custom="http://www.mgl.com/schema/tools" xsi:schemaLocation="http://www.mgl.com/schema/tools http://www.mgl.com/schema/custom/interceptor-scan.xsd"&lt;mvc:annotation-driven /&gt;&lt;custom:interceptor-scan base-package="com.mgl.interceptor" base-class="org.springframework.web.servlet.handler.HandlerInterceptorAdapter" /&gt; 好了，我们只要将Interceptor放入com.mgl.interceptor包目录下，就可以自动注入了，还可以根据@Order进行拦截器的调用顺序控制]]></content>
      <categories>
        <category>经典</category>
      </categories>
      <tags>
        <tag>Interceptor</tag>
        <tag>自动扫描</tag>
        <tag>注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Filter实现响应结果打印]]></title>
    <url>%2F2018%2F06%2F10%2F2018-06-10Filter%E5%AE%9E%E7%8E%B0%E5%93%8D%E5%BA%94%E7%BB%93%E6%9E%9C%E6%89%93%E5%8D%B0%E5%92%8C%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E5%90%8D%E5%A4%A7%E5%B0%8F%E5%86%99%E4%B8%8D%E6%95%8F%E6%84%9F%2F</url>
    <content type="text"><![CDATA[在实际业务开发中，我们经常需要打印响应结果日志，方便以后问题跟踪和处理，但是我们是不能直接从response的输出流中获取结果，为了解决这个问题，我们可以在拦截器中使用HttpServletResponseWrapper实现类替换HttpServletResponse，将输出的结果保存下来，然后在日志打印的地方直接将结果拿出来打印就可以了 同样，有时候是历史原因导致接口中参数名不是按驼峰规则命名，接口移植重写过程中我们还要照顾旧渠道调用我们接口时使用的非驼峰格式的参数名，这样就导致获取参数值时的混乱问题，为了统一解决这个问题，我们也同样可以在拦截器中使用HttpServletRequestWrapper实现类替换HttpServletRequest，从而可以实现参数值获取时的参数名大小写不敏感。 以下是java代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301import java.io.BufferedWriter;import java.io.ByteArrayOutputStream;import java.io.IOException;import java.io.InterruptedIOException;import java.io.OutputStreamWriter;import java.io.PrintWriter;import java.io.Writer;import java.nio.charset.StandardCharsets;import java.util.Enumeration;import java.util.HashMap;import java.util.Map;import javax.servlet.FilterChain;import javax.servlet.ServletException;import javax.servlet.ServletOutputStream;import javax.servlet.WriteListener;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletRequestWrapper;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpServletResponseWrapper;import org.apache.commons.lang3.StringUtils;import org.springframework.web.filter.OncePerRequestFilter;public class RequestResponseFilter extends OncePerRequestFilter &#123; @Override protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException &#123; filterChain.doFilter(new RequestParameterWrapper(request), new ResponseContentWrapper(response)); &#125; private final class RequestParameterWrapper extends HttpServletRequestWrapper &#123; private Map&lt;String, String&gt; keyMap = new HashMap&lt;&gt;(); private boolean repeatKey = false; public RequestParameterWrapper(HttpServletRequest request) &#123; super(request); Enumeration&lt;String&gt; keys = request.getParameterNames(); while (keys.hasMoreElements()) &#123; String key = keys.nextElement(); String keyUpper = key.toUpperCase(); if (keyMap.containsKey(keyUpper)) &#123; this.repeatKey = true; break; &#125; else &#123; this.keyMap.put(keyUpper, key); &#125; &#125; &#125; @Override public String getParameter(String name) &#123; if (StringUtils.isEmpty(name)) &#123; return null; &#125; String realName = this.getRealName(name); return super.getParameter(realName); &#125; @Override public String[] getParameterValues(String name) &#123; if (StringUtils.isEmpty(name)) &#123; return null; &#125; String realName = this.getRealName(name); return super.getParameterValues(realName); &#125; private String getRealName(String name) &#123; if (this.repeatKey) &#123; return name; &#125; String upperKey = name.toUpperCase(); if (keyMap.containsKey(upperKey)) &#123; return keyMap.get(upperKey); &#125; return name; &#125; &#125; public final class ResponseContentWrapper extends HttpServletResponseWrapper &#123; private ResponsePrintWriter responsePrintWriter; private ResponseOutputStream responseOutputStream; private String content = null; public ResponseContentWrapper(HttpServletResponse servletResponse) &#123; super(servletResponse); this.responsePrintWriter = new ResponsePrintWriter(new ByteArrayOutputStream(), servletResponse); this.responseOutputStream = new ResponseOutputStream(servletResponse); &#125; @Override protected void finalize() throws Throwable &#123; super.finalize(); this.responsePrintWriter.close(); &#125; public String getContent() throws IOException &#123; try &#123; if (content != null) &#123; return content; &#125; this.responsePrintWriter.flush(); ByteArrayOutputStream output = this.responsePrintWriter.getOutput(); this.content = new String(output.toByteArray(), StandardCharsets.UTF_8); if (StringUtils.isEmpty(content)) &#123; this.responseOutputStream.flush(); this.content = this.responseOutputStream.getContent(); &#125; return content; &#125; catch (Exception e) &#123; return "UnsupportedEncoding"; &#125; &#125; @Override public PrintWriter getWriter() throws IOException &#123; return responsePrintWriter; &#125; @Override public ServletOutputStream getOutputStream() throws IOException &#123; return this.responseOutputStream; &#125; &#125; private final class ResponsePrintWriter extends PrintWriter &#123; private HttpServletResponse servletResponse; private ByteArrayOutputStream byteArrayOutputStream; private Writer writer; private boolean startWrite = false; public ResponsePrintWriter(ByteArrayOutputStream byteArrayOutputStream, HttpServletResponse servletResponse) &#123; super(byteArrayOutputStream); this.servletResponse = servletResponse; this.byteArrayOutputStream = byteArrayOutputStream; this.writer = new BufferedWriter(new OutputStreamWriter(byteArrayOutputStream)); &#125; public ByteArrayOutputStream getOutput() &#123; return this.byteArrayOutputStream; &#125; @Override public void write(String s) &#123; this.write(s, 0, s.length()); &#125; @Override public void write(String s, int off, int len) &#123; byte[] bytes = s.getBytes(StandardCharsets.UTF_8); this.byteArrayOutputStream.write(bytes, off, len); if (!startWrite) &#123; this.servletResponse.setContentLength(-1); this.startWrite = true; &#125; try &#123; this.servletResponse.getWriter().write(s, off, len); &#125; catch (IOException e) &#123; logger.error("write failed,", e); &#125; &#125; @Override public void write(char[] buf) &#123; this.write(buf, 0, buf.length); &#125; @Override public void write(char[] buf, int off, int len) &#123; try &#123; this.writer.write(buf, off, len); &#125; catch (InterruptedIOException x) &#123; Thread.currentThread().interrupt(); &#125; catch (IOException x) &#123; logger.error("HttpServletResponse write failed!"); &#125; if (!startWrite) &#123; this.servletResponse.setContentLength(-1); this.startWrite = true; &#125; try &#123; this.servletResponse.getWriter().write(buf, off, len); &#125; catch (IOException e) &#123; logger.error("write failed,", e); &#125; &#125; @Override public void write(int c) &#123; this.byteArrayOutputStream.write(c); if (!startWrite) &#123; this.servletResponse.setContentLength(-1); this.startWrite = true; &#125; try &#123; this.servletResponse.getWriter().write(c); &#125; catch (IOException e) &#123; logger.error("write failed,", e); &#125; &#125; &#125; private class ResponseOutputStream extends ServletOutputStream &#123; private HttpServletResponse servletResponse; private ByteArrayOutputStream byteArrayOutputStream; private boolean startWrite = false; public ResponseOutputStream(HttpServletResponse servletResponse) &#123; this.servletResponse = servletResponse; this.byteArrayOutputStream = new ByteArrayOutputStream(); &#125; @Override public void write(int b) throws IOException &#123; this.servletResponse.getOutputStream().write(b); &#125; @Override public void print(String s) throws IOException &#123; this.byteArrayOutputStream.write(s.getBytes(StandardCharsets.UTF_8)); if (!startWrite) &#123; this.servletResponse.setContentLength(-1); this.startWrite = true; &#125; try &#123; this.servletResponse.getOutputStream().print(s); &#125; catch (IOException e) &#123; logger.error("write failed,", e); &#125; &#125; @Override public void println(String s) throws IOException &#123; this.byteArrayOutputStream.write(s.getBytes(StandardCharsets.UTF_8)); if (!startWrite) &#123; this.servletResponse.setContentLength(-1); this.startWrite = true; &#125; try &#123; this.servletResponse.getOutputStream().println(s); &#125; catch (IOException e) &#123; logger.error("write failed,", e); &#125; &#125; @Override public void write(byte[] b) throws IOException &#123; this.byteArrayOutputStream.write(b, 0, b.length); if (!startWrite) &#123; this.servletResponse.setContentLength(-1); this.startWrite = true; &#125; try &#123; this.servletResponse.getOutputStream().write(b); &#125; catch (IOException e) &#123; logger.error("write failed,", e); &#125; &#125; @Override public void write(byte[] b, int off, int len) throws IOException &#123; if (!startWrite) &#123; this.servletResponse.setContentLength(-1); this.startWrite = true; &#125; if (b == null) &#123; throw new NullPointerException(); &#125; else if ((off &lt; 0) || (off &gt; b.length) || (len &lt; 0) || ((off + len) &gt; b.length) || ((off + len) &lt; 0)) &#123; throw new IndexOutOfBoundsException(); &#125; else if (len == 0) &#123; return; &#125; len = Math.min(b.length - off, len); this.byteArrayOutputStream.write(b, off, len); try &#123; this.servletResponse.getOutputStream().write(b, off, len); &#125; catch (IOException e) &#123; logger.error("write failed,", e); &#125; &#125; public String getContent() &#123; return new String(this.byteArrayOutputStream.toByteArray(), StandardCharsets.UTF_8); &#125; @Override public boolean isReady() &#123; // TODO Auto-generated method stub return false; &#125; @Override public void setWriteListener(WriteListener arg0) &#123; // TODO Auto-generated method stub &#125; &#125;&#125; web.xml配置12345678&lt;filter&gt; &lt;filter-name&gt;requestResponseFilter&lt;/filter-name&gt; &lt;filter-class&gt;com.mgl.filter.RequestResponseFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;requestResponseFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 使用方法123if (ResponseContentWrapper.class.isAssignableFrom(response.getClass())) &#123; logger.info("响应结果为：&#123;&#125;", ((ResponseContentWrapper) response).getContent());&#125;]]></content>
      <categories>
        <category>经典</category>
      </categories>
      <tags>
        <tag>Filter</tag>
        <tag>Log</tag>
        <tag>响应结果打印</tag>
        <tag>HttpServletResponseWrapper</tag>
        <tag>HttpServletRequestWrapper</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[zookeeper实现分布式锁和热备及dubbo加解锁服务]]></title>
    <url>%2F2018%2F05%2F18%2F2018-05-18zookeeper%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%2F</url>
    <content type="text"><![CDATA[使用zookeeper实现分布式锁可以完美解决Redis实现分布式锁带来的弊端 基本流程： 往zookeeper中的某个永久节点上创建一个临时节点 判断创建的临时节点是否是最小的节点 如果是最小的节点，说明当前节点拿到了锁 如果不是最小节点，监听当前节点的上一个节点，如果上一个节点被删除，触发当前节点的线程去获取锁 下面是zookeeper实现分布式锁的具体代码逻辑 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895import com.google.common.collect.Maps;import com.google.gson.Gson;import com.jzg.api.util.StringUtil;import com.jzg.api.util.ThreadLocalUtil;import com.jzg.api.util.ThreadPoolHandler;import org.apache.commons.lang3.StringUtils;import org.apache.curator.framework.CuratorFramework;import org.apache.curator.framework.CuratorFrameworkFactory;import org.apache.curator.framework.recipes.cache.TreeCache;import org.apache.curator.framework.recipes.cache.TreeCacheEvent;import org.apache.curator.framework.recipes.cache.TreeCacheListener;import org.apache.curator.retry.ExponentialBackoffRetry;import org.apache.zookeeper.CreateMode;import org.apache.zookeeper.KeeperException;import org.apache.zookeeper.data.Stat;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.util.CollectionUtils;import javax.annotation.PostConstruct;import java.nio.charset.StandardCharsets;import java.util.Collections;import java.util.List;import java.util.Map;import java.util.UUID;import java.util.concurrent.CountDownLatch;import java.util.concurrent.TimeUnit;public class ZKLock &#123; private static Logger logger = LoggerFactory.getLogger(ZKLock.class); private static final String LOCK_BASE_PATH = "/ZKLOCK"; private static final String EXECUTE_PERMISSION_BASE_PATH = "/ZKLOCK/ACTIVE/CURRENT"; private static final String EXECUTE_PERMISSION_NODE_NAME = "EPHEMERAL_NODE"; private boolean executePermission = false; private String executePermissionLockVal; private Map&lt;Integer, String&gt; currNodeNameAndIndexMap = Maps.newConcurrentMap(); private DataCacheHandler cacheHandler; private String ipPort; private int connectionTimeoutMs; private String appName = ""; private CuratorFramework client; @PostConstruct public void init() &#123; this.client = CuratorFrameworkFactory.builder().connectString(ipPort).connectionTimeoutMs(connectionTimeoutMs).retryPolicy(new ExponentialBackoffRetry(1000, 3)).build(); this.client.start(); this.executePermissionLockVal = UUID.randomUUID().toString().replaceAll("-", ""); cacheHandler = new DataCacheHandler(client); &#125; /** * 对某个key键进行尝试加锁，如果加锁失败，需要设置监听事件 * * @param lockKey * @return * @throws Exception */ public boolean tryLock(String lockKey) throws Exception &#123; try &#123; createParentNodeIfNotExists(lockKey); String currQueueNodeName = this.createCurrQueueNodeIfNotExists(lockKey); if (StringUtils.isEmpty(currQueueNodeName)) &#123; return false; &#125; return checkQueue(lockKey); &#125; catch (Exception e) &#123; String exceptionTimeTLKey = this.getExceptionTimeTLKey(lockKey); String exceptionTime = ThreadLocalUtil.getMapValue(exceptionTimeTLKey); if (StringUtils.isEmpty(exceptionTime)) &#123; ThreadLocalUtil.setMapValue(exceptionTimeTLKey, "1"); &#125; else &#123; int time = Integer.parseInt(exceptionTime); if (time &gt; 3) &#123; throw e; &#125; ThreadLocalUtil.setMapValue(exceptionTimeTLKey, new Integer(time + 1).toString()); &#125; return false; &#125; &#125; private boolean checkQueue(String lockKey) throws Exception &#123; String parentNodePath = this.getParentPath(lockKey); List&lt;String&gt; childrenNodePath = findAllChildrenQueueNodeName(parentNodePath); if (CollectionUtils.isEmpty(childrenNodePath)) &#123; throw new Exception("当前占队集合为空！"); &#125; Collections.sort(childrenNodePath); String currQueueNodeName = this.getCurrQueueNameFromThreadLocal(lockKey); int idx = searchCurrQueueNodeIndex(childrenNodePath, currQueueNodeName); if (idx &lt; 0) &#123; this.resetCurrQueueNodeName(lockKey); this.resetLastQueueNodeName(lockKey); return false; &#125; else if (idx &gt; 0) &#123; String lastNodeName = this.findLastQueueNodeName(childrenNodePath, idx); String lastNodeNameTLKey = getLastNodeNameTLKey(lockKey); putThreadLocal(lastNodeNameTLKey, lastNodeName); return false; &#125; else &#123; this.resetLastQueueNodeName(lockKey); return true; &#125; &#125; /** * 创建父节点，如果父节点不存在的话 * * @param lockKey * @return * @throws Exception */ private void createParentNodeIfNotExists(String lockKey) throws Exception &#123; try &#123; String parentPath = getParentPath(lockKey); Stat stat = this.client.checkExists().forPath(parentPath); if (stat == null) &#123; try &#123; this.client.create().creatingParentsIfNeeded().withMode(CreateMode.PERSISTENT).forPath(parentPath); &#125; catch (KeeperException.NodeExistsException e) &#123; System.out.println("父节点已经创建"); &#125; &#125; &#125; catch (Exception e) &#123; logger.error("zookeeper 连接失败或无法创建节点！", e); throw e; &#125; &#125; /** * 父节点路径的ThreadLocal的key * * @param lockKey * @return */ private String getParentNodePathTLKey(String lockKey) &#123; return lockKey + "_parent_node_path"; &#125; /** * 父节点全路径的ThreadLocal的key * * @param lockKey * @return */ private String getParentNodeFullPathTLKey(String lockKey) &#123; return lockKey + "_parent_node_full_path"; &#125; /** * 记录获取锁抛出异常的次数 * * @param lockKey * @return */ private String getExceptionTimeTLKey(String lockKey) &#123; return lockKey + "_exception_time"; &#125; /** * 获取父节点路径，最后没有/ * * @param lockKey * @return */ private String getParentPath(String lockKey) &#123; String parentNodePathTLKey = getParentNodePathTLKey(lockKey); String parentNodePath = ThreadLocalUtil.getMapValue(parentNodePathTLKey); if (!StringUtils.isEmpty(parentNodePath)) &#123; return parentNodePath; &#125; else &#123; if (lockKey.startsWith("/")) &#123; if (lockKey.endsWith("/")) &#123; parentNodePath = LOCK_BASE_PATH + lockKey.substring(0, lockKey.length() - 1); &#125; else &#123; parentNodePath = LOCK_BASE_PATH + lockKey; &#125; &#125; else &#123; if (lockKey.endsWith("/")) &#123; parentNodePath = LOCK_BASE_PATH + "/" + lockKey.substring(0, lockKey.length() - 1); &#125; else &#123; parentNodePath = LOCK_BASE_PATH + "/" + lockKey; &#125; &#125; putThreadLocal(parentNodePathTLKey, parentNodePath); return parentNodePath; &#125; &#125; /** * 获取父节点路径，最后带/ * * @param lockKey * @return */ private String getParentFullPath(String lockKey) &#123; String parentNodeFullPathTLKey = this.getParentNodeFullPathTLKey(lockKey); String parentNodeFullPath = ThreadLocalUtil.getMapValue(parentNodeFullPathTLKey); if (!StringUtils.isEmpty(parentNodeFullPath)) &#123; return parentNodeFullPath; &#125; else &#123; if (lockKey.startsWith("/")) &#123; if (lockKey.endsWith("/")) &#123; parentNodeFullPath = LOCK_BASE_PATH + lockKey; &#125; else &#123; parentNodeFullPath = LOCK_BASE_PATH + lockKey + "/"; &#125; &#125; else &#123; if (lockKey.endsWith("/")) &#123; parentNodeFullPath = LOCK_BASE_PATH + "/" + lockKey; &#125; else &#123; parentNodeFullPath = LOCK_BASE_PATH + "/" + lockKey + "/"; &#125; &#125; putThreadLocal(parentNodeFullPathTLKey, parentNodeFullPath); return parentNodeFullPath; &#125; &#125; /** * 当前节点名称的ThreadLocal的key * * @param lockKey * @return */ private String getCurrNodeNameTLKey(String lockKey) &#123; return lockKey + "_curr_node_name"; &#125; /** * 获取当前排队节点的名称，如果没有，排队去获取 * * @param lockKey * @return * @throws Exception */ private String createCurrQueueNodeIfNotExists(String lockKey) throws Exception &#123; try &#123; // 对这个路径进行加锁操作 String currNodeNameTLKey = getCurrNodeNameTLKey(lockKey); String currQueueNodeName = ThreadLocalUtil.getMapValue(currNodeNameTLKey); if (StringUtil.isNullOrEmpty(currQueueNodeName)) &#123; String fullPath = getParentFullPath(lockKey); // 排队，创建临时节点 String currQueueNodePath = this.client.create().creatingParentsIfNeeded().withMode(CreateMode.EPHEMERAL_SEQUENTIAL).forPath(fullPath, "lock".getBytes()); currQueueNodeName = currQueueNodePath.substring(fullPath.length()); ThreadLocalUtil.setMapValue(currNodeNameTLKey, currQueueNodeName); &#125; return currQueueNodeName; &#125; catch (Exception e) &#123; logger.error("创建父节点：：zookeeper连接失败！", e); throw e; &#125; &#125; /** * 从当前线程获取排队节点，如果没排队抛出异常 * * @param lockKey * @return * @throws Exception */ public String getCurrQueueNameFromThreadLocal(String lockKey) &#123; String currNodeNameTLKey = getCurrNodeNameTLKey(lockKey); String currQueueName = ThreadLocalUtil.getMapValue(currNodeNameTLKey); if (StringUtils.isEmpty(currQueueName)) &#123; throw new RuntimeException("当前线程没有排队获取锁！"); &#125; return currQueueName; &#125; /** * 获取当前排队节点的路径 * * @param lockKey * @return */ private String getCurrQueueNodePath(String lockKey) &#123; String currQueueNodeName = this.getCurrQueueNameFromThreadLocal(lockKey); String parentFullPath = this.getParentFullPath(lockKey); return parentFullPath + currQueueNodeName; &#125; /** * 上一节点名称的ThreadLocal的key * * @param lockKey * @return */ private String getLastNodeNameTLKey(String lockKey) &#123; return lockKey + "_last_node_name"; &#125; /** * 获取上一个排队节点的全路径名称 * * @param lockKey * @param lastQueueNodeName * @return */ private String getLastQueueNodePath(String lockKey, String lastQueueNodeName) &#123; return this.getParentPath(lockKey) + "/" + lastQueueNodeName; &#125; /** * 当前排队节点的上一个节点名称 * * @param children * @param idx * @return */ private String findLastQueueNodeName(List&lt;String&gt; children, int idx) &#123; return children.get(idx - 1); &#125; /** * 获取上一节点名称 * * @param lockKey * @return */ private String getLastQueueNodeName(String lockKey) &#123; String lastNodeNameTLKey = this.getLastNodeNameTLKey(lockKey); if (!StringUtils.isEmpty(lastNodeNameTLKey)) &#123; return ThreadLocalUtil.getMapValue(lastNodeNameTLKey); &#125; return null; &#125; private void clean(String lockKey, boolean lockSuccess) &#123; this.resetLastQueueNodeName(lockKey); if (!lockSuccess) &#123; this.resetParentNodeFullPath(lockKey); this.resetParentNodePath(lockKey); this.resetCurrQueueNodeName(lockKey); &#125; &#125; /** * 绑定监听事件，并没有时间限制的一直等待 * * @param lockKey */ @SuppressWarnings("resource") private void waitForLock(String lockKey) &#123; CountDownLatch cdl = new CountDownLatch(1); TreeCache cache = null; TreeCacheListener listener = null; try &#123; String lastNodeName = this.getLastQueueNodeName(lockKey); if (StringUtils.isEmpty(lastNodeName)) &#123; return; &#125; String lastQueueNodePath = this.getLastQueueNodePath(lockKey, lastNodeName); cache = new TreeCache(this.client, lastQueueNodePath); listener = new TreeCacheListener() &#123; @Override public void childEvent(CuratorFramework client, TreeCacheEvent event) throws Exception &#123; if (event.getData() != null &amp;&amp; event.getType() == TreeCacheEvent.Type.NODE_REMOVED) &#123; cdl.countDown(); &#125; &#125; &#125;; try &#123; try &#123; cache.start(); &#125; catch (Exception e) &#123; return; &#125; cache.getListenable().addListener(listener); if (this.checkQueue(lockKey)) &#123; return; &#125; cdl.await(1000, TimeUnit.MILLISECONDS); &#125; catch (Exception e) &#123; logger.info("监听排队节点失败！", e); &#125; &#125; finally &#123; try &#123; cdl.countDown(); if (cache != null &amp;&amp; listener != null) &#123; cache.getListenable().removeListener(listener); &#125; &#125; catch (Exception e) &#123; logger.warn("监听节点退出异常！", e); &#125; &#125; &#125; /** * 将当前节点从缓存中清除，从zookeeper中删除 * * @param lockKey */ private void resetCurrQueueNodeName(String lockKey) &#123; String currNodeName = this.getCurrQueueNameFromThreadLocal(lockKey); if (!StringUtils.isEmpty(currNodeName)) &#123; try &#123; this.client.delete().forPath(this.getCurrQueueNodePath(lockKey)); &#125; catch (Exception e) &#123; logger.warn("删除当前节点失败，currNodeName=&#123;&#125;", currNodeName, e); &#125; &#125; String currNodeNameTLKey = this.getCurrNodeNameTLKey(lockKey); removeFromThreadLocal(currNodeNameTLKey); &#125; private void resetLastQueueNodeName(String lockKey) &#123; String lastNodeNameTLKey = this.getLastNodeNameTLKey(lockKey); removeFromThreadLocal(lastNodeNameTLKey); &#125; private void resetParentNodePath(String lockKey) &#123; String parentNodePathTLKey = this.getParentFullPath(lockKey); removeFromThreadLocal(parentNodePathTLKey); &#125; private void resetParentNodeFullPath(String lockKey) &#123; String parentNodeFullPathTLKey = this.getParentNodeFullPathTLKey(lockKey); removeFromThreadLocal(parentNodeFullPathTLKey); &#125; private boolean removeFromThreadLocal(String currNodeNameTLKey) &#123; return ThreadLocalUtil.removeMapValue(currNodeNameTLKey); &#125; /** * 对某个key键进行加锁，一直等待，直到加锁成功 * * @param lockKey * @return * @throws Exception */ public boolean acquire(String lockKey) &#123; boolean result = false; try &#123; while (!tryLock(lockKey)) &#123; waitForLock(lockKey); &#125; result = true; &#125; catch (Exception e) &#123; logger.info("获取zk锁异常或超时！", e); result = false; &#125; finally &#123; clean(lockKey, result); &#125; return result; &#125; public boolean acquire(String lockKey, long expireSeconds) &#123; boolean result = false; long start = System.currentTimeMillis(); try &#123; while (!tryLock(lockKey)) &#123; if (expireSeconds &lt; 0 || System.currentTimeMillis() - start &gt; expireSeconds * 1000) &#123; throw new Exception("获取锁超时！"); &#125; waitForLock(lockKey); &#125; result = true; &#125; catch (Exception e) &#123; logger.info("获取zk锁异常或超时！"); result = false; &#125; finally &#123; clean(lockKey, result); &#125; return result; &#125; // 供内部dubbo接口服务使用 public String acquireExp(String lockKey, String requestId, long expiredSeconds) &#123; if (lockKey == null || "".equals(lockKey.trim()) || requestId == null || "".equals(requestId.trim())) &#123; return "FAILED"; &#125; RequestNode cachedNode; if ((cachedNode = cacheHandler.findByRequestIdLockKey(requestId, lockKey)) != null) &#123; return cachedNode.responseId; &#125; if (this.acquire(lockKey, expiredSeconds)) &#123; RequestNode node = new RequestNode(); node.locked = true; node.requestId = requestId; node.lockKey = lockKey; node.nodeName = this.getCurrQueueNameFromThreadLocal(lockKey); node.parentPath = this.getParentPath(lockKey); node.parentFullPath = this.getParentFullPath(lockKey); node.lastNodeName = this.getLastQueueNodeName(lockKey); node.responseId = UUID.randomUUID().toString().replaceAll("-", ""); removeFromThreadLocal(this.getCurrNodeNameTLKey(lockKey)); removeFromThreadLocal(this.getLastNodeNameTLKey(lockKey)); removeFromThreadLocal(this.getParentNodePathTLKey(lockKey)); removeFromThreadLocal(this.getParentNodeFullPathTLKey(lockKey)); if (!this.cacheHandler.createRequestNode(node) || !this.cacheHandler.createResponseNode(node)) &#123; // 回滚操作 unlockExp(node); return "FAILED"; &#125; doExpired(node); return node.responseId; &#125; return "FAILED"; &#125; // 对用户ID进行加锁操作示例 public String acquireUserId(Integer userId, String requestId, long expiredSeconds) &#123; return this.acquireExp("/USER_ID/" + userId, requestId, expiredSeconds); &#125; /** * 只加锁一次，如果加锁失败，立马返回失败信息 * * @param lockKey * @return */ public boolean acquireOnce(String lockKey) &#123; boolean result = false; try &#123; result = tryLock(lockKey); &#125; catch (Exception e) &#123; logger.info("获取zk锁异常或超时！", e); return false; &#125; finally &#123; clean(lockKey, result); &#125; return result; &#125; /** * 等待一段时间还没等到，就返回失败 * * @param lockKey * @param timeoutMs * @return */ public boolean acquire(String lockKey, int timeoutMs) &#123; boolean result = false; long start = System.currentTimeMillis(); try &#123; while (!tryLock(lockKey)) &#123; if (System.currentTimeMillis() - start &gt; timeoutMs) &#123; return false; &#125; waitForLock(lockKey); &#125; if (System.currentTimeMillis() - start &gt; timeoutMs) &#123; result = false; return false; &#125; result = true; &#125; catch (Exception e) &#123; logger.info("获取zk锁异常或超时！", e); return false; &#125; finally &#123; clean(lockKey, result); &#125; return result; &#125; /** * 释放掉锁，删除缓存(当前节点，上一节点，父节点缓存)，删除zookeeper中当前节点数据 * * @param lockKey */ public void unlock(String lockKey) &#123; try &#123; String currNodeName = this.getCurrQueueNameFromThreadLocal(lockKey); if (!StringUtils.isEmpty(currNodeName)) &#123; this.resetCurrQueueNodeName(lockKey); this.resetLastQueueNodeName(lockKey); this.resetParentNodeFullPath(lockKey); this.resetParentNodePath(lockKey); &#125; &#125; catch (Exception e) &#123; logger.error("释放锁失败，删除节点失败！"); &#125; &#125; // 释放锁资源 供内部dubbo接口服务使用 public void unlockExp(String guid) &#123; unlockExp(this.cacheHandler.findByResponseId(guid)); &#125; // 释放锁，或回滚操作 private void unlockExp(RequestNode node) &#123; if (node == null) &#123; return; &#125; int rslt = 0; try &#123; this.client.delete().forPath(node.parentFullPath + node.nodeName); &#125; catch (KeeperException.NoNodeException e) &#123; logger.warn("删除当前节点失败，当前节点不存在，currNodeName=&#123;&#125;", node.parentFullPath + node.nodeName); &#125; catch (Exception e) &#123; rslt |= 1; logger.warn("删除当前节点失败，currNodeName=&#123;&#125;", node.parentFullPath + node.nodeName); &#125; rslt |= this.cacheHandler.deleteRequestNode(node) ? 0 : 1; rslt |= this.cacheHandler.deleteResponseNode(node) ? 0 : 1; if(rslt &gt; 0)&#123; if (++node.time &gt; 6) &#123; return; &#125; this.doExpired(node); &#125; &#125; private static class RequestNode &#123; String requestId; String lockKey; String parentPath; String parentFullPath; String nodeName; String lastNodeName; String responseId; boolean locked; int time; public boolean compareTo(RequestNode o) &#123; if (o == null) &#123; return false; &#125; return this.requestId.equals(o.requestId) &amp;&amp; this.responseId.equals(o.responseId) &amp;&amp; this.lockKey.equals(o.lockKey) &amp;&amp; this.parentPath.equals(o.parentPath) &amp;&amp; this.parentFullPath.equals(o.parentFullPath) &amp;&amp; this.nodeName.equals(o.nodeName) &amp;&amp; ((this.lastNodeName == null &amp;&amp; o.lastNodeName == null) || this.lastNodeName.equals(o.lastNodeName)) &amp;&amp; this.time == o.time; &#125; &#125; // 锁超时预处理 private void doExpired(RequestNode node) &#123; ThreadPoolHandler.getInstance().schedule(new LockExpiredHandler(node, this), 10, TimeUnit.SECONDS); &#125; private class LockExpiredHandler implements Runnable &#123; private RequestNode node; private ZKLock zkLock; public LockExpiredHandler(RequestNode node, ZKLock zkLock) &#123; this.node = node; this.zkLock = zkLock; &#125; @Override public void run() &#123; this.zkLock.unlockExp(node.responseId); &#125; &#125; /** * 查找所有排队子节点 * * @param parentNodePath * @return * @throws Exception */ private List&lt;String&gt; findAllChildrenQueueNodeName(String parentNodePath) throws Exception &#123; try &#123; return this.client.getChildren().forPath(parentNodePath); &#125; catch (Exception e) &#123; logger.error("zookeeper连接失败，或查找不到子节点！path=&#123;&#125;", parentNodePath, e); throw e; &#125; &#125; /** * 将当前线程的当前key赋值 * * @param tlKey * @param currNodeName */ private void putThreadLocal(String tlKey, String currNodeName) &#123; ThreadLocalUtil.setMapValue(tlKey, currNodeName); &#125; /** * 查询当前节点排在第几号位置 * * @param childrenNodePath * @param currQueueNodeName * @return */ private int searchCurrQueueNodeIndex(List&lt;String&gt; childrenNodePath, String currQueueNodeName) &#123; return Collections.binarySearch(childrenNodePath, currQueueNodeName); &#125; /** * 获取运行权限 */ public boolean acquireActive() &#123; try &#123; // 如果保存的是自己已经拿到锁了，还得去校验一遍，为了解决脑列问题 if (this.executePermission) &#123; String value = getExecutePermissionValue(); if (value != null &amp;&amp; value.equals(this.executePermissionLockVal)) &#123; return true; &#125; &#125; // 如果没有拿到锁，就将当前zkLock保存的状态修改一下 this.executePermission = false; return this.createEphemeralNode(); &#125; catch (Exception e) &#123; return false; &#125; &#125; public boolean removeExecutePermission() &#123; try &#123; this.client.delete().forPath(this.getEphemeralNodePath()); return true; &#125; catch (Exception e) &#123; logger.error("模拟连接断掉失败！"); return false; &#125; &#125; private String getExecutePermissionValue() throws Exception &#123; try &#123; return new String(this.client.getData().forPath(this.getEphemeralNodePath()), "UTF-8"); &#125; catch (KeeperException.NoNodeException e) &#123; return null; &#125; catch (Exception e) &#123; logger.info("获取临时节点Value失败！", e); throw e; &#125; &#125; private Stat getExecutePermissionStat() throws Exception &#123; try &#123; return this.client.checkExists().forPath(this.getEphemeralNodePath()); &#125; catch (Exception e) &#123; logger.error("获取临时节点状态失败！"); throw e; &#125; &#125; private String getEphemeralNodePath() &#123; return EXECUTE_PERMISSION_BASE_PATH + "_" + this.appName + "/" + EXECUTE_PERMISSION_NODE_NAME; &#125; private boolean createEphemeralNode() throws Exception &#123; try &#123; Stat stat = this.getExecutePermissionStat(); if (stat == null) &#123; try &#123; this.client.create().creatingParentsIfNeeded().withMode(CreateMode.EPHEMERAL).forPath(this.getEphemeralNodePath(), this.executePermissionLockVal.getBytes("UTF-8")); stat = this.getExecutePermissionStat(); if (stat != null) &#123; this.executePermission = true; System.out.println("加锁成功:::" + this.executePermission + ",,," + this.executePermissionLockVal + ",,,"); return true; &#125; else &#123; return false; &#125; &#125; catch (KeeperException.NodeExistsException e) &#123; return false; &#125; &#125; else &#123; return false; &#125; &#125; catch (Exception e) &#123; logger.error("zookeeper 连接失败或无法创建节点！", e); throw e; &#125; &#125; private class DataCacheHandler &#123; private Gson gson = new Gson(); private CuratorFramework client; private static final String RequestBasePath = "/ZKLOCK/REQUESTID_LOCKKEY/"; private static final String ResponseBasePath = "/ZKLOCK/RESPONSEID/"; public DataCacheHandler(CuratorFramework client) &#123; this.client = client; &#125; // 根据requestId、lockKey查看有没有对应的缓存数据，如果有，表明已经加过锁，如果没有，表明还没有加过锁，那就可以去加锁了 public RequestNode findByRequestIdLockKey(String requestId, String lockKey) &#123; return this.fetchRequestNodeByPath(this.getRequestIdPath(requestId, lockKey), 0); &#125; // 加锁成功后，将requestId、lockKey当做key把RequestNode保存好，以供之后再次请求用 public boolean createRequestNode(RequestNode node) &#123; return this.saveRequestNode(this.getRequestIdPath(node.requestId, node.lockKey), node, 0); &#125; // 删除requestId对应的缓存数据 public boolean deleteRequestNode(RequestNode node) &#123; return this.removePath(this.getRequestIdPath(node.requestId, node.lockKey), 0); &#125; private String getRequestIdPath(String requestId, String lockKey) &#123; return RequestBasePath + requestId + "_" + lockKey.replaceAll("/", "_"); &#125; // 获取responseId为key的临时数据，用于之后的解锁操作 public RequestNode findByResponseId(String responseId) &#123; return this.fetchRequestNodeByPath(this.getResponsePath(responseId), 0); &#125; // 创建responseId为key的临时数据 public boolean createResponseNode(RequestNode node) &#123; return this.saveRequestNode(this.getResponsePath(node.responseId), node, 0); &#125; // 删除responseId为key的临时数据 public boolean deleteResponseNode(RequestNode node) &#123; return this.removePath(this.getResponsePath(node.responseId), 0); &#125; public String getResponsePath(String responseId) &#123; return ResponseBasePath + responseId; &#125; private RequestNode fetchRequestNodeByPath(String path, int count) &#123; try &#123; String data = new String(this.client.getData().forPath(path), StandardCharsets.UTF_8); return gson.fromJson(data, RequestNode.class); &#125; catch (KeeperException.NoNodeException e) &#123; return null; &#125; catch (Exception e) &#123; logger.error("获取RequestNode失败,path=&#123;&#125;", path); if (count &gt; 1) &#123; return null; &#125; return fetchRequestNodeByPath(path, ++count); &#125; &#125; private boolean saveRequestNode(String path, RequestNode node, int count) &#123; String nodeJson = this.gson.toJson(node); try &#123; // 创建临时数据，如果session断掉，临时数据和锁都会被释放掉 this.client.create().creatingParentsIfNeeded().withMode(CreateMode.EPHEMERAL).forPath(path, nodeJson.getBytes(StandardCharsets.UTF_8)); return true; &#125; catch (KeeperException.NodeExistsException e) &#123; // 如果添加节点的时候，这个节点已经存在，这种情况不可能发生，因为已经将LockKey加锁成功，当前的lockKey只会有一个服务器的线程加锁成功并将加锁成功的数据放入缓存 logger.error("缓存数据不应该存在！node=&#123;&#125;", nodeJson); RequestNode existNode = this.fetchRequestNodeByPath(path, 0); if (existNode != null &amp;&amp; existNode.compareTo(node)) &#123; return true; &#125; throw new RuntimeException("缓存数据不应该存在，node=" + nodeJson); &#125; catch (Exception e) &#123; logger.error("添加缓存数据失败，node=&#123;&#125;", nodeJson); if (count &gt; 1) &#123; return false; &#125; return saveRequestNode(path, node, ++count); &#125; &#125; private boolean removePath(String path, int count) &#123; try &#123; this.client.delete().forPath(path); &#125; catch (KeeperException.NoNodeException e) &#123; return true; &#125; catch (Exception e) &#123; logger.warn("删除当前节点失败，currNodePath=&#123;&#125;", path); if (count &gt; 2) &#123; return false; &#125; return this.removePath(path, ++count); &#125; return true; &#125; &#125; public String getIpPort() &#123; return ipPort; &#125; public void setIpPort(String ipPort) &#123; this.ipPort = ipPort; &#125; public int getConnectionTimeoutMs() &#123; return connectionTimeoutMs; &#125; public void setConnectionTimeoutMs(int connectionTimeoutMs) &#123; this.connectionTimeoutMs = connectionTimeoutMs; &#125; public String getAppName() &#123; return appName; &#125; public void setAppName(String appName) &#123; this.appName = appName; &#125;&#125; spring中配置12345&lt;bean id="zkLock" class="com.api.lock.ZKLock"&gt; &lt;property name="ipPort" value="$&#123;lock.zk.ipPort&#125;"/&gt; &lt;property name="connectionTimeoutMs" value="$&#123;lock.zk.timeout&#125;"/&gt; &lt;property name="appName" value="$&#123;lock.zk.appName&#125;"/&gt;&lt;/bean&gt;]]></content>
      <categories>
        <category>经典</category>
      </categories>
      <tags>
        <tag>分布式锁</tag>
        <tag>zookeeper</tag>
        <tag>curator</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis实现分布式锁]]></title>
    <url>%2F2018%2F05%2F17%2F2018-05-17redis%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%2F</url>
    <content type="text"><![CDATA[redis实现分布式锁redis分布式锁是通过setNx，getset原子性操作实现的 基本流程是： 使用setNx命令给给定的锁Key（比如要给OrderNo=1234加锁，key值就为lock_1234）设置值（System.currentTimeMillis()+UUID） 如果设置成功了，就表明加锁成功 如果设置失败了，就表明有其它线程在占用该锁，获取占用锁线程设置的值（System.currentTimeMillis()+UUID） 判断当前占用锁的进程占用锁是否超时，如果超时，使用getset抢着去赋新值，如果赋值后返回的结果是之前超时线程赋的值，则表明占用锁成功，否则占用锁失败，等待一段时间重新尝试获取锁 下面是具体的代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110import java.util.UUID;import org.apache.commons.lang3.StringUtils;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Component;/** * 分布式锁 CAS * @author menggl */@Componentpublic class RedisLock &#123; private static Logger logger = LoggerFactory.getLogger(RedisLock.class); @Autowired private RedisCache redis; private static final String CLK_PREFIX = "lock_"; private static final int HOLD_LOCK_EXPIRE_MILL_SECOND = 50 * 1000; // 持有锁有效时长为50秒，50秒之后锁自动释放 private static final int DEFAULT_TIME_OUT_MILL_SECOND = 5 * 1000; // 获取锁超时时长默认值5秒 private static final long LOCK_VALUE_EXPIRE = 60*60; // 锁值有效时长，1小时 /** * lockKey可以是当前订单号或者VIN码，对订单号或VIN码加锁 * @param lockKey * @param timeOutSeconds 获取锁超时时间，毫秒,-1:没有超时限制，谨慎使用 * @return */ public boolean tryLock(String lockKey,long timeOutMillSeconds)&#123; try &#123; ThreadLocalUtil.removeMapValue(lockKey); String redisKey = CLK_PREFIX + lockKey; long startTime = System.currentTimeMillis(); String uuid = UUID.randomUUID().toString().replaceAll("-", ""); while(true)&#123; long currentTime = System.currentTimeMillis(); String newVal = currentTime+"_"+uuid; boolean setnx = redis.setNx(redisKey, newVal); if(!setnx)&#123; // 锁被占用 String oldVal = redis.get(redisKey); if(oldVal == null)&#123; continue; &#125; String[] oldArr = oldVal.split("_",2); long expireTime = Long.parseLong(oldArr[0])+HOLD_LOCK_EXPIRE_MILL_SECOND; // 锁有效期判定 if(System.currentTimeMillis() &gt;= expireTime)&#123; String getStr = redis.getSet(redisKey, newVal); if(getStr == null || oldVal.equals(getStr))&#123; logger.debug("trylock successed, getSet, key=&#123;&#125;, newValue=&#123;&#125;, oldValue=&#123;&#125;, expireTime=&#123;&#125;, currentTime=&#123;&#125;, &#123;&#125;, interval=&#123;&#125; millseconds",redisKey,newVal,oldVal,expireTime,currentTime,currentTime-expireTime,HOLD_LOCK_EXPIRE_MILL_SECOND); ThreadLocalUtil.setMapValue(lockKey, System.currentTimeMillis()+""); this.redis.expire(redisKey, LOCK_VALUE_EXPIRE); return true; &#125; &#125; try &#123; Thread.sleep(200); &#125; catch (InterruptedException e) &#123; logger.error("Thread sleep error:",e); &#125; &#125;else&#123; // 正常获取到锁 logger.debug("trylock successed, key=&#123;&#125;, value=&#123;&#125;",redisKey,newVal); ThreadLocalUtil.setMapValue(lockKey, System.currentTimeMillis()+""); this.redis.expire(redisKey, LOCK_VALUE_EXPIRE); return true; &#125; // 获取锁时长超时判定 long costTime = System.currentTimeMillis() - startTime; if(timeOutMillSeconds != -1 &amp;&amp; costTime &gt; timeOutMillSeconds)&#123; logger.warn("获取锁超时，timeout= &#123;&#125; millseconds",costTime); return false; &#125; &#125; &#125; catch (Exception e) &#123; logger.error("trylock error, msg:",e); return false; &#125; &#125; /** * lockKey可以是当前订单号或者VIN码，对订单号或VIN码加锁 * @param lockKey * @return */ public boolean tryLock(String lockKey)&#123; return this.tryLock(lockKey,DEFAULT_TIME_OUT_MILL_SECOND); &#125; /** * 释放锁，lockKey可以是当前订单号或者VIN码 * @param lockKey * @return */ public boolean unlock(String lockKey)&#123; String millSecondsStr = ThreadLocalUtil.getMapValue(lockKey); if(!StringUtils.isBlank(millSecondsStr))&#123; try&#123; long millSeconds = Long.parseLong(millSecondsStr); if(millSeconds + HOLD_LOCK_EXPIRE_MILL_SECOND - 200 &gt; System.currentTimeMillis())&#123; String redisKey = CLK_PREFIX + lockKey; return this.redis.del(redisKey); &#125; &#125;finally&#123; ThreadLocalUtil.removeMapValue(lockKey); &#125; &#125; return true; &#125;&#125; 问题： 没有使用redis的超时机制，因为如果setNx成功，setExpire失败，那么这把锁就永远不能被别的线程拿到，所以使用服务器时间判断超时 各个服务器使用的时间不一致时，会导致这台服务器获刚获取到锁，另一台服务器就判定超时，然后就拿到了锁 如果占用锁的线程崩掉，没有释放锁，就只能一直等待，直到锁超时，没有一个监控拿到锁线程的机制 拿到锁的线程处理业务时间不确定，如果业务没处理完，锁就超时了，就会出现同时拿到锁的情况 不是公平锁，都是随机获取锁 综上所述： 只有在有界的网络延迟、有界的程序中断、有界的时钟错误范围，Redlock才能正常工作，但是这三种场景的边界又是无法确认的，所以专家不建议使用Redlock。对于正确性要求高的场景，专家推荐了Zookeeper，关于使用Zookeeper作为分布式锁后面再讨论。]]></content>
      <categories>
        <category>经典</category>
      </categories>
      <tags>
        <tag>redis</tag>
        <tag>分布式锁</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Interceptor中解决跨域问题]]></title>
    <url>%2F2018%2F05%2F07%2F2018-05-07Interceptor%E4%B8%AD%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[在项目开发过程中，我们会遇到浏览器跨域请求资源的场景，跨域的时候有时候还需要携带cookie，我们发现配置上SpringMVC自带的mvc:cors后我们自己写的业务校验拦截器Interceptor还会被调用两次，如果业务拦截器中有校验cookie中字段的逻辑也会校验失败，这样跨域问题就没有解决 导致这个问题出现的原因是使用SpringMVC自带的mvc:cors实现跨域，也是使用的Interceptor，但是这个Interceptor是在所有Interceptor都调用完成之后才调用的，这就导致业务拦截时校验失败，调用不到Cors的拦截器就返回了，导致跨域授权失败，资源请求失败 我们看一下源码：所有请求都会走DispatchServlet.doDispatch()方法12345678910// Determine handler for the current request.mappedHandler = getHandler(processedRequest);// 这里会顺序调用所有的Interceptor，直到有一个拦截器返回false或者抛出异常或者所有拦截器都调用完毕if (!mappedHandler.applyPreHandle(processedRequest, response)) &#123; return;&#125;// Actually invoke the handler.mv = ha.handle(processedRequest, response, mappedHandler.getHandler()); 解决方案：在所有的业务拦截器的前面判断是否为OPTIONS权限请求，如果是OPTIONS请求，不进行业务拦截12345678910public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; ServletServerHttpRequest serverRequest = new ServletServerHttpRequest(request); if (serverRequest != null &amp;&amp; serverRequest.getMethod() != null) &#123; if ("OPTIONS".equalsIgnoreCase(serverRequest.getMethod().name())) &#123; return true; &#125; &#125; // ...业务逻辑 return true;&#125; 简单跨域请求（1) 请求方法是以下三种方法之一： HEAD GET POST （2）HTTP的头信息不超出以下几种字段： Accept Accept-Language Content-Language Last-Event-ID Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain 凡是不满足上面要求的都是不简单跨域请求 浏览器对这两种情况，处理的方式是不一样的 简单请求只有一次http调用，消息头中携带Referer: http://localhost:8080/cross-domain1/和Origin: http://localhost:8080信息，表示跨域的请求来自http://localhost:8080。 复杂请求会有两次http调用，第一次http请求是OPTIONS请求，跨域权限请求，第二次才是真正的资源访问请求 跨域解决方案如下：第一种：使用CorsFilter 定义跨域请求过滤器CORSFilter 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import java.io.IOException;import javax.servlet.Filter;import javax.servlet.FilterChain;import javax.servlet.FilterConfig;import javax.servlet.ServletException;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;import javax.servlet.http.HttpServletResponse;public class CORSFilter implements Filter &#123; public CORSFilter() &#123; &#125; public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; HttpServletResponse httpServletResponse = (HttpServletResponse) response; // 允许哪些域名下的网页可以进行跨域请求 httpServletResponse.setHeader("Access-Control-Allow-Origin", "http://localhost:8080"); // 跨域请求时允许的请求头信息 httpServletResponse.setHeader("Access-Control-Allow-Headers", "User-Agent,Origin,Cache-Control,Content-type,Date,Server,withCredentials,AccessToken,X-Custom-Header"); // 服务端控制的是否允许跨域请求携带cookie // 若客户端想发送带cookie的跨域请求，使用withCredentials控制打开，如下所示 // js代码：var xhr = new XMLHttpRequest();xhr.withCredentials = true; // ajax代码： xhrFields:&#123;withCredentials:true,&#125; httpServletResponse.setHeader("Access-Control-Allow-Credentials", "true"); // 允许的请求类型 httpServletResponse.setHeader("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS, HEAD"); httpServletResponse.setHeader("Access-Control-Max-Age", "5"); // 该字段可选，浏览器可以拿到哪些字段信息，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma，如果想拿到其它字段，就必须在这里指定 httpServletResponse.setHeader("Access-Control-Expose-Headers", "accesstoken"); // 资源过期时间，秒 httpServletResponse.setHeader("Expires", "-1"); // 控制浏览器缓存，不缓存 httpServletResponse.setHeader("Cache-Control", "no-cache"); // http1.0使用的浏览器缓存控制 httpServletResponse.setHeader("pragma", "no-cache"); chain.doFilter(request, response); &#125; public void init(FilterConfig fConfig) throws ServletException &#123; &#125; public void destroy() &#123; &#125;&#125; 在web.xml配置上这个过滤器 12345678&lt;filter&gt; &lt;filter-name&gt;corsFilter&lt;/filter-name&gt; &lt;filter-class&gt;com.test.filter.CORSFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;corsFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 在业务校验拦截器Interceptor中将OPTIONS请求过滤 123456789101112131415161718192021222324252627public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; ServletServerHttpRequest serverRequest = new ServletServerHttpRequest(request); logger.debug(serverRequest.getMethod().name()); if (serverRequest != null &amp;&amp; serverRequest.getMethod() != null) &#123; if ("OPTIONS".equalsIgnoreCase(serverRequest.getMethod().name())) &#123; logger.debug("OPTIONS请求不进行业务拦截校验！"); return true; &#125; &#125; if ("/test/setCookies".equals(request.getServletPath())) &#123; return true; &#125; // 模拟业务使用cookie中的参数 Cookie[] cookies = request.getCookies(); String token = null; if (cookies != null &amp;&amp; cookies.length &gt; 0) &#123; for (Cookie c : cookies) &#123; if (c.getName().equals("token")) &#123; token = c.getValue(); &#125; &#125; &#125; if (token == null) &#123; throw new Exception("参数token不能为空！"); &#125; return true;&#125; 第二种：使用mvc:cors 添加springMVC的cors配置 12345678&lt;mvc:cors&gt; &lt;mvc:mapping path="/**" allowed-origins="*" allow-credentials="true" allowed-methods="GET,POST,PUT,DELETE,OPTIONS,HEAD" max-age="3600" allowed-headers="User-Agent,Origin,Cache-Control,Content-type,Date,Server,withCredentials,AccessToken,X-Custom-Header"/&gt;&lt;/mvc:cors&gt; 在业务拦截器Interceptor中将OPTIONS请求过滤 123456789101112131415161718192021222324252627public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; ServletServerHttpRequest serverRequest = new ServletServerHttpRequest(request); logger.debug(serverRequest.getMethod().name()); if (serverRequest != null &amp;&amp; serverRequest.getMethod() != null) &#123; if ("OPTIONS".equalsIgnoreCase(serverRequest.getMethod().name())) &#123; logger.debug("OPTIONS请求不进行业务拦截校验！"); return true; &#125; &#125; if ("/test/setCookies".equals(request.getServletPath())) &#123; return true; &#125; // 模拟业务使用cookie中的参数 Cookie[] cookies = request.getCookies(); String token = null; if (cookies != null &amp;&amp; cookies.length &gt; 0) &#123; for (Cookie c : cookies) &#123; if (c.getName().equals("token")) &#123; token = c.getValue(); &#125; &#125; &#125; if (token == null) &#123; throw new Exception("参数token不能为空！"); &#125; return true;&#125; 第三种：使用@CrossOrigin1234567891011@Controller@RequestMapping("/test")@CrossOrigin(origins = &#123; "http://localhost:8080" &#125;, allowCredentials = "true", maxAge = 5, allowedHeaders = &#123; "User-Agent", "Origin", "Cache-Control", "Content-type", "Date", "Server", "withCredentials", "AccessToken", "X-Custom-Header" &#125;)public class TestController &#123; @RequestMapping(name = "/crossDomain", method = &#123; RequestMethod.GET, RequestMethod.POST, RequestMethod.PUT &#125;) @ResponseBody public String testCrossDomain() &#123; return "success OK!"; &#125; 这个对于简单跨域请求是没问题的，对于非简单跨域请求权限校验失败。 测试demo创建web项目：cross-domain1(localhost:8080)和cross-domain2(localhost:8081) 我们将要从localhost:8080项目下的网页访问localhost:8081项目下的请求 cross-domain1项目创建test.html12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;html&gt;&lt;!-- 这个html是在http://localhost:8080项目下 --&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;script src="static/js/jquery-1.8.1.min.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;input type="button" id="testBtn1" value="简单跨域"/&gt;&lt;input type="button" id="testBtn2" value="非简单跨域"/&gt;&lt;script type="text/javascript"&gt;$(document).ready(function()&#123; $("#testBtn2").click(function()&#123; $.ajax(&#123; url:'http://localhost:8081/cross-domain2/test/crossDomain', type: "GET",// 请求方式 async: false,// 默认为true，异步方式请求 contentType: 'application/x-www-form-urlencoded', // 内容编码格式，默认是application/x-www-form-urlencoded crossDomain: true, cache:false, data: &#123;token:"abc"&#125;, dataType: 'json',// 预期服务器返回的数据类型 beforeSend:function(XMLHttpReqeust)&#123; XMLHttpReqeust.withCredentials = true;// 可以附带cookie信息,同时服务端配置权限的时Access-Control-Allow-Origin就不能设置为*，必须设置指定的域了 XMLHttpReqeust.setRequestHeader("X-Custom-Header","session=xxxxyyyyzzzz");// 新增消息头 &#125;, complete:function(XMLHttpRequest, textStatus)&#123; console.log('complete'); &#125;, success:function(data, textStatus)&#123; console.log(data); &#125;, error:function(XMLHttpRequest, textStatus, errorThrown)&#123; console.log(errorThrown); &#125;, &#125;) &#125;); $("#testBtn1").click(function()&#123; $.ajax(&#123; url:'http://localhost:8081/cross-domain2/test/crossDomain', type: "GET",// 请求方式 async: false,// 默认为true，异步方式请求 contentType: 'application/x-www-form-urlencoded', // 内容编码格式，默认是application/x-www-form-urlencoded crossDomain: true, cache:false, data: &#123;token:"abc"&#125;, dataType: 'json',// 预期服务器返回的数据类型 complete:function(XMLHttpRequest, textStatus)&#123; console.log('complete'); &#125;, success:function(data, textStatus)&#123; console.log(data); &#125;, error:function(XMLHttpRequest, textStatus, errorThrown)&#123; console.log(errorThrown); &#125;, &#125;) &#125;);&#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; cross-domain2项目，创建Controller123456789101112131415161718192021222324252627import javax.servlet.http.Cookie;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;@Controller@RequestMapping("/test")public class TestController &#123; @RequestMapping("/crossDomain") @ResponseBody public String testCrossDomain() &#123; return "success OK!"; &#125; @RequestMapping("/setCookies") @ResponseBody public String setCookies(HttpServletRequest request, HttpServletResponse response) &#123; Cookie token = new Cookie("token", "123456"); token.setPath("/"); token.setMaxAge(86400); response.addCookie(token); return "success OK!"; &#125;&#125;]]></content>
      <categories>
        <category>经典</category>
      </categories>
      <tags>
        <tag>Cors</tag>
        <tag>CrossOrigin</tag>
        <tag>简单跨域</tag>
        <tag>cookie</tag>
        <tag>ajax跨域</tag>
        <tag>spring跨域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA虚拟机之运行时数据区]]></title>
    <url>%2F2018%2F03%2F20%2F2018-03-20JAVA%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%2F</url>
    <content type="text"><![CDATA[JAVA运行时数据区域(runtime data area)java运行时数据区可以分为6个区域 Java堆 Java虚拟机栈 本地方法栈 方法区 运行时常量池 程序计数器 线程私有的有： 程序计数器 本地方法栈 java虚拟机栈 线程共有的有： java堆 方法区 运行时常量池 PC程序计数器可以理解为一块较小的内存空间，可以看做是当前线程执行字节码的行号计数器，一个线程分配一小块，以便记录当前线程执行的上线文环境，多线程切换时将上线文环境数据保存和加载。如果线程执行到本地方法，则PC程序计数器不会记录本地方法的上下文（没有字节码可以记录啊）。 Java虚拟机栈每个java线程都会拥有一块Java虚拟机栈的内存空间，Java虚拟机栈记录的是每个JAVA方法执行时候的内存模型，每调用一个JAVA方法的时候都会在Java虚拟机栈里面创建一个栈帧每个栈帧都会包含下面几个部分： 局部变量表 操作数栈 动态链接 方法返回地址 下面我们解释一下栈帧中各个部分都是干什么用的 局部变量表 作用：保存方法中的参数、局部变量等 如果这个栈帧是实例的方法栈帧，这个局部变量表第0个Slot肯定就是this（当前的实例），然后方法中的局部变量从第1个Slot开始 局部变量表以变量槽Slot为基本单位，在32位虚拟机中一个变量槽可以保存一个32位以内的数据类型（boolean、byte、char、short、int、float、reference和returnAddress八种），对于64位的数据用连续的两个变量槽来记录 如果方法中的某个变量的作用域结束了，那么这个变量对应的slot内存就可以被其它变量覆盖重用了 returnAddress类型是为字节码指令：jsr、jsr_w、ret服务的，它指向了一条字节码指令的地址（返回上一个调用该方法的字节码地址？） 引用类型reference没有明确规定它的长度 在java程序被编译成class文件时，就在方法的Code属性的max_locals数据项中确定该方法需要分配的局部变量表的内存大小 操作数栈 就像汇编一样，jvm也有指令集，java指令集是由一个字节表示的，也就是说指令集不超过256个，现在的java指令集也就200多条 指令运行时需要读取数据，处理完成后需要保存数据，这个操作数栈就是用来保存这些指令执行中需要的参数数据和结果数据的 操作数分两种，一种直接嵌入到指令中，可以叫做是嵌入操作数；还有一种是会压入操作数栈，这种可以叫做栈中操作数 嵌入操作数在编译期就已经确定好了，比如putstatic指令，将数据赋值给一个静态变量，该静态变量就是一个嵌入式操作数，它会紧跟指令，用两个字节表示，这个操作数是一个索引值，索引值指向的是运行时常量池中该静态字段对应的符号引用，由于符号引用中包含了这个静态变量的基本信息，如所属类、简单名称、描述符，这样指令就知道要给哪个类的哪个字段赋值了 栈中操作数是在运行期动态确定的数据，比如一个指令需要两个参数，需要先把两个参数放入操作数栈中，使用后出栈，将运行结果再入栈 动态链接 静态链接是在类加载的时候或者第一次使用的时候就将符号引用确定下来直接引用的过程 动态链接是在代码执行的时候才会确定符号引用对应的直接引用地址的过程 方法返回地址这个应该就保存在局部变量表中吧 本地方法栈与java虚拟机栈类似，为Java使用到的本地方法提供服务用的。 当java线程调用了一个本地方法时，它就会进入一个全新的不受java虚拟机限制的世界，本地方法还可以反过来通过本地方法接口来访问虚拟机的运行时数据区 如果某个虚拟机实现的本地方法接口是使用C连接模型的话，那么它的本地方法栈就是C栈 下面是定义了一个java的Native Method，类似于定义了一个接口123456public class IHaveNatives&#123; native public void Native1( int x ) ; native static public long Native2() ; native synchronized private float Native3( Object o ) ; native void Native4( int[] ary ) throws Exception ;&#125; Java堆 java堆是被所有线程共享的一块内存区域 所有的对象和数组的内存分配都在堆上面 为了垃圾收集方便，java堆又可以分为新生代、老年代和永久代（也叫方法区，jdk1.8中没有永久代，用metaspace实现）三块区域 方法区 保存虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码Class等数据 jdk6时，字符串常量是保存在方法区中的，jdk7开始，已将其移到堆中了 jdk8的方法区被元数据区替代（MetaSpace） 注意：这里的类变量是类的静态变量 类型的常量池：这里保存的是该class用到的其它常量的有序集合，包括字面量（直接常量）和符号引用（对象引用，非字面量），这个在动态链接中起核心作用（将符号引用解释为直接引用） 方法信息：方法信息包含该类中的所有方法，每个方法包含下面的信息：方法修饰符、方法返回类型、方法名、方法参数个数/类型/顺序等、方法的字节码、操作数栈和该方法在栈帧中的局部变量区大小、异常表 方法表：为了提高访问效率，JVM为每个加载的非虚拟类的类型都添加一个方法表，方法表是一组该类及该类父类方法的直接引用。jvm可以通过方法表快速激活实例方法。 常量池JAVA字面量（JAVA直接量）指的是int，long、double的直接量，比如123,”中国”,’c’,123.01，等具体的数值 符号引用符号引用是一个字符串，我们在代码里引用一个非字面量的东西，不管是变量还是常量，它都只是由一个符号串定义的符号，这个符号串在常量池中，类加载的时候，第一次加载到这个符号时，就会将这个符号引用（字符串）解析成直接引用（指针） 直接引用 指向目标的指针，指向对象、类变量、类方法的指针 相对偏移量，指向实例的变量、方法的指针 一个可以间接定位到对象的句柄 class文件中的常量池查看class文件中的常量池信息， 使用命令 1javap -verbose Test.class 使用Notepad++以16进制打开class文件 我们先看看常量池在class文件中的位置 常量池的数据结构是怎么组成的 常量池的数据结构很简单，前面有两个字节表示常量池计数器（constant_pool_count），它记录了常量池中常量项的个数，如果它的数值为10，则后面就会紧跟着9个常量项（cp_info） 每个常量项的数据结构是什么下面是不同类型的常量项的tag值常量项可以分成两种类型 下面是int和float常量项的数据结构 比如在class中定义了两个变量，并且赋值12public static int a = 32768;// [-32768,32767]的数据都不放入常量池中public static float b = 11.2; 在常量池中的数据结构如下 我们使用javap -v Test.class来看看常量池中保存的数据 下面是long和double的常量项结构 下面是String的常量项结构CONSTANT_String_info常量项的值为#21指向CONSTANT_Utf8_info常量项里的值 方法区中的运行时常量池方法区中的常量池是动态的，可以随时增加或被垃圾回收 运用比较多的就是String类的intern()方法 测试代码1234567891011public static void main(String[] args) &#123; String s1 = new String("1"); s1.intern(); String s2 = "1"; System.out.println(s1 == s2); String s3 = new String("1") + new String("1"); s3.intern(); String s4 = "11"; System.out.println(s3 == s4);&#125; 上面的代码在jdk6中运行结果是12falsefalse 在jdk7中运行的结果是12falsetrue jdk6中的常量池是放在永久区中的（Perm区），永久区和堆区是完全分开的，也就是说堆中对象地址永远不可能与Perm区中的对象地址相等 jdk7中的常量池已经将Perm区移动到堆中了，当调用intern()的时候会做一个操作：常量池中创建一个”11”对象，该对象保存的是s3对象的地址，所以之后使用”11”常量池赋值的时候就是赋的s3对象的引用地址 下面是jdk8中的常量池12345678910111213141516171819202122232425262728public static void main(String[] args) &#123; // s1在常量池中 String s1 = "abcd"; // s2在堆中 String s2 = new String("abcd"); System.out.println(s1 == s2);// 这里肯定是false // s3到常量池中找s2对应的字符串的常量对应的地址 String s3 = s2.intern(); System.out.println(s1 == s3);// s3找到的是s1常量池的地址,这里是true System.out.println(s2 == s3);// s2是堆中的地址，这里的s3是常量池中的地址s1，肯定是false // 这里的两个1都在常量池中，"11"在常量池中是不存在的 String s4 = new String("1") + new String("1"); // 在常量池中新增加一个"11"的对象，该对象保存的是s4的引用地址，以后所有使用"11"赋值的字符串变量都使用的是s4的引用地址 s4.intern(); String s5 = "11"; String s6 = "11"; System.out.println(s5 == s4); System.out.println(s6 == s4); // 这里会创建两个对象，一个在常量池中的"9"(类加载后就存在?)，另一个是在堆中创建的s7对象 String s7 = new String("9"); String s8 = s7.intern();// 这里返回的是常量池中的"9"保存的地址（在类加载完后就存在了?） String s9 = "9";// 这里使用的是常量池中的"9"保存的地址 System.out.println(s7 == s9);// 一个在堆中，一个在常量池中，false System.out.println(s8 == s9);// 这两个都是常量池中"9"保存的引用地址，true&#125; 如果在代码中就存在的字面量，也就是在class文件中的常量池中的常量，在类加载后就会保存在运行时常量池中，动态创建的字符串,比如String new_ss = new String(“1”)+new String(“1”);”11”不会在常量池中保存，只能调用new_ss.intern()将”11”放入常量池，这时候常量池中”11”对象就保存的是new_ss堆中的引用地址了，以后任何String s1、2、3..=”11”;中的引用地址都是new_ss的堆中地址 配置参数-Xms // 虚拟机初始堆内存大小-Xmx // 虚拟机最大堆内存大小-Xmn // 虚拟机年轻代堆内存大小（1.4及之后版本） -Xss // 设置JVM栈的大小 -Xmn // 年轻代的内存大小 查看虚拟机加载、卸载的class数量、空间及耗费的时间1jstat -class [进程号] Loaded 加载class的数量 Bytes 所占用空间大小 Unloaded 未加载class数量 Bytes 未加载占用空间大小 Time 加载使用时间 查看JIT编译过的方法（编译字节码成机器码）数量及耗时时间1jstat -compiler [进程号] Compiled 编译数量 Failed 编译失败数量 Invalid 无效数量 Time 编译耗时 FailedType 失败类型 FailedMethod 编译失败的最后一个方法名称 查看虚拟机内存统计1jstat -gccapacity [进程号] NGCMN 新生代最小容量 NGCMX 新生代最大容量 NGC 当前新生代所占容量 EC eden区容量大小 S0C 第一个幸存区容量大小 S1C 第二个幸存区容量大小 OGCMN 老年代最小容量大小 OGCMX 老年代最大容量大小 OGC 当前老年代大小 OC 当前老年代大小 MCMN MetaSpace最小容量大小 MCMX MetaSpace最大容量大小 MC 当前MetaSpace容量大小 CCSMN 当前压缩类空间大小 CCSMX 当前压缩类空间最大容量 CCSC 当前压缩类使用空间大小 YGC 年轻代GC次数 FGC 老年代GC次数 查看虚拟机垃圾回收统计1jstat -gc [进程号] [间隔时间/毫秒] EC 年轻代Eden区的容量 EU 年轻代Eden区使用大小 S0C 年轻代第一个survivor区的容量 S0U 年轻代第一个Survivor区的使用大小 S1C 年轻代第二个Survivor区的容量 S1U 年轻代第二个Survivor区的使用大小 OC 老年代的容量 OU 老年代的使用大小 PC 持久代的容量 1.8之后就是MC PU 持久代的使用大小 1.8之后就是MU CCSC 压缩类空间容量 CCSU 压缩类空间使用大小 YGC 从应用程序启动以来年轻代GC的次数 YGCT 从应用城区启动以来年轻代GC所用时间 FGC 从应用程序启动以来FullGC的次数 FGCT 从应用程序启动以来FullGC使用时间 GCT 从应用程序启动以来GC使用的事件 新生代的内存统计1jstat -gcnewcapacity [进程号] NGCMN 新生代最小容量 NGCMX 新生代最大容量 NGC 当前新生代容量 EC 当前eden区容量大小 ECMX 当前eden区最大容量大小 S0C 第一个幸存区容量大小 S0CMX 第一个幸存区最大容量大小 S1C 第二个幸存区容量大小 S1CMX 第二个幸存区最大容量大小 YGC 年轻代垃圾回收次数 FGC 老年代垃圾回收次数 新生代垃圾回收统计1jstat -gcnew [进程号] EC eden区的容量 EU eden区使用大小 S0C 第一个幸存区的容量 S0U 第一个幸存区使用大小 S1C 第二个幸存区容量 S1U 第二个幸存区使用大小 TT 对象在新生代存活的次数 MTT 对象在新生代存活的最大次数 DSS 期望的幸存区大小 YGC 年轻代GC次数 YGCT 年轻代GC消耗时间 老年代内存统计1jstat -gcoldcapacity [进程号] OGCMN 老年代最小容量大小 OGCMX 老年代最大容量大小 OGC 当前老年代容量大小 OC 老年代容量大小 YGC FGC FGCT GCT 老年代垃圾回收统计1jstat -gcold [进程号] MC 方法区大小 MU 方法区使用大小 OC 老年代大小 OU 老年代使用大小 CCSC 压缩类空间大小 CCSU 压缩类空间使用大小 YGC FGC FGCT GCT 元数据空间内存统计 MCMN 元数据区最小空间大小 MCMX 元数据区最大空间大小 MC 当前元数据区空间大小 CCSMN CCSMX CCSC YGC FGC FGCT GCT 查看JVM内存使用百分比统计1jstat -gcutil [进程号] E eden区使用比例 S0 第一个幸存区使用比例 S1 第二个幸存区使用比例 O 老年代使用比例 M 元数据区使用比例 CCS 压缩区使用比例 YGC FGC FGCT GCT 查看JVM编译方法统计1jstat -printcompilation [进程号] Compiled 最近编译的方法数量 Size 最近编译方法的字节码数量 Type 最近编译方法的编译类型 Method 方法名标识 导出堆内存状态1jmap -dump:format=b,file=[文件名] [进程号] 分析工具:Memory Analyzer http://www.eclipse.org/mat/downloads.php // 查看对象及数量1jmap -histo [进程号] 参考：https://blog.csdn.net/wangtaomtk/article/details/52267548]]></content>
      <categories>
        <category>经典</category>
      </categories>
      <tags>
        <tag>虚拟机</tag>
        <tag>性能调优</tag>
        <tag>JVM参数</tag>
        <tag>垃圾回收</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA虚拟机之类加载器]]></title>
    <url>%2F2018%2F03%2F16%2F2018-03-16JAVA%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B9%8B%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%2F</url>
    <content type="text"><![CDATA[java虚拟机组成： 类加载器：加载类用的 执行引擎：执行java代码用的 运行时数据区：相当于操作系统内存，保存虚拟机运行时的缓存数据用的，是一块需要优化的部分 类加载器将java的.class文件按照规范加载到运行时数据区的方法区中，以供执行引擎解释执行 每个类加载器将class文件加载完之后，都会将全限定名(包名+类名)保存起来，也就是说每一个类加载器只能加载一份全限定名的class文件不同的类加载器可以加载相同的全限定名文件 java类加载器是分层级的，最顶级的类加载器是BootstrapClassLoader，其次的类加载器是ExtClassLoader，最后才是AppClassLoader结构如下所示：12345--BootstrapClassLoader 加载$JAVA_HOME$/lib/rt.jar下的类----ExtClassLoader 加载$JAVA_HOME$/lib/ext.jar下的类------AppClassLoader--------URLClassLoader spring中的类加载器----------WebappClassLoader 在tomcat中部署的每个项目都会创建一个类加载器，以保证加载的相同命名空间（不同项目、不同实现）的类加载后不同，以实现隔离项目冲突的目的 各个类加载器之间是组合的关系，不是继承的关系 双亲委派模型当一个classLoader想加载一个class文件的时候，首先从当前ClassLoader查找有没有加载过这个class，如果没有加载过就去父加载器里查有没有加载过这个class，最后直到BootstrapClassLoader顶级加载器也没有加载过这个class，才会从顶级加载器开始尝试加载这个class，然后是子加载器，最后直到当前ClassLoader都加载class失败，这个类才是加载失败! 下面是ClassLoader.loadClass的代码实现1234567891011121314151617181920212223242526272829303132333435363738protected Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException&#123; // 加载一个类的时候需要加锁，防止并发加载同一个类时出现冲突 synchronized (getClassLoadingLock(name)) &#123; // 看看这个类是否已经被当前类加载器加载过 Class&lt;?&gt; c = findLoadedClass(name); // 如果没有被加载过会返回null if (c == null) &#123; long t0 = System.nanoTime(); try &#123; // 找到当前类加载器的父类加载器加载这个命名空间下的class if (parent != null) &#123; c = parent.loadClass(name, false); &#125; else &#123;// 如果父加载器是null，则说明当前委托的类加载器已经到顶了，到BootstrapClassLoader了 c = findBootstrapClassOrNull(name); &#125; &#125; catch (ClassNotFoundException e) &#123; // ClassNotFoundException thrown if class not found // from the non-null parent class loader &#125; // 如果父加载器没有加载过这个class，并且也不能加载这个class，则只能当前类加载器尝试去加载这个类了 if (c == null) &#123; // If still not found, then invoke findClass in order // to find the class. long t1 = System.nanoTime(); c = findClass(name); // this is the defining class loader; record the stats sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0); sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1); sun.misc.PerfCounter.getFindClasses().increment(); &#125; &#125; if (resolve) &#123; resolveClass(c); &#125; return c; &#125;&#125; 测试类加载器加载顺序No1.创建下面的类，并将编译好的class文件及命名空间文件夹放到D:\temp目录下面12345public class HelloLoader &#123; public void print() &#123; System.out.println("I am in BootstrapClassLoader!"); &#125;&#125; 然后修改本地HelloLoader类中的代码为：12345public class HelloLoader &#123; public void print() &#123; System.out.println("I am in AppClassLoader!"); &#125;&#125; 测试类定义：123456public class FindClassOrder &#123; public static void main(String[] args) &#123; HelloLoader helloLoader = new HelloLoader(); helloLoader.print(); &#125;&#125; 正常情况下会输出：I am in AppClassLoader! //ClassLoader加载的是本地HelloLoader定义的类 添加虚拟机运行参数：-Xbootclasspath/a:D:\temp（添加BootstrapClassLoader加载类路径的范围D:\temp） 再次运行时输出变成了：I am in BootstrapClassLoader! //ClassLoader加载的是D:\temp目录下定义的类 No2.即使配置了运行参数：-Xbootclasspath/a:D:\temp，如果AppClassLoader强行加载某个类，创建对象的时候也不会用到父加载器加载到的同命名空间下的类1234567891011121314151617181920212223242526272829303132import java.io.File;import java.io.FileInputStream;import java.lang.reflect.Method;import org.apache.commons.io.IOUtils;public class FindClassOrder &#123; public static void main(String[] args) throws Exception &#123; // 使用appClassLoader强行加载HelloLoader这个class ClassLoader classLoader = FindClassOrder.class.getClassLoader(); byte[] bHelloLoader = loadClassBytes("D:\\temp\\com\\test\\HelloLoader.class"); Method defineClassMethod = ClassLoader.class.getDeclaredMethod("defineClass", byte[].class,int.class,int.class); defineClassMethod.setAccessible(true); defineClassMethod.invoke(classLoader, new Object[]&#123;bHelloLoader,0,bHelloLoader.length&#125;); defineClassMethod.setAccessible(false); // 当前AppClassLoader强行加载了HelloLoader这个类，就不会再使用父加载器加载的这个类了 HelloLoader helloLoader = new HelloLoader(); helloLoader.print(); &#125; public static byte[] loadClassBytes(String filePath) throws Exception &#123; return IOUtils.toByteArray(new FileInputStream(new File(filePath))); &#125; /* &lt;!-- https://mvnrepository.com/artifact/commons-io/commons-io --&gt; IOUtils使用到的jar包 &lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.6&lt;/version&gt; &lt;/dependency&gt; */&#125; 双亲委托模型的弊端：父类加载器无法访问子类加载器的对象。比如父类加载器定义一个接口，同时绑定一个工厂方法，由于接口实现类不在父加载器中，所以无法访问和创建实例 No3.父加载器加载的类，不能访问加载子加载器加载的类1.编译下面java，将class文件放入D:\temp目录下面1234567public class HelloLoader &#123; public void print() &#123; System.out.println("I am in BootstrapClassLoader!"); System.out.println(Thread.currentThread().getContextClassLoader()); new HelloChildLoader().print(); &#125;&#125; 2.本地java1234567public class HelloLoader &#123; public void print() &#123; System.out.println("I am in AppClassLoader!"); System.out.println(Thread.currentThread().getContextClassLoader()); new HelloChildLoader().print(); &#125;&#125; 12345public class HelloChildLoader &#123; public void print() &#123; System.out.println("I am HelloChildLoader!"); &#125;&#125; 123456public class FindClassOrder &#123; public static void main(String[] args) &#123; HelloLoader helloLoader = new HelloLoader(); helloLoader.print(); &#125;&#125; 上面的main方法运行之后输出结果：12345I am in BootstrapClassLoader! sun.misc.Launcher$AppClassLoader@c387f44 &lt;br&gt;Exception in thread "main" java.lang.NoClassDefFoundError: com/test/HelloChildLoader at com.test.HelloLoader.print(HelloLoader.java:7)at com.test.FindClassOrder.main(FindClassOrder.java:6) 修改main方法：1234567891011121314151617181920212223import java.io.File;import java.io.FileInputStream;import java.lang.reflect.Method;import org.apache.commons.io.IOUtils;public class FindClassOrder &#123; public static void main(String[] args) throws Exception &#123; // 使用appClassLoader强行加载HelloLoader这个class ClassLoader classLoader = FindClassOrder.class.getClassLoader(); byte[] bHelloLoader = loadClassBytes("D:\\tmp\\com\\test\\HelloLoader.class"); Method defineClassMethod = ClassLoader.class.getDeclaredMethod("defineClass", byte[].class,int.class,int.class); defineClassMethod.setAccessible(true); defineClassMethod.invoke(classLoader, new Object[]&#123;bHelloLoader,0,bHelloLoader.length&#125;); defineClassMethod.setAccessible(false); // 当前AppClassLoader强行加载了HelloLoader这个类，就不会再使用父加载器加载的这个类了 HelloLoader helloLoader = new HelloLoader(); helloLoader.print(); &#125; public static byte[] loadClassBytes(String filePath) throws Exception &#123; return IOUtils.toByteArray(new FileInputStream(new File(filePath))); &#125;&#125; 运行上面代码，结果如下：123I am in BootstrapClassLoader!sun.misc.Launcher$AppClassLoader@c387f44I am HelloChildLoader! 以上结果表明： 父类加载器加载的class不能直接创建子类加载器加载的类，因为父类加载器没有访问子类加载器加载的类的权限 解决方法： 父类加载器使用Thread.currentThread().getContextClassLoader()可以获取到子类加载器ClassLoader，进而可以创建子类加载器加载的对象 以下是测试用例：创建一个待被应用类加载器加载的类HelloChildLoader12345public class HelloChildLoader &#123; public void print() &#123; System.out.println("this is HelloChildLoader!"); &#125;&#125; 将下面编译后的class拷贝到D:\temp目录下123456public class HelloLoader &#123; public void print() throws Exception &#123; System.out.println("I am in BootstrapClassLoader!"); new HelloChildLoader().print(); &#125;&#125; 本地HelloLoader实现如下123456public class HelloLoader &#123; public void print() throws Exception &#123; System.out.println("I am in AppClassLoader!"); new HelloChildLoader().print(); &#125;&#125; 测试类代码如下：123456public class FindClassOrder &#123; public static void main(String[] args) throws Exception &#123; HelloLoader helloLoader = new HelloLoader(); helloLoader.print(); &#125;&#125; 配置虚拟机运行时参数：-Xbootclasspath/a:D:\temp运行后结果如下：1234I am in BootstrapClassLoader!Exception in thread &quot;main&quot; java.lang.NoClassDefFoundError: com/test/classloader/HelloChildLoader at com.test.classloader.HelloLoader.print(HelloLoader.java:6) at com.test.classloader.FindClassOrder.main(FindClassOrder.java:6) 以上运行结果表明，启动类加载器不能直接加载和创建应用类加载器的类对象 修改D:\temp目录下的类实现：1234567891011public class HelloLoader &#123; public void print() throws Exception &#123; System.out.println("I am in BootstrapClassLoader!"); ClassLoader classLoader = Thread.currentThread().getContextClassLoader(); Class&lt;?&gt; helloChildLoaderClazz = Class.forName("com.test.classloader.HelloChildLoader", false, classLoader); // 这里如果启动类加载器定义了HelloChildLoader的接口，就直接用接口接收就可以了，不用反射调用了 Object helloChildLoader = helloChildLoaderClazz.newInstance(); Method printMethod = helloChildLoaderClazz.getDeclaredMethod("print",new Class[]&#123;&#125;); printMethod.invoke(helloChildLoader, new Object[]&#123;&#125;); &#125;&#125; 执行main方法运行结果如下：12I am in BootstrapClassLoader!this is HelloChildLoader! 上面运行结果表明： 启动类加载器加载的类中，我们可以通过应用类加载器(通过Thread.currentThread().getContextClassLoader()获取)和要加载应用类的全限定名，我们就可以得到应用类加载器的实例对象 热部署自定义一个ClassLoader，用于实现热部署12345678910111213141516171819202122232425262728public class MyClassLoader extends ClassLoader &#123; private String fileName; public MyClassLoader(String fileName) &#123; this.fileName = fileName; &#125; @Override protected Class&lt;?&gt; findClass(String className) throws ClassNotFoundException &#123; Class&lt;?&gt; clazz = this.findLoadedClass(className); // 如果当前类被加载过，就不会重复去加载 if (clazz == null) &#123; try &#123; String classFile = getClassFile(className); byte[] bytes = IOUtils.toByteArray(new FileInputStream(new File(classFile))); return super.defineClass(className, bytes, 0, bytes.length); &#125; catch (FileNotFoundException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; return clazz; &#125; private String getClassFile(String classFile) &#123; return this.fileName + "/" + classFile.replaceAll("[.]", "/") + ".class"; &#125;&#125; 定义一个需要热部署的类12345public class DemoA &#123; public void hot()&#123; System.out.println("OldDemoA is Running!"); &#125;&#125; 测试类代码123456789101112131415161718192021public class DoopRun &#123; public static void main(String[] args) &#123; while(true)&#123; try &#123; // 每次循环都重新创建MyClassLoader保证没有加载过DemoA这个类 MyClassLoader loader = new MyClassLoader("D:\\temp"); Class&lt;?&gt; clazz = loader.loadClass("com.test.classloader.DemoA"); Object demoA = clazz.newInstance(); Method m = demoA.getClass().getMethod("hot", new Class[]&#123;&#125;); m.invoke(demoA, new Object[]&#123;&#125;); &#125; catch (Exception e) &#123; System.out.println("not find!"); &#125; try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 将DemoA.class文件放入D:\temp目录下面，并保证当前main启动环境下没有这个类定义启动main，每隔一段时间输出打印”OldDemoA is Running!”，结果如下：123OldDemoA is Running!OldDemoA is Running!OldDemoA is Running! 修改D:\temp目录下的DemoA类定义为下面代码：12345public class DemoA &#123; public void hot()&#123; System.out.println("NewDemoA is Running!"); &#125;&#125; 然后覆盖到D:\temp目录下面，输出打印变成如下：1234OldDemoA is Running!NewDemoA is Running!NewDemoA is Running!NewDemoA is Running!]]></content>
      <categories>
        <category>经典</category>
      </categories>
      <tags>
        <tag>虚拟机</tag>
        <tag>类加载器</tag>
        <tag>classloader</tag>
        <tag>双亲委派模型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git命令使用大全]]></title>
    <url>%2F2018%2F02%2F23%2F2018-02-23Git%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%E5%A4%A7%E5%85%A8%2F</url>
    <content type="text"><![CDATA[git安装1.下载git客户端，并安装2.生成公钥，私钥，一直回车就可以打开git bash窗口，输入命令cd ~/.ssh 查看当前系统有没有rsa公钥私钥，如果有的话备份一下ssh-keygen -t rsa -C “menggl@jingzhengu.com“3.配置gitgit config –global user.name “用户名”git config –global user.email “邮箱账号”4.将公钥文件中的内容放到git hub上去测试是否成功：ssh git@git.jingzhengu.com 将本地项目上传到远程git仓库cd existing_foldergit initgit remote add origin http://git.jingzhengu.com/EvaluatePlatform/EvaluatePlatformAPI.git //git平台地址git add .git commitgit push -u origin master 清理本地已经不存在的远程分支git remote prune origin 从远程复制版本库到本地git initgit clone “git@git.okcoin.com:huzhu/huzhu.git”git clone “git版本库地址” “本地文件夹目录”git clone -o “非origin主机名” “git地址” #查看分支git branch -r #查看远程分支git branch -a #查看所有分支 #设置本地分支和远程分支的关联关系git branch –set-upstream-to=origin/ master2 #删除本地分支git branch -D [本地分支名] #删除远程分支git push [远程主机名] –delete [远程分支名] #切换本地分支git checkout [本地分支名] #从master分出一个新的分支git checkout -b [新本地分支名] [远程主机名]/[远程分支名] #设置本地分支与远程主机分支的追踪关系git branch –set-upstream [本地分支名] [远程主机名]/[远程分支名] #查看追踪关系git status 从远程主机更新到本地分支git pull [远程主机名] [远程分支名]:[本地分支名] #推送到远程主机git push [远程主机名] [本地分支名]:[远程分支名] #普通提交更新步骤如下： #提交更新git pull [远程主机名] [远程分支名]:[本地分支名] #查看分支冲突git status #解决完冲突添加到文件暂存git add 文件1 [文件2] [文件3] ..git rm 文件1 [文件2] [文件3] .. #提交更改git commit -a -m “注解”git push [远程主机名] [本地分支名]:[远程分支名] #普通合并分支步骤如下： #如果A合并到B先把最新的A分支更新下来：git checkout Agit pull origin 远程A:本地A然后执行合并git checkout Bgit merge Agit status #查看冲突解决冲突git add 文件1 [文件2] [文件3] ..git rm 文件1 [文件2] [文件3] .. #分支合并git commit -a -m “注解”git push [远程主机名] [本地分支名]:[远程分支名] #分支衍合 （不保留日志的分支合并）将上面步骤的git merge A 更换成git rebase A将上面的git commit -a -m “注解”更换成git rebase –continue提交更改后的文件 #远程分支之间的合并登录git hub 线上合并 #git merge 解决冲突 #显示所有远程仓库git remote -v //git diff与beyond compare工具组合进行比较\配置如下：1.新建文件：git-diff-wrapper.sh ，内容如下 文件夹路径：C:\Users\oker\bin #/bin/sh diff is called by git with 7 parameters:path old-file old-hex old-mode new-file new-hex new-mode“你的Beyond Compare.exe文件路径” “$2” “$5”|cat &gt;/dev/null 2.修改.gitconfig文件，文件目录在用户根目录下，添加命令如下： 文件夹路径：C:\Users\oker[color] ui = auto[diff] external = ~/bin/git-diff-wrapper.sh #git 换行符问题解决在.gitconfig文件下面，添加以下配置[core] autocrlf = false filemode = false safecrlf = true 关掉并移除IDE中的所有项目，删除git_rep下面的所有文件，重新git init ; git clone ; git checkout 就可以了 //查看某个文件的历史提交记录git log –pretty=oneline [文件名]git show 版本号 //git提交换行符问题CR回车 LF换行Windows/Dos： CRLF \r\nLinux/Unix： LF \nMacOS： CR \r1.配置项：AutoCRLF//提交时转换为LF，检出时转换为CRLFgit config –global core.autocrlf true//提交时转换为LF，检出时不转换git config –global core.autocrlf input//提交检出均不转换git config –global core.autocrlf false2.配置项：SafeCRLF//拒绝提交包含混合换行符的文件git config –global core.safecrlf true//允许提交包含混合换行符的文件git config –global core.safecrlf false//提交包含混合换行符的文件时给出警告git config –global core.safecrlf warn3.总结：如果你是在Windows下开发，建议设置autocrlf为true。如果你文件编码是UTF8并且包含中文文字，那还是把autocrlf设置为false，并且把所有文件（待编辑文件？）转换为Linux编码（即LF\n），开启safecrlf检查。为什么？]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tomcat相关配置]]></title>
    <url>%2F2018%2F02%2F22%2F2018-02-22Tomcat%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[查看Tomcat版本执行tomcat安装目录下的脚本命令tomcat/bin/version.sh Tomcat中ClassLoader加载顺序 Bootstrap 引导类加载器，加载JVM启动需要的类，以及标准扩展类（位于jre/lib/ext下） System 系统类加载器，CLASSPATH环境变量和Tomcat启动需要的jar包，加载启动tomcat所需的类，比如bootstrap.jar，通常或在Catalina.sh或者Catalana.bat中指定，位于CATALINA_HOME/bin下 WebApp 类加载器，在WEB-INF/classes中查找要加载的类，如果没有就到WEB-INF/lib中查找要加载的类 Common 类加载器，在Tomcat目录下的CATALINA_HOME/lib目录下查找要加载的类]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[idea工具的使用]]></title>
    <url>%2F2018%2F02%2F21%2F2018-02-21idea%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[最近开始使用idea开发工具开发项目，很多配置与eclipse中的配置不一样，特整理一些配置方法 idea配置maven仓库File -&gt; Settings -&gt; 搜索”maven”关键字 -&gt; 将”Always update snapshots”按钮勾选上，将”User settings file”配置好，如下图所示 在当前工作窗口，导入第二个工程 File -&gt; Project structure…(或直接按Ctrl+Alt+Shift+S) -&gt; 选择Modules选项卡 -&gt; 点击”+”按钮添加模块 -&gt; Import Module -&gt; 选择项目文件夹 -&gt; 选择项目类型，之后就可以在Project窗口看到添加的项目了 idea设置自动编译 File -&gt; Settings -&gt; Build… -&gt; Compiler -&gt; 选中Build project automatically 和 compile independent modules in parallel按钮，如下图所示 快速创建一个main方法快捷键： psvm 快速输入System.out.println()快捷键：sout 生成构造器、getter、setter方法 Alt+Insert 自动填充变量名称 Ctrl+Alt+V 获取注册码参考博客：https://blog.csdn.net/halen001/article/details/81137092 我使用的是第三种方式： idea版本：idea 2018.2.2 (Ultimate Edition) 修改hosts文件：C:\Windows\System32\drivers\etc\hosts 将下面配置追加到文件末尾10.0.0.0 account.jetbrains.com 使用下面注册码注册1K71U8DBPNE-eyJsaWNlbnNlSWQiOiJLNzFVOERCUE5FIiwibGljZW5zZWVOYW1lIjoibGFuIHl1IiwiYXNzaWduZWVOYW1lIjoiIiwiYXNzaWduZWVFbWFpbCI6IiIsImxpY2Vuc2VSZXN0cmljdGlvbiI6IkZvciBlZHVjYXRpb25hbCB1c2Ugb25seSIsImNoZWNrQ29uY3VycmVudFVzZSI6ZmFsc2UsInByb2R1Y3RzIjpbeyJjb2RlIjoiSUkiLCJwYWlkVXBUbyI6IjIwMTktMDUtMDQifSx7ImNvZGUiOiJSUzAiLCJwYWlkVXBUbyI6IjIwMTktMDUtMDQifSx7ImNvZGUiOiJXUyIsInBhaWRVcFRvIjoiMjAxOS0wNS0wNCJ9LHsiY29kZSI6IlJEIiwicGFpZFVwVG8iOiIyMDE5LTA1LTA0In0seyJjb2RlIjoiUkMiLCJwYWlkVXBUbyI6IjIwMTktMDUtMDQifSx7ImNvZGUiOiJEQyIsInBhaWRVcFRvIjoiMjAxOS0wNS0wNCJ9LHsiY29kZSI6IkRCIiwicGFpZFVwVG8iOiIyMDE5LTA1LTA0In0seyJjb2RlIjoiUk0iLCJwYWlkVXBUbyI6IjIwMTktMDUtMDQifSx7ImNvZGUiOiJETSIsInBhaWRVcFRvIjoiMjAxOS0wNS0wNCJ9LHsiY29kZSI6IkFDIiwicGFpZFVwVG8iOiIyMDE5LTA1LTA0In0seyJjb2RlIjoiRFBOIiwicGFpZFVwVG8iOiIyMDE5LTA1LTA0In0seyJjb2RlIjoiR08iLCJwYWlkVXBUbyI6IjIwMTktMDUtMDQifSx7ImNvZGUiOiJQUyIsInBhaWRVcFRvIjoiMjAxOS0wNS0wNCJ9LHsiY29kZSI6IkNMIiwicGFpZFVwVG8iOiIyMDE5LTA1LTA0In0seyJjb2RlIjoiUEMiLCJwYWlkVXBUbyI6IjIwMTktMDUtMDQifSx7ImNvZGUiOiJSU1UiLCJwYWlkVXBUbyI6IjIwMTktMDUtMDQifV0sImhhc2giOiI4OTA4Mjg5LzAiLCJncmFjZVBlcmlvZERheXMiOjAsImF1dG9Qcm9sb25nYXRlZCI6ZmFsc2UsImlzQXV0b1Byb2xvbmdhdGVkIjpmYWxzZX0=-Owt3/+LdCpedvF0eQ8635yYt0+ZLtCfIHOKzSrx5hBtbKGYRPFDrdgQAK6lJjexl2emLBcUq729K1+ukY9Js0nx1NH09l9Rw4c7k9wUksLl6RWx7Hcdcma1AHolfSp79NynSMZzQQLFohNyjD+dXfXM5GYd2OTHya0zYjTNMmAJuuRsapJMP9F1z7UTpMpLMxS/JaCWdyX6qIs+funJdPF7bjzYAQBvtbz+6SANBgN36gG1B2xHhccTn6WE8vagwwSNuM70egpahcTktoHxI7uS1JGN9gKAr6nbp+8DbFz3a2wd+XoF3nSJb/d2f/6zJR8yJF8AOyb30kwg3zf5cWw==-MIIEPjCCAiagAwIBAgIBBTANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTE1MTEwMjA4MjE0OFoXDTE4MTEwMTA4MjE0OFowETEPMA0GA1UEAwwGcHJvZDN5MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAxcQkq+zdxlR2mmRYBPzGbUNdMN6OaXiXzxIWtMEkrJMO/5oUfQJbLLuMSMK0QHFmaI37WShyxZcfRCidwXjot4zmNBKnlyHodDij/78TmVqFl8nOeD5+07B8VEaIu7c3E1N+e1doC6wht4I4+IEmtsPAdoaj5WCQVQbrI8KeT8M9VcBIWX7fD0fhexfg3ZRt0xqwMcXGNp3DdJHiO0rCdU+Itv7EmtnSVq9jBG1usMSFvMowR25mju2JcPFp1+I4ZI+FqgR8gyG8oiNDyNEoAbsR3lOpI7grUYSvkB/xVy/VoklPCK2h0f0GJxFjnye8NT1PAywoyl7RmiAVRE/EKwIDAQABo4GZMIGWMAkGA1UdEwQCMAAwHQYDVR0OBBYEFGEpG9oZGcfLMGNBkY7SgHiMGgTcMEgGA1UdIwRBMD+AFKOetkhnQhI2Qb1t4Lm0oFKLl/GzoRykGjAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBggkA0myxg7KDeeEwEwYDVR0lBAwwCgYIKwYBBQUHAwEwCwYDVR0PBAQDAgWgMA0GCSqGSIb3DQEBCwUAA4ICAQC9WZuYgQedSuOc5TOUSrRigMw4/+wuC5EtZBfvdl4HT/8vzMW/oUlIP4YCvA0XKyBaCJ2iX+ZCDKoPfiYXiaSiH+HxAPV6J79vvouxKrWg2XV6ShFtPLP+0gPdGq3x9R3+kJbmAm8w+FOdlWqAfJrLvpzMGNeDU14YGXiZ9bVzmIQbwrBA+c/F4tlK/DV07dsNExihqFoibnqDiVNTGombaU2dDup2gwKdL81ua8EIcGNExHe82kjF4zwfadHk3bQVvbfdAwxcDy4xBjs3L4raPLU3yenSzr/OEur1+jfOxnQSmEcMXKXgrAQ9U55gwjcOFKrgOxEdek/Sk1VfOjvS+nuM4eyEruFMfaZHzoQiuw4IqgGc45ohFH0UUyjYcuFxxDSU9lMCv8qdHKm+wnPRb0l9l5vXsCBDuhAGYD6ss+Ga+aDY6f/qXZuUCEUOH3QUNbbCUlviSz6+GiRnt1kA9N2Qachl+2yBfaqUqr8h7Z2gsx5LcIf5kYNsqJ0GavXTVyWh7PYiKX4bs354ZQLUwwa/cG++2+wNWP+HtBhVxMRNTdVhSm38AknZlD+PTAsWGu9GyLmhti2EnVwGybSD2Dxmhxk3IPCkhKAK+pl0eWYGZWG3tJ9mZ7SowcXLWDFAk0lRJnKGFMTggrWjV8GYpw5bq23VmIqqDLgkNzuoog== 设置字体大小File -&gt; Settings -&gt; Color Schema font -&gt; 修改size的大小 设置使用eclipse快捷键File -&gt; Settings -&gt; keymap -&gt; 选择Eclipse即可 代买补全设置File -&gt; Settings -&gt; keymap 赋值eclipse配置方案 搜索并修改Completion-Basic快捷键为Alt+/ File -&gt; Settings -&gt; keymap -&gt; live Templates 选择默认扩展为Enter 添加Java模板组 添加main快捷键 点击define 参考博客： https://blog.csdn.net/www_wangjun/article/details/71722941]]></content>
      <categories>
        <category>整理</category>
      </categories>
      <tags>
        <tag>idea</tag>
        <tag>工具</tag>
        <tag>配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java对象序列化和反序列化源码解读]]></title>
    <url>%2F2018%2F01%2F14%2F2018-01-14Java%E5%AF%B9%E8%B1%A1%E5%BA%8F%E5%88%97%E5%8C%96%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%2F</url>
    <content type="text"><![CDATA[Java对象序列化new ObjectOutputStream123456789101112131415161718public ObjectOutputStream(OutputStream out) throws IOException &#123; verifySubclass(); bout = new BlockDataOutputStream(out); handles = new HandleTable(10, (float) 3.00); subs = new ReplaceTable(10, (float) 3.00); enableOverride = false; writeStreamHeader();/*protected void writeStreamHeader() throws IOException &#123; bout.writeShort(STREAM_MAGIC);// 在文件头写入 ac ed bout.writeShort(STREAM_VERSION);// 在文件头写入00 05&#125;*/ bout.setBlockDataMode(true);// 设置blockDataMode为true if (extendedDebugInfo) &#123; debugInfoStack = new DebugTraceInfoStack(); &#125; else &#123; debugInfoStack = null; &#125;&#125; output.writeObject(p)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138public final void writeObject(Object obj) throws IOException &#123; if (enableOverride) &#123; // 如果为true，调用writeObjectOverride方法而不是writeObject(obj,false)方法 writeObjectOverride(obj); return; &#125; try &#123; writeObject0(obj, false); &#125; catch (IOException ex) &#123; if (depth == 0) &#123; writeFatalException(ex); &#125; throw ex; &#125;&#125;private void writeObject0(Object obj, boolean unshared) throws IOException&#123; boolean oldMode = bout.setBlockDataMode(false);// 切换块数据模式为false，切换模式会把数据写入buffer中/*boolean setBlockDataMode(boolean mode) throws IOException &#123; // ObjectOutputStream中的 if (blkmode == mode) &#123;//如果模式相等，返回旧模式 return blkmode; &#125; drain();// 如果模式转换了 blkmode = mode; return !blkmode;&#125;void drain() throws IOException &#123; if (pos == 0) &#123;// 没数据可以写入，即使之前是数据块模式，如果没有数据可以写入，也是不会写任何东西的 return; &#125; if (blkmode) &#123;// 如果原来的模式是数据块模式，现在要转换成非数据块模式，这里需要将数据块头消息写入，再写入数据块 writeBlockHeader(pos); &#125; out.write(buf, 0, pos); pos = 0;&#125;private void writeBlockHeader(int len) throws IOException &#123; if (len &lt;= 0xFF) &#123;// 如果缓冲中的数据长度小于0xFF，先写入(byte)0x77一个字节，再写入数据长度一个字节 hbuf[0] = TC_BLOCKDATA; hbuf[1] = (byte) len; out.write(hbuf, 0, 2); &#125; else &#123; // 如果缓冲中的数据长度大于0xFF，先写入(byte)0x7A一个字节，再将长度当做四个字节写入之后的位置上 hbuf[0] = TC_BLOCKDATALONG; Bits.putInt(hbuf, 1, len); out.write(hbuf, 0, 5); &#125;&#125;public void write(byte b[], int off, int len) throws IOException &#123;// 将缓冲中的数据写入输出流 if (b == null) &#123; throw new NullPointerException(); &#125; else if ((off &lt; 0) || (off &gt; b.length) || (len &lt; 0) || ((off + len) &gt; b.length) || ((off + len) &lt; 0)) &#123; throw new IndexOutOfBoundsException(); &#125; else if (len == 0) &#123; return; &#125; for (int i = 0 ; i &lt; len ; i++) &#123; write(b[off + i]); &#125;&#125;*/ depth++; try &#123; // handle previously written and non-replaceable objects int h; if ((obj = subs.lookup(obj)) == null) &#123;// 替换表中查找？ writeNull(); return; &#125; else if (!unshared &amp;&amp; (h = handles.lookup(obj)) != -1) &#123; writeHandle(h); return; &#125; else if (obj instanceof Class) &#123; writeClass((Class) obj, unshared); return; &#125; else if (obj instanceof ObjectStreamClass) &#123; writeClassDesc((ObjectStreamClass) obj, unshared); return; &#125; Object orig = obj; Class&lt;?&gt; cl = obj.getClass();// 获取对象的class ObjectStreamClass desc; for (;;) &#123; Class&lt;?&gt; repCl; desc = ObjectStreamClass.lookup(cl, true);// 生成Object的一个描述对象出来 if (!desc.hasWriteReplaceMethod() || (obj = desc.invokeWriteReplace(obj)) == null || (repCl = obj.getClass()) == cl) &#123; break; &#125; cl = repCl; &#125; if (enableReplace) &#123; Object rep = replaceObject(obj); if (rep != obj &amp;&amp; rep != null) &#123; cl = rep.getClass(); desc = ObjectStreamClass.lookup(cl, true); &#125; obj = rep; &#125; // if object replaced, run through original checks a second time if (obj != orig) &#123; subs.assign(orig, obj); if (obj == null) &#123; writeNull(); return; &#125; else if (!unshared &amp;&amp; (h = handles.lookup(obj)) != -1) &#123; writeHandle(h); return; &#125; else if (obj instanceof Class) &#123; writeClass((Class) obj, unshared); return; &#125; else if (obj instanceof ObjectStreamClass) &#123; writeClassDesc((ObjectStreamClass) obj, unshared); return; &#125; &#125; // remaining cases if (obj instanceof String) &#123;// 如果对象是个String的类型，直接将String写出去就可以了 writeString((String) obj, unshared); &#125; else if (cl.isArray()) &#123; writeArray(obj, desc, unshared); &#125; else if (obj instanceof Enum) &#123; writeEnum((Enum&lt;?&gt;) obj, desc, unshared); &#125; else if (obj instanceof Serializable) &#123; writeOrdinaryObject(obj, desc, unshared);// 将Object写入输出流 &#125; else &#123; if (extendedDebugInfo) &#123; throw new NotSerializableException( cl.getName() + "\n" + debugInfoStack.toString()); &#125; else &#123; throw new NotSerializableException(cl.getName()); &#125; &#125; &#125; finally &#123; depth--; bout.setBlockDataMode(oldMode); &#125;&#125; 查找class的ObjectStreamClass对象描述信息1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283static ObjectStreamClass lookup(Class&lt;?&gt; cl, boolean all) &#123; if (!(all || Serializable.class.isAssignableFrom(cl))) &#123;// 如果Object可以被序列化 return null; &#125; processQueue(Caches.localDescsQueue, Caches.localDescs);// 一个是引用队列 一个是集合Map&lt;WeakClassKey&lt;class&gt;,SoftReference&lt;EntryFuture&gt;&gt;， 引用队列里保存的就是这个Map集合的Key ，将所有失效的引用删除，以及map中的保存的SoftReference&lt;EntryFuture&gt; value删除/*private static final ReferenceQueue&lt;Class&lt;?&gt;&gt; localDescsQueue = new ReferenceQueue&lt;&gt;();// 引用队列static final ConcurrentMap&lt;WeakClassKey,Reference&lt;?&gt;&gt; localDescs = new ConcurrentHashMap&lt;&gt;();// 弱引用以及引用队列static void processQueue(ReferenceQueue&lt;Class&lt;?&gt;&gt; queue,ConcurrentMap&lt;? extends WeakReference&lt;Class&lt;?&gt;&gt;, ?&gt; map)&#123; Reference&lt;? extends Class&lt;?&gt;&gt; ref; while((ref = queue.poll()) != null) &#123;// 从引用队列中拿出已经被删除的引用，然后从map中清除对应的value值 map.remove(ref); &#125;&#125;*/ // 这里的class对应的是WeakClassKey（class）， 里面持有的是class的hash值 // 下面的Field对应的是FieldReflectorKey（class）， 也是WeakReference&lt;Class&gt;类型, 里面持有的是fieldName, fieldSignature WeakClassKey key = new WeakClassKey(cl, Caches.localDescsQueue);/*static class WeakClassKey extends WeakReference&lt;Class&lt;?&gt;&gt; &#123; private final int hash; WeakClassKey(Class&lt;?&gt; cl, ReferenceQueue&lt;Class&lt;?&gt;&gt; refQueue) &#123; super(cl, refQueue);// 将这个Object的Class对象的弱引用与引用队列关联 hash = System.identityHashCode(cl);// 将这个Class对象的hashCode保存起来 &#125;*/ Reference&lt;?&gt; ref = Caches.localDescs.get(key);// 从map中通过这个WeakClassKey获取SoftReference&lt;EntryFuture&gt; Object entry = null; if (ref != null) &#123;// 如果能拿到SoftReference&lt;EntryFuture&gt;值出来 entry = ref.get(); &#125; EntryFuture future = null; if (entry == null) &#123;// 如果前面没有拿到对应的EntryFuture EntryFuture newEntry = new EntryFuture();// 自己创建一个EntryFuture Reference&lt;?&gt; newRef = new SoftReference&lt;&gt;(newEntry);// 再使用软引用将这个EntryFuture包装起来 do &#123; if (ref != null) &#123;// 如果软引用不为null，将其从map中删除掉 Caches.localDescs.remove(key, ref); &#125; ref = Caches.localDescs.putIfAbsent(key, newRef);// 将新的WeakClassKey和新的SoftReference(EntryFuture)放入map中 if (ref != null) &#123;// 如果map中有旧值，将旧值拿出来 entry = ref.get(); &#125; &#125; while (ref != null &amp;&amp; entry == null);// 如果map中有旧的SoftReference(EntryFuture),其对应的EntryFuture还等于null，继续循环，将其删除，放入新的WeakClassKey(class)和新的SoftReference(newEntry) if (entry == null) &#123;// 如果entry为null，将新的EntryFuture赋值给变量future，以供下面使用 future = newEntry; &#125; &#125; if (entry instanceof ObjectStreamClass) &#123; // check common case first return (ObjectStreamClass) entry; &#125; if (entry instanceof EntryFuture) &#123; future = (EntryFuture) entry; if (future.getOwner() == Thread.currentThread()) &#123; entry = null; &#125; else &#123; entry = future.get(); &#125; &#125; if (entry == null) &#123;// 如果entry为null，现在这个Entry就是个null值，得创建一份出来，然后放入EntryFuture中 try &#123; entry = new ObjectStreamClass(cl);// 创建一个ObjectStreamClass(class)对象，当做Entry，需要放入EntryFuture中，并且需要将WeakClassKey(class)当key，SoftReference(EntryFuture&lt;ObjectStreamClass&gt;)当value保存到map中 &#125; catch (Throwable th) &#123; entry = th; &#125; if (future.set(entry)) &#123;// 将该强引用放入future中 Caches.localDescs.put(key, new SoftReference&lt;Object&gt;(entry));// 将ObjectStreamClass用一个软引用包起来，保存到key是WeakClassKey(class)的map中 &#125; else &#123; entry = future.get();// 如果放入失败，从future中拿出那个强引用 &#125; &#125; if (entry instanceof ObjectStreamClass) &#123; return (ObjectStreamClass) entry; &#125; else if (entry instanceof RuntimeException) &#123; throw (RuntimeException) entry; &#125; else if (entry instanceof Error) &#123; throw (Error) entry; &#125; else &#123; throw new InternalError("unexpected entry: " + entry); &#125;&#125; new ObjectStreamClass(Class)时候的代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336private ObjectStreamClass(final Class&lt;?&gt; cl) &#123; this.cl = cl; // 将class类型保存到cl字段上 name = cl.getName();// 将类型名称保存到name字段上 isProxy = Proxy.isProxyClass(cl);// 将是否是代理类保存到isProxy字段上 isEnum = Enum.class.isAssignableFrom(cl);// 将是否是枚举保存到isEnum字段上 serializable = Serializable.class.isAssignableFrom(cl);// 将是否可以序列化保存到serializable字段上 externalizable = Externalizable.class.isAssignableFrom(cl);// 将是否是自定义序列化保存到externalizable字段上 Class&lt;?&gt; superCl = cl.getSuperclass();// 拿到这个class的父类class superDesc = (superCl != null) ? lookup(superCl, false) : null;// 将父类对象class描述保存到superDesc字段上 localDesc = this;// 将本对象class描述保存到localDesc字段上 if (serializable) &#123; // 如果是可序列化类型的对象 AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() &#123;// 使用特权处理本类中的构造函数及属性字段 public Void run() &#123; if (isEnum) &#123; suid = Long.valueOf(0); fields = NO_FIELDS; return null; &#125; if (cl.isArray()) &#123; fields = NO_FIELDS; return null; &#125; suid = getDeclaredSUID(cl);// 获取class保存着的静态的、final的版本号/*private static Long getDeclaredSUID(Class&lt;?&gt; cl) &#123; try &#123; Field f = cl.getDeclaredField("serialVersionUID");//3206093459760846163L int mask = Modifier.STATIC | Modifier.FINAL; if ((f.getModifiers() &amp; mask) == mask) &#123; f.setAccessible(true); return Long.valueOf(f.getLong(null)); &#125; &#125; catch (Exception ex) &#123; &#125; return null;&#125;*/ try &#123; fields = getSerialFields(cl);// 获取可序列化的属性字段/*private static ObjectStreamField[] getSerialFields(Class&lt;?&gt; cl) throws InvalidClassException&#123; ObjectStreamField[] fields; if (Serializable.class.isAssignableFrom(cl) &amp;&amp; //还得校验一遍class类型是不是可序列化的、不能是代理类、不能是接口 !Externalizable.class.isAssignableFrom(cl) &amp;&amp; !Proxy.isProxyClass(cl) &amp;&amp; !cl.isInterface())&#123; if ((fields = getDeclaredSerialFields(cl)) == null) &#123;// 看看有没有自定义自己配置的可序列化的字段，字段名必须是serialPersistentFields，类型是ObjectStreamField[]数组类型 fields = getDefaultSerialFields(cl);// 如果自己没有自定义自配置可序列化字段，那就按正常逻辑走了 &#125; Arrays.sort(fields);// 对这些属性字段定义（ObjectStreamField）进行排序 &#125; else &#123; fields = NO_FIELDS;// 如果实现的是Externalizable，fields是空的 &#125; return fields;&#125;// 查找自己定义的可序列化字段===serialPersistentFieldsprivate static ObjectStreamField[] getDeclaredSerialFields(Class&lt;?&gt; cl) throws InvalidClassException&#123;// ObjectStreamClass中的 ObjectStreamField[] serialPersistentFields = null;// 查找序列化编号字段 try &#123; Field f = cl.getDeclaredField("serialPersistentFields");// 尝试拿到serialPersistentFields字段，这个字段必须是private、static、final修饰的 int mask = Modifier.PRIVATE | Modifier.STATIC | Modifier.FINAL; if ((f.getModifiers() &amp; mask) == mask) &#123; f.setAccessible(true); serialPersistentFields = (ObjectStreamField[]) f.get(null); &#125; &#125; catch (Exception ex) &#123; &#125; if (serialPersistentFields == null) &#123; return null; &#125; else if (serialPersistentFields.length == 0) &#123; return NO_FIELDS;// 没有字段可序列化 &#125; // 如果拿到了这么一个字段，并且拿到了其里面配置的ObjectStreamField[]数组对象 ObjectStreamField[] boundFields = new ObjectStreamField[serialPersistentFields.length];// 创建一个数组，用于保存在Object中真实存在的这些配置的属性字段 Set&lt;String&gt; fieldNames = new HashSet&lt;&gt;(serialPersistentFields.length);// 定义一个集合 for (int i = 0; i &lt; serialPersistentFields.length; i++) &#123; ObjectStreamField spf = serialPersistentFields[i];// 获取第i个ObjectStreamField配置项 String fname = spf.getName(); if (fieldNames.contains(fname)) &#123;// 名字不能配置重复 throw new InvalidClassException( "multiple serializable fields named " + fname); &#125; fieldNames.add(fname);// 将名字放入fieldNames集合中 try &#123; Field f = cl.getDeclaredField(fname);// 根据名字再去class中看有没有这个字段属性 if ((f.getType() == spf.getType()) &amp;&amp; ((f.getModifiers() &amp; Modifier.STATIC) == 0))&#123;// 如果拿到的字段属性跟配置的字段属性一样，并且不是static修饰的 boundFields[i] = new ObjectStreamField(f, spf.isUnshared(), true);// 这里才是真正的封装一个ObjectStreamField &#125; &#125; catch (NoSuchFieldException ex) &#123; &#125; if (boundFields[i] == null) &#123; // 如果从class中拿不到配置中的属性字段，也封装一个配置的属性名称及属性类型的ObjectStreamField对象 boundFields[i] = new ObjectStreamField(fname, spf.getType(), spf.isUnshared()); &#125; &#125; return boundFields;&#125;public Field getDeclaredField(String name) throws NoSuchFieldException, SecurityException &#123;// 从class中查找定义的属性字段 checkMemberAccess(Member.DECLARED, Reflection.getCallerClass(), true);// 校验是否有查看该class的权限 Field field = searchFields(privateGetDeclaredFields(false), name);// 查找对应的field if (field == null) &#123; throw new NoSuchFieldException(name); &#125; return field;&#125;private void checkMemberAccess(int which, Class&lt;?&gt; caller, boolean checkProxyInterfaces) &#123;// 校验是否有查看该class的权限 final SecurityManager s = System.getSecurityManager();// 权限管理，现在为null if (s != null) &#123; final ClassLoader ccl = ClassLoader.getClassLoader(caller); final ClassLoader cl = getClassLoader0(); if (which != Member.PUBLIC) &#123; if (ccl != cl) &#123; s.checkPermission(SecurityConstants.CHECK_MEMBER_ACCESS_PERMISSION); &#125; &#125; this.checkPackageAccess(ccl, checkProxyInterfaces); &#125;&#125;private Field[] privateGetDeclaredFields(boolean publicOnly) &#123;// 该class所有的属性字段定义，不仅仅是public修饰的 checkInitted(); Field[] res; ReflectionData&lt;T&gt; rd = reflectionData(); if (rd != null) &#123; res = publicOnly ? rd.declaredPublicFields : rd.declaredFields;// declaredFields是所有的属性字段，不仅仅是public的 if (res != null) return res; &#125; // No cached value available; request value from VM res = Reflection.filterFields(this, getDeclaredFields0(publicOnly)); if (rd != null) &#123; if (publicOnly) &#123; rd.declaredPublicFields = res; &#125; else &#123; rd.declaredFields = res; &#125; &#125; return res;&#125;private ReflectionData&lt;T&gt; reflectionData() &#123;// 从Class对象的的reflectionData属性字段（SoftReference）中获取反射数据 SoftReference&lt;ReflectionData&lt;T&gt;&gt; reflectionData = this.reflectionData; int classRedefinedCount = this.classRedefinedCount; ReflectionData&lt;T&gt; rd; if (useCaches &amp;&amp; reflectionData != null &amp;&amp; (rd = reflectionData.get()) != null &amp;&amp; rd.redefinedCount == classRedefinedCount) &#123; return rd;// 将缓存中的反射数据返回 &#125; return newReflectionData(reflectionData, classRedefinedCount);&#125;private static Field searchFields(Field[] fields, String name) &#123;// 既然拿到了所有的属性字段定义，一个一个比较名字就可以了，如果名字相同，返回 String internedName = name.intern(); for (int i = 0; i &lt; fields.length; i++) &#123; if (fields[i].getName() == internedName) &#123; return getReflectionFactory().copyField(fields[i]); &#125; &#125; return null;&#125;public Field copyField(Field var1) &#123; return langReflectAccess().copyField(var1);&#125;Field copy() &#123;// 拷贝一个Field对象 if (this.root != null) throw new IllegalArgumentException("Can not copy a non-root Field"); Field res = new Field(clazz, name, type, modifiers, slot, signature, annotations); res.root = this; res.fieldAccessor = fieldAccessor; res.overrideFieldAccessor = overrideFieldAccessor; return res;&#125;// 如果没有配置serialPersistentFields，那就需要自己去遍历Class的字段属性了private static ObjectStreamField[] getDefaultSerialFields(Class&lt;?&gt; cl) &#123; Field[] clFields = cl.getDeclaredFields();// 拿到class中的属性字段 ArrayList&lt;ObjectStreamField&gt; list = new ArrayList&lt;&gt;(); int mask = Modifier.STATIC | Modifier.TRANSIENT; for (int i = 0; i &lt; clFields.length; i++) &#123; if ((clFields[i].getModifiers() &amp; mask) == 0) &#123;// 将静态字段和transient修饰的字段过滤 list.add(new ObjectStreamField(clFields[i], false, true));// 将字段包装成ObjectStreamField类型 &#125; &#125; int size = list.size(); return (size == 0) ? NO_FIELDS : list.toArray(new ObjectStreamField[size]);&#125;*/ computeFieldOffsets();// 计算便宜量，及字段属性数量/*private void computeFieldOffsets() throws InvalidClassException &#123; primDataSize = 0; numObjFields = 0; int firstObjIndex = -1; for (int i = 0; i &lt; fields.length; i++) &#123; ObjectStreamField f = fields[i]; switch (f.getTypeCode()) &#123; case 'Z': case 'B': f.setOffset(primDataSize++);// 设置原始数据偏移量 break; case 'C': case 'S': f.setOffset(primDataSize);// 设置原始数据偏移量 primDataSize += 2;// 记录原始数据字节数 break; case 'I': case 'F': f.setOffset(primDataSize);// 设置原始数据偏移量 primDataSize += 4;// 记录原始数据字节数 break; case 'J': case 'D': f.setOffset(primDataSize);// 设置原始数据偏移量 primDataSize += 8;// 记录原始数据字节数 break; case '[': case 'L': f.setOffset(numObjFields++);// 设置这是第几个非原始属性字段 if (firstObjIndex == -1) &#123; firstObjIndex = i; &#125; break; default: throw new InternalError(); &#125; &#125; if (firstObjIndex != -1 &amp;&amp; firstObjIndex + numObjFields != fields.length)&#123; throw new InvalidClassException(name, "illegal field order"); &#125;&#125;*/ &#125; catch (InvalidClassException e) &#123; serializeEx = deserializeEx = new ExceptionInfo(e.classname, e.getMessage()); fields = NO_FIELDS; &#125; if (externalizable) &#123; cons = getExternalizableConstructor(cl); &#125; else &#123; cons = getSerializableConstructor(cl);// 将class对象的无参构造函数保存到cons变量/*private static Constructor&lt;?&gt; getSerializableConstructor(Class&lt;?&gt; cl) &#123; Class&lt;?&gt; initCl = cl; while (Serializable.class.isAssignableFrom(initCl)) &#123;// 查找不可序列化的父类 if ((initCl = initCl.getSuperclass()) == null) &#123; return null; &#125; &#125; try &#123; Constructor&lt;?&gt; cons = initCl.getDeclaredConstructor((Class&lt;?&gt;[]) null);// 拿到不可序列化的父类的无参构造函数 int mods = cons.getModifiers(); if ((mods &amp; Modifier.PRIVATE) != 0 || // 校验不可序列化的父类无参构造函数，不能是私有的，必须是public或protected类型，包必须有访问权限 ((mods &amp; (Modifier.PUBLIC | Modifier.PROTECTED)) == 0 &amp;&amp; !packageEquals(cl, initCl)))&#123; return null; &#125; cons = reflFactory.newConstructorForSerialization(cl, cons);// 创建一个新的构造方法 cons.setAccessible(true); return cons; &#125; catch (NoSuchMethodException ex) &#123; return null; &#125;&#125;*/ writeObjectMethod = getPrivateMethod(cl, "writeObject", new Class&lt;?&gt;[] &#123; ObjectOutputStream.class &#125;,Void.TYPE);// 将writeObject方法保存到writeObjectMethod属性字段上 readObjectMethod = getPrivateMethod(cl, "readObject",new Class&lt;?&gt;[] &#123; ObjectInputStream.class &#125;,Void.TYPE);// 将readObject方法保存到readObjectMethod属性字段上 readObjectNoDataMethod = getPrivateMethod(cl, "readObjectNoData", null, Void.TYPE);// 将readObjectNoData方法保存到readObjectNoDataMethod属性字段上/*private static Method getPrivateMethod(Class&lt;?&gt; cl, String name,Class&lt;?&gt;[] argTypes,Class&lt;?&gt; returnType)&#123;// 收集当前class的私有方法 try &#123; Method meth = cl.getDeclaredMethod(name, argTypes); meth.setAccessible(true); int mods = meth.getModifiers(); return ((meth.getReturnType() == returnType) &amp;&amp; ((mods &amp; Modifier.STATIC) == 0) &amp;&amp; ((mods &amp; Modifier.PRIVATE) != 0)) ? meth : null;// 收集private类型的非static类型的方法 &#125; catch (NoSuchMethodException ex) &#123; return null; &#125;&#125;*/ hasWriteObjectData = (writeObjectMethod != null);// 是否有其它需要持久化的数据 &#125; writeReplaceMethod = getInheritableMethod(cl, "writeReplace", null, Object.class);// 将writeReplace方法收集起来（当前类或者父类） readResolveMethod = getInheritableMethod(cl, "readResolve", null, Object.class);// 将readResolve方法收集起来（当前类或者父类）/*private static Method getInheritableMethod(Class&lt;?&gt; cl, String name,Class&lt;?&gt;[] argTypes, Class&lt;?&gt; returnType)&#123;// 收集自己（私有/公有，非静态）或父类（非静态、非私有）里的方法 Method meth = null; Class&lt;?&gt; defCl = cl; while (defCl != null) &#123; try &#123; meth = defCl.getDeclaredMethod(name, argTypes); break; &#125; catch (NoSuchMethodException ex) &#123; defCl = defCl.getSuperclass(); &#125; &#125; if ((meth == null) || (meth.getReturnType() != returnType)) &#123; return null; &#125; meth.setAccessible(true); int mods = meth.getModifiers(); if ((mods &amp; (Modifier.STATIC | Modifier.ABSTRACT)) != 0) &#123; return null; &#125; else if ((mods &amp; (Modifier.PUBLIC | Modifier.PROTECTED)) != 0) &#123; return meth; &#125; else if ((mods &amp; Modifier.PRIVATE) != 0) &#123; return (cl == defCl) ? meth : null; &#125; else &#123; return packageEquals(cl, defCl) ? meth : null; &#125;&#125;*/ return null; &#125; &#125;); &#125; else &#123; suid = Long.valueOf(0); fields = NO_FIELDS; &#125; try &#123; fieldRefl = getReflector(fields, this);// 处理收集到的ObjectStreamField数组，将其转换成FieldReflactor对象，保存到fieldRefl属性字段上 &#125; catch (InvalidClassException ex) &#123; throw new InternalError(ex); &#125; if (deserializeEx == null) &#123; if (isEnum) &#123; deserializeEx = new ExceptionInfo(name, "enum type"); &#125; else if (cons == null) &#123; deserializeEx = new ExceptionInfo(name, "no valid constructor"); &#125; &#125; for (int i = 0; i &lt; fields.length; i++) &#123; if (fields[i].getField() == null) &#123; defaultSerializeEx = new ExceptionInfo(name, "unmatched serializable field(s) declared"); &#125; &#125;&#125; 获取ObjectStreamClass中的FieldReflector对象的方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107private static FieldReflector getReflector(ObjectStreamField[] fields, ObjectStreamClass localDesc) throws InvalidClassException&#123; Class&lt;?&gt; cl = (localDesc != null &amp;&amp; fields.length &gt; 0) ? localDesc.cl : null;// 拿到要序列化对象的Class processQueue(Caches.reflectorsQueue, Caches.reflectors);// 清理引用队列中无效的引用（FieldReflectorKey(class,queue)&lt;=&gt;WeakReference(class)，也就是说Class对象被回收了），并将reflectors Map中对应的弱引用删除（key=FieldReflectorKey,value为弱引用SoftReference&lt;EntryFuture&gt;） // 上面的class对应的是WeakClassKey（class）， 里面持有的是class的hash值 // 这里的Field对应的是FieldReflectorKey（class）， 也是WeakReference&lt;Class&gt;类型, 里面持有的是fieldName, fieldSignature FieldReflectorKey key = new FieldReflectorKey(cl, fields, Caches.reflectorsQueue); Reference&lt;?&gt; ref = Caches.reflectors.get(key);// 如果在map中保存有这个FieldReflectorKey，将其对应的Value拿出来，Value就是一个对象软引用（SoftReference&lt;EntryFuture&gt;） Object entry = null; if (ref != null) &#123; entry = ref.get();// 如果能使用新创建的FieldReflectorKey当做key从map中吧SoftReference&lt;EntryFuture&gt;拿出来，怎么可能？ &#125; EntryFuture future = null; if (entry == null) &#123; EntryFuture newEntry = new EntryFuture(); Reference&lt;?&gt; newRef = new SoftReference&lt;&gt;(newEntry);// 给新创建的EntryFuture分配一个软引用 do &#123; if (ref != null) &#123;// 如果之前就有FieldReflectorKey，并且有其对应的EntryFuture的软引用，但是软引用中的EntryFuture拿不到，那就将它从map集合中删除掉 Caches.reflectors.remove(key, ref); &#125; ref = Caches.reflectors.putIfAbsent(key, newRef);// 我们再把新的FieldReflectorKey及对应的软引用保存到map中去 if (ref != null) &#123; entry = ref.get(); &#125; &#125; while (ref != null &amp;&amp; entry == null);// 如果旧的软引用存在，但是里面的EntryFuture是null的，一直循环处理 if (entry == null) &#123;// 如果entry还是空的，将EntryFuture赋值，然后下面会将处理过的Entry放入EntryFuture中保存起来 future = newEntry; &#125; &#125; if (entry instanceof FieldReflector) &#123; // check common case first return (FieldReflector) entry; &#125; else if (entry instanceof EntryFuture) &#123; entry = ((EntryFuture) entry).get(); &#125; else if (entry == null) &#123; try &#123; entry = new FieldReflector(matchFields(fields, localDesc));// 真正创建FieldReflactor对象， 上面class创建的是ObjectStreamClass对象,为啥这里不是创建的额ObjectStreamField对象？/*private static ObjectStreamField[] matchFields(ObjectStreamField[] fields,ObjectStreamClass localDesc) throws InvalidClassException&#123; // 传进来的Fields不就是ObjectStreamClass中的fields字段吗，这还匹配个啥？ ObjectStreamField[] localFields = (localDesc != null) ? localDesc.fields : NO_FIELDS;// 拿到所有的fields ObjectStreamField[] matches = new ObjectStreamField[fields.length]; for (int i = 0; i &lt; fields.length; i++) &#123; ObjectStreamField f = fields[i], m = null;// 拿到传进来的ObjectStreamField[i] for (int j = 0; j &lt; localFields.length; j++) &#123; ObjectStreamField lf = localFields[j];// 拿到ObjectStreamClass中的fields[j] if (f.getName().equals(lf.getName())) &#123;// 如果字段名相等 if ((f.isPrimitive() || lf.isPrimitive()) &amp;&amp; // 如果是原始类型，并且类型不一致，抛出异常 f.getTypeCode() != lf.getTypeCode())&#123; throw new InvalidClassException(localDesc.name,"incompatible types for field " + f.getName()); &#125; if (lf.getField() != null) &#123; m = new ObjectStreamField(lf.getField(), lf.isUnshared(), false); &#125; else &#123; m = new ObjectStreamField(lf.getName(), lf.getSignature(), lf.isUnshared()); &#125; &#125; &#125; if (m == null) &#123;// 如果与ObjectStreamClass中的fields匹配不成功，就再创建一个ObjectStreamField，这怎么会匹配不成功，不都是同一个数组引用吗？ m = new ObjectStreamField(f.getName(), f.getSignature(), false); &#125; m.setOffset(f.getOffset());// 设置偏移量 matches[i] = m; &#125; return matches;&#125;FieldReflector(ObjectStreamField[] fields) &#123;// 将匹配成功的fields放入FieldReflector中保存起来 this.fields = fields; // 保存fields引用 int nfields = fields.length;// 保存fields数组长度 readKeys = new long[nfields];// 属性字段的内存偏移量 writeKeys = new long[nfields];// 属性字段的内存偏移量 offsets = new int[nfields]; // 原始数据类型属性字段的字节数组下标，非原始数据类型属性字段的第几个（从0开始）非原始数据类型属性字段 typeCodes = new char[nfields]; // 创建字段属性类型的数组 ArrayList&lt;Class&lt;?&gt;&gt; typeList = new ArrayList&lt;&gt;(); Set&lt;Long&gt; usedKeys = new HashSet&lt;&gt;(); for (int i = 0; i &lt; nfields; i++) &#123; ObjectStreamField f = fields[i]; Field rf = f.getField();// 从ObjectStreamField中拿出Field对象出来 long key = (rf != null) ? unsafe.objectFieldOffset(rf) : Unsafe.INVALID_FIELD_OFFSET;// 计算字段在class中的偏移量 readKeys[i] = key;// 保存属性字段在class中的偏移量 writeKeys[i] = usedKeys.add(key) ? key : Unsafe.INVALID_FIELD_OFFSET;// 去重字段属性在class中的偏移量，并将偏移量写入writeKeys数组中 offsets[i] = f.getOffset();// 将原始类型字段的偏移量或第几个非原始类型属性字段保存到offsets中 typeCodes[i] = f.getTypeCode();// 保存属性字段的类型 if (!f.isPrimitive()) &#123;// 如果不是原始类型的属性字段，将属性字段的类型保存到typeList集合中 typeList.add((rf != null) ? rf.getType() : null); &#125; &#125; types = typeList.toArray(new Class&lt;?&gt;[typeList.size()]);// 将非原始类型的属性字段的class类型保存到数组types中 numPrimFields = nfields - types.length;// 将原始类型的属性字段数量保存到numPrimFields中&#125;*/ &#125; catch (Throwable th) &#123; entry = th; &#125; future.set(entry); Caches.reflectors.put(key, new SoftReference&lt;Object&gt;(entry)); &#125; if (entry instanceof FieldReflector) &#123; return (FieldReflector) entry; &#125; else if (entry instanceof InvalidClassException) &#123; throw (InvalidClassException) entry; &#125; else if (entry instanceof RuntimeException) &#123; throw (RuntimeException) entry; &#125; else if (entry instanceof Error) &#123; throw (Error) entry; &#125; else &#123; throw new InternalError("unexpected entry: " + entry); &#125;&#125; 开始写入Object序列化数据1234567891011121314151617181920212223private void writeOrdinaryObject(Object obj,ObjectStreamClass desc,boolean unshared)throws IOException&#123; if (extendedDebugInfo) &#123;// debug debugInfoStack.push( (depth == 1 ? "root " : "") + "object (class \"" + obj.getClass().getName() + "\", " + obj.toString() + ")"); &#125; try &#123; desc.checkSerialize();// 查看是否有序列化异常 bout.writeByte(TC_OBJECT);// 开始序列化Object，将Object标志位写入，0x73; writeClassDesc(desc, false);// 将描述信息写入 handles.assign(unshared ? null : obj); if (desc.isExternalizable() &amp;&amp; !desc.isProxy()) &#123; writeExternalData((Externalizable) obj); &#125; else &#123; writeSerialData(obj, desc);// 将Object的序列化的数据写入 &#125; &#125; finally &#123; if (extendedDebugInfo) &#123; debugInfoStack.pop(); &#125; &#125;&#125; 写入ObjectStreamClass对象描述信息123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869private void writeClassDesc(ObjectStreamClass desc, boolean unshared) throws IOException&#123; int handle; if (desc == null) &#123; writeNull(); &#125; else if (!unshared &amp;&amp; (handle = handles.lookup(desc)) != -1) &#123; writeHandle(handle); &#125; else if (desc.isProxy()) &#123; writeProxyDesc(desc, unshared); &#125; else &#123; writeNonProxyDesc(desc, unshared);// 写出非代理对象 &#125;&#125;private void writeNonProxyDesc(ObjectStreamClass desc, boolean unshared) throws IOException&#123; bout.writeByte(TC_CLASSDESC);// 开始写class的描述信息，先将标志位写入 handles.assign(unshared ? null : desc); if (protocol == PROTOCOL_VERSION_1) &#123; // do not invoke class descriptor write hook with old protocol desc.writeNonProxy(this); &#125; else &#123; // 如果序列化版本不是1 writeClassDescriptor(desc);// 类型描述/*protected void writeClassDescriptor(ObjectStreamClass desc) throws IOException&#123; desc.writeNonProxy(this);// 这里的this就是ObjectOutputStream&#125;void writeNonProxy(ObjectOutputStream out) throws IOException &#123; out.writeUTF(name);// 将类名写入 com.jzg.quartz.job.task.TestTask$Person out.writeLong(getSerialVersionUID());// 将class的序列化编号写入 byte flags = 0; if (externalizable) &#123; flags |= ObjectStreamConstants.SC_EXTERNALIZABLE; int protocol = out.getProtocolVersion(); if (protocol != ObjectStreamConstants.PROTOCOL_VERSION_1) &#123; flags |= ObjectStreamConstants.SC_BLOCK_DATA; &#125; &#125; else if (serializable) &#123; flags |= ObjectStreamConstants.SC_SERIALIZABLE;// 序列化是001 &#125; if (hasWriteObjectData) &#123; flags |= ObjectStreamConstants.SC_WRITE_METHOD;// 有没有写入其它数据是010 &#125; if (isEnum) &#123; flags |= ObjectStreamConstants.SC_ENUM;// 是不是enum是10000 &#125; out.writeByte(flags);// 将是否是序列化，是否是自定义序列化，是否是枚举，是否有自定义字段需要持久化，标志位写入 out.writeShort(fields.length);// 将要序列化的属性字段的数量写入 for (int i = 0; i &lt; fields.length; i++) &#123; ObjectStreamField f = fields[i]; out.writeByte(f.getTypeCode());// 将要序列化的属性字段的类型（一个字节）写入 out.writeUTF(f.getName());// 将属性字段的名字写入 if (!f.isPrimitive()) &#123;// 如果字段不是原始类型的字段，将该属性字段的类型写入 out.writeTypeString(f.getTypeString()); &#125; &#125;&#125;*/ &#125; Class&lt;?&gt; cl = desc.forClass(); bout.setBlockDataMode(true);// 转换模式成块模式，会将缓存中的字节写到buffer中去 if (cl != null &amp;&amp; isCustomSubclass()) &#123; ReflectUtil.checkPackageAccess(cl); &#125; annotateClass(cl);// 空 bout.setBlockDataMode(false);// 转换模式，会将缓存中的数据写出到buffer bout.writeByte(TC_ENDBLOCKDATA);// 结束该类型描述块的写入 (byte)0x78; writeClassDesc(desc.getSuperDesc(), false);// 将父类的对象描述信息写入&#125; 写入属性字段数据123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172private void writeSerialData(Object obj, ObjectStreamClass desc) throws IOException&#123; ObjectStreamClass.ClassDataSlot[] slots = desc.getClassDataLayout();// 获取当前ObjectStreamClass描述的可序列化的当前类及父类的槽数组 for (int i = 0; i &lt; slots.length; i++) &#123; ObjectStreamClass slotDesc = slots[i].desc;// 拿到第一个可序列化的ObjectStreamClass描述 if (slotDesc.hasWriteObjectMethod()) &#123; PutFieldImpl oldPut = curPut; curPut = null; SerialCallbackContext oldContext = curContext; if (extendedDebugInfo) &#123; debugInfoStack.push( "custom writeObject data (class \"" + slotDesc.getName() + "\")"); &#125; try &#123; curContext = new SerialCallbackContext(obj, slotDesc); bout.setBlockDataMode(true); slotDesc.invokeWriteObject(obj, this); bout.setBlockDataMode(false); bout.writeByte(TC_ENDBLOCKDATA); &#125; finally &#123; curContext.setUsed(); curContext = oldContext; if (extendedDebugInfo) &#123; debugInfoStack.pop(); &#125; &#125; curPut = oldPut; &#125; else &#123; defaultWriteFields(obj, slotDesc);/*private void defaultWriteFields(Object obj, ObjectStreamClass desc) throws IOException&#123; Class&lt;?&gt; cl = desc.forClass(); if (cl != null &amp;&amp; obj != null &amp;&amp; !cl.isInstance(obj)) &#123; throw new ClassCastException(); &#125; desc.checkDefaultSerialize();// 校验是否实现了序列化接口 int primDataSize = desc.getPrimDataSize();// 拿到该class原始数据的字节数 if (primVals == null || primVals.length &lt; primDataSize) &#123; primVals = new byte[primDataSize];// 将存储原始数据的字节数组长度设置成原始数据的字节总数 &#125; // 将所有的原始数据值保存在字节数组primVals中 desc.getPrimFieldValues(obj, primVals); bout.write(primVals, 0, primDataSize, false);// 将原始数据写入输出流中 ObjectStreamField[] fields = desc.getFields(false);// 获取Class的属性字段数组ObjectStreamField Object[] objVals = new Object[desc.getNumObjFields()];// 创建属性字段非原始数据类型的数量的数组 int numPrimFields = fields.length - objVals.length;// 拿到所有原始数据类型的字段数量 desc.getObjFieldValues(obj, objVals);// 将所有非原始数据类型的属性字段保存在objVals对象数组中 for (int i = 0; i &lt; objVals.length; i++) &#123; if (extendedDebugInfo) &#123; debugInfoStack.push( "field (class \"" + desc.getName() + "\", name: \"" + fields[numPrimFields + i].getName() + "\", type: \"" + fields[numPrimFields + i].getType() + "\")"); &#125; try &#123; writeObject0(objVals[i], fields[numPrimFields + i].isUnshared());// 将非原始类型的属性字段以Object序列化的形式写入输出流中 &#125; finally &#123; if (extendedDebugInfo) &#123; debugInfoStack.pop(); &#125; &#125; &#125;&#125;*/ &#125; &#125;&#125; 获取当前类及父类的ObjectStreamClass的槽数组12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758ClassDataSlot[] getClassDataLayout() throws InvalidClassException &#123; // 获取所有当前类及父类可序列化的ObjectStreamClass数组 // REMIND: synchronize instead of relying on volatile? if (dataLayout == null) &#123; dataLayout = getClassDataLayout0(); &#125; return dataLayout;&#125;private ClassDataSlot[] getClassDataLayout0() throws InvalidClassException&#123; ArrayList&lt;ClassDataSlot&gt; slots = new ArrayList&lt;&gt;();// 创建一个集合，用来保存ClassDataSlot Class&lt;?&gt; start = cl, end = cl; while (end != null &amp;&amp; Serializable.class.isAssignableFrom(end)) &#123;// 找到最顶级的不可以序列化的那个父类，保存到end变量中 end = end.getSuperclass(); &#125; HashSet&lt;String&gt; oscNames = new HashSet&lt;&gt;(3);// 保存ObjectStreamClass的set集合 for (ObjectStreamClass d = this; d != null; d = d.superDesc) &#123; if (oscNames.contains(d.name)) &#123; throw new InvalidClassException("Circular reference."); &#125; else &#123; oscNames.add(d.name);// 将当前要序列化的Object的全限定名保存到oscNames集合中 &#125; String searchName = (d.cl != null) ? d.cl.getName() : d.name;// 拿到要序列化的对象的全限定名 Class&lt;?&gt; match = null; // 将要序列化对象的class找到 for (Class&lt;?&gt; c = start; c != end; c = c.getSuperclass()) &#123; if (searchName.equals(c.getName())) &#123; match = c; break; &#125; &#125; // add "no data" slot for each unmatched class below match if (match != null) &#123; // 如果能拿到要序列化对象的class for (Class&lt;?&gt; c = start; c != match; c = c.getSuperclass()) &#123; slots.add(new ClassDataSlot(ObjectStreamClass.lookup(c, true), false)); &#125; start = match.getSuperclass();// 这里的start就变成了class java.lang.Object &#125; // record descriptor/class pairing slots.add(new ClassDataSlot(d.getVariantFor(match), true));// 序列化类的数据槽集合中添加一个新的ClassDataSlot/*static class ClassDataSlot &#123; final ObjectStreamClass desc; final boolean hasData; ClassDataSlot(ObjectStreamClass desc, boolean hasData) &#123; this.desc = desc;// class描述 this.hasData = hasData;// 是否有数据 &#125;&#125;*/ &#125; // add "no data" slot for any leftover unmatched classes for (Class&lt;?&gt; c = start; c != end; c = c.getSuperclass()) &#123; slots.add(new ClassDataSlot( ObjectStreamClass.lookup(c, true), false)); &#125; // order slots from superclass -&gt; subclass Collections.reverse(slots);// 反向排序 return slots.toArray(new ClassDataSlot[slots.size()]);// 将slots的Set集合转换成ClassDataSlot的数组返回&#125; 总结： Object序列化需要生成一个Class的描述信息ObjectStreamClass，以及可序列化的父类描述信息 可序列化类的ObjectStreamClass描述信息，里面存储信息如下 当前类的Class cl 当前类的全限定名称 name 是否是代理 isProxy 是否是枚举 isEnum 是否是自定义序列化 serializable、externalizable 可序列化父类的ObjectStreamClass描述信息 superDesc 当前类的 ObjectStreamClass描述信息 localDesc 可序列化的当前类的属性字段（父类的可序列化属性字段由父类desc保存） fields 原始数据类型的属性字段在对象中的偏移量，及占用字节总数 f.setOffset(primDataSize)，offset保存的是当前原始数据属性在字节数组的下标，primDataSize保存的是原始数据属性占用的字节总数。这些都是保存在ObjectStreamClass里面 非原始数据类型的属性字段在对象中的个数，及第一个非原始数据类型的属性字段在所有属性字段数组中的第几个 f.setOffset(numObjFields++); offset保存的是第几个非原始数据类型的属性，numObjFields保存的是有多少个非原始数据类型的属性字段 父类的构造函数（最顶级不可序列化的父类） writeObject方法 readObject方法 readObjectNoData方法 是否有writeObject方法 writeReplace方法 readResolveMethod方法 FieldReflector对象，里面储存信息如下： 当前类可序列化属性字段 fields 当前类可序列化属性字段数目 nfields 属性字段内存地址偏移量 readKeys 属性字段内存地址偏移量 writeKeys 属性字段字节数组偏移量 offsets 属性字段类型 typeCodes 非原始数据类型属性字段的全限定名称 types 原始数据类型属性字段的数量 numPrimFields 写入数据之类描述信息 对象的全限定名称 序列化版本号 是否是自定义序列化、有没有writeObject方法、是否是枚举类型 可序列化属性字段的数量 属性字段的字符类型 属性字段的名称 非原始属性字段的类型全限定名 可序列化父类的类型描述信息 写入数据之属性字段值 生成一个ClassDataSlot数组，里面保存当前类及父类的ObjectStreamClass描述信息 写入原始数据属性字段的值，临时字节数组primVals 从FieldReflector中拿到原始数据类型的类型字符（typeCode[i]），判断需要写入的字节长度 拿出属性字段的字节数组偏移量offsets[i] 根据内存地址偏移量（readKeys[i]）拿出字段值 写入字节数组primVals中 将字节数组写入到持久化输出流中 写入非原始数据属性字段的值，临时对象数组vals[] 从FieldReflector中拿到非原始数据类型的属性字段，从原始数据类型的数量作为下标从fields中拿到非原始数据类型的ObjectStreamField值 从typeCodes[numPrimFields++]中拿出非原始属性字段的字符类型 从offsets[numPrimFields++]中拿出非原始数据属性Field的offset值，offset[numPrimFields]值是从0开始++的 从readKeys[i]拿到非原始数据类型的属性字段的内存地址偏移量 vals[offsets[i]]设置上对象的引用 遍历vals[]非原始数据类型属性，然后再将该对象按照序列化对象的步骤写入到持久化输出流中 Object反序列化1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798public final Object readObject() throws IOException, ClassNotFoundException&#123; if (enableOverride) &#123; return readObjectOverride(); &#125; int outerHandle = passHandle; try &#123; Object obj = readObject0(false); handles.markDependency(outerHandle, passHandle); ClassNotFoundException ex = handles.lookupException(passHandle); if (ex != null) &#123; throw ex; &#125; if (depth == 0) &#123; vlist.doCallbacks(); &#125; return obj; &#125; finally &#123; passHandle = outerHandle; if (closed &amp;&amp; depth == 0) &#123; clear(); &#125; &#125;&#125;private Object readObject0(boolean unshared) throws IOException &#123; // 将对象从输入流中读取并转换 boolean oldMode = bin.getBlockDataMode(); if (oldMode) &#123; int remain = bin.currentBlockRemaining(); if (remain &gt; 0) &#123; throw new OptionalDataException(remain); &#125; else if (defaultDataEnd) &#123; throw new OptionalDataException(true); &#125; bin.setBlockDataMode(false); &#125; byte tc; while ((tc = bin.peekByte()) == TC_RESET) &#123;// 拿出第一个字节出来 bin.readByte(); handleReset(); &#125; depth++; try &#123; switch (tc) &#123; case TC_NULL: return readNull(); case TC_REFERENCE: return readHandle(unshared); case TC_CLASS: return readClass(unshared); case TC_CLASSDESC: case TC_PROXYCLASSDESC: return readClassDesc(unshared); case TC_STRING: case TC_LONGSTRING: return checkResolve(readString(unshared)); case TC_ARRAY: return checkResolve(readArray(unshared)); case TC_ENUM: return checkResolve(readEnum(unshared)); case TC_OBJECT: return checkResolve(readOrdinaryObject(unshared));// 如果读取的是Object对象 case TC_EXCEPTION: IOException ex = readFatalException(); throw new WriteAbortedException("writing aborted", ex); case TC_BLOCKDATA: case TC_BLOCKDATALONG: if (oldMode) &#123; bin.setBlockDataMode(true); bin.peek(); // force header read throw new OptionalDataException(bin.currentBlockRemaining()); &#125; else &#123; throw new StreamCorruptedException("unexpected block data"); &#125; case TC_ENDBLOCKDATA: if (oldMode) &#123; throw new OptionalDataException(true); &#125; else &#123; throw new StreamCorruptedException("unexpected end of block data"); &#125; default: throw new StreamCorruptedException(String.format("invalid type code: %02X", tc)); &#125; &#125; finally &#123; depth--; bin.setBlockDataMode(oldMode); &#125;&#125; 读取数据并返回Object对象123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173private Object readOrdinaryObject(boolean unshared) throws IOException&#123; if (bin.readByte() != TC_OBJECT) &#123;// 开始拿出一个字节判断是否是Object对象流 throw new InternalError(); &#125; ObjectStreamClass desc = readClassDesc(false);// 读取ObjectStreamClass对象描述信息 desc.checkDeserialize(); Class&lt;?&gt; cl = desc.forClass(); if (cl == String.class || cl == Class.class || cl == ObjectStreamClass.class) &#123; throw new InvalidClassException("invalid class descriptor"); &#125; Object obj; try &#123; obj = desc.isInstantiable() ? desc.newInstance() : null;// 创建Object实例，通过构造函数 &#125; catch (Exception ex) &#123; throw (IOException) new InvalidClassException(desc.forClass().getName(),"unable to create instance").initCause(ex); &#125; passHandle = handles.assign(unshared ? unsharedMarker : obj); ClassNotFoundException resolveEx = desc.getResolveException(); if (resolveEx != null) &#123; handles.markException(passHandle, resolveEx); &#125; if (desc.isExternalizable()) &#123; readExternalData((Externalizable) obj, desc); &#125; else &#123; readSerialData(obj, desc);// 读取属性字段的值/*private void readSerialData(Object obj, ObjectStreamClass desc) throws IOException&#123; ObjectStreamClass.ClassDataSlot[] slots = desc.getClassDataLayout();// 拿到当前类及父类的类描述 for (int i = 0; i &lt; slots.length; i++) &#123; ObjectStreamClass slotDesc = slots[i].desc; if (slots[i].hasData) &#123; if (obj == null || handles.lookupException(passHandle) != null) &#123; defaultReadFields(null, slotDesc); // skip field values &#125; else if (slotDesc.hasReadObjectMethod()) &#123; SerialCallbackContext oldContext = curContext; if (oldContext != null) oldContext.check(); try &#123; curContext = new SerialCallbackContext(obj, slotDesc); bin.setBlockDataMode(true); slotDesc.invokeReadObject(obj, this); &#125; catch (ClassNotFoundException ex) &#123; handles.markException(passHandle, ex); &#125; finally &#123; curContext.setUsed(); if (oldContext!= null) oldContext.check(); curContext = oldContext; &#125; defaultDataEnd = false; &#125; else &#123; defaultReadFields(obj, slotDesc);// 默认读取属性字段的值 &#125; if (slotDesc.hasWriteObjectData()) &#123; skipCustomData(); &#125; else &#123; bin.setBlockDataMode(false); &#125; &#125; else &#123; if (obj != null &amp;&amp; slotDesc.hasReadObjectNoDataMethod() &amp;&amp; handles.lookupException(passHandle) == null)&#123; slotDesc.invokeReadObjectNoData(obj); &#125; &#125; &#125;&#125;private void defaultReadFields(Object obj, ObjectStreamClass desc) throws IOException&#123; Class&lt;?&gt; cl = desc.forClass();// 拿到类的Class if (cl != null &amp;&amp; obj != null &amp;&amp; !cl.isInstance(obj)) &#123; throw new ClassCastException(); &#125; int primDataSize = desc.getPrimDataSize();// 获取原始数据字节长度 if (primVals == null || primVals.length &lt; primDataSize) &#123; primVals = new byte[primDataSize];// 创建原始数据字节长度的数组 &#125; bin.readFully(primVals, 0, primDataSize, false);// 读取原始数据字节长度的值，放入到字节数组中 if (obj != null) &#123; desc.setPrimFieldValues(obj, primVals);// 将原始数据的值放入对象属性字段上 &#125; int objHandle = passHandle; ObjectStreamField[] fields = desc.getFields(false);// 获取所有属性字段 Object[] objVals = new Object[desc.getNumObjFields()];// 创建一个非原始数据类型的属性字段个数的数组 int numPrimFields = fields.length - objVals.length; for (int i = 0; i &lt; objVals.length; i++) &#123; ObjectStreamField f = fields[numPrimFields + i]; objVals[i] = readObject0(f.isUnshared());// 开始读取非原始数据属性字段的值，跟读取要序列化对象的方式一样 if (f.getField() != null) &#123; handles.markDependency(objHandle, passHandle); &#125; &#125; if (obj != null) &#123; desc.setObjFieldValues(obj, objVals);// 对每个非原始数据类型的属性字段赋值 &#125; passHandle = objHandle;&#125;void setPrimFieldValues(Object obj, byte[] buf) &#123; fieldRefl.setPrimFieldValues(obj, buf);// 使用的是ObjectStreamClass中的FieldReflector&#125;void setPrimFieldValues(Object obj, byte[] buf) &#123; for (int i = 0; i &lt; numPrimFields; i++) &#123;// 拿到原始数据属性的数量 long key = writeKeys[i];// 该属性字段的对象内存的偏移量 if (key == Unsafe.INVALID_FIELD_OFFSET) &#123; continue; // discard value &#125; int off = offsets[i];// 在数组哪个下标开始读取字节 switch (typeCodes[i]) &#123;// 判断原始数据类型 case 'Z': unsafe.putBoolean(obj, key, Bits.getBoolean(buf, off)); break; case 'B': unsafe.putByte(obj, key, buf[off]); break; case 'C': unsafe.putChar(obj, key, Bits.getChar(buf, off)); break; case 'S': unsafe.putShort(obj, key, Bits.getShort(buf, off)); break; case 'I': unsafe.putInt(obj, key, Bits.getInt(buf, off)); break; case 'F': unsafe.putFloat(obj, key, Bits.getFloat(buf, off)); break; case 'J': unsafe.putLong(obj, key, Bits.getLong(buf, off)); break; case 'D': unsafe.putDouble(obj, key, Bits.getDouble(buf, off)); break; default: throw new InternalError(); &#125; &#125;&#125;void setObjFieldValues(Object obj, Object[] vals) &#123; fieldRefl.setObjFieldValues(obj, vals);// 非原始属性字段的赋值也是通过FieldReflector实现的&#125;void setObjFieldValues(Object obj, Object[] vals) &#123; for (int i = numPrimFields; i &lt; fields.length; i++) &#123; long key = writeKeys[i]; // 该属性字段的对象内存的偏移量 if (key == Unsafe.INVALID_FIELD_OFFSET) &#123; continue; &#125; switch (typeCodes[i]) &#123; case 'L': case '[': Object val = vals[offsets[i]];// offsets[i]中保存的是第几个（从0开始）非原始数据类型的属性字段 if (val != null &amp;&amp; !types[i - numPrimFields].isInstance(val))&#123; Field f = fields[i].getField(); throw new ClassCastException("cannot assign instance of " + val.getClass().getName() + " to field " + f.getDeclaringClass().getName() + "." + f.getName() + " of type " + f.getType().getName() + " in instance of " + obj.getClass().getName()); &#125; unsafe.putObject(obj, key, val); break; default: throw new InternalError(); &#125; &#125;&#125;*/ &#125; handles.finish(passHandle); if (obj != null &amp;&amp; handles.lookupException(passHandle) == null &amp;&amp; desc.hasReadResolveMethod())&#123;// 如果实现了readResolve方法，直接通过反射调用获取对象即可 Object rep = desc.invokeReadResolve(obj); if (unshared &amp;&amp; rep.getClass().isArray()) &#123; rep = cloneArray(rep); &#125; if (rep != obj) &#123; handles.setObject(passHandle, obj = rep); &#125; &#125; return obj;&#125; 读取对象描述信息（readDesc）并将本地对象描述信息localDesc拷贝到readDesc中123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106private ObjectStreamClass readClassDesc(boolean unshared) throws IOException&#123; byte tc = bin.peekByte();// 拿出一个字节来判断，是否是对象描述信息流 switch (tc) &#123; case TC_NULL: return (ObjectStreamClass) readNull(); case TC_REFERENCE: return (ObjectStreamClass) readHandle(unshared); case TC_PROXYCLASSDESC: return readProxyDesc(unshared); case TC_CLASSDESC: return readNonProxyDesc(unshared);// 开始读取对象描述信息ObjectStreamClass default: throw new StreamCorruptedException( String.format("invalid type code: %02X", tc)); &#125;&#125;private ObjectStreamClass readNonProxyDesc(boolean unshared) throws IOException&#123; if (bin.readByte() != TC_CLASSDESC) &#123;// 再次校验一下，是否是对象描述信息 throw new InternalError(); &#125; ObjectStreamClass desc = new ObjectStreamClass(); int descHandle = handles.assign(unshared ? unsharedMarker : desc); passHandle = NULL_HANDLE; ObjectStreamClass readDesc = null; try &#123; readDesc = readClassDescriptor();// 解析输入流中的文件描述信息 &#125; catch (ClassNotFoundException ex) &#123; throw (IOException) new InvalidClassException("failed to read class descriptor").initCause(ex); &#125; Class&lt;?&gt; cl = null; ClassNotFoundException resolveEx = null; bin.setBlockDataMode(true); final boolean checksRequired = isCustomSubclass(); try &#123; if ((cl = resolveClass(readDesc)) == null) &#123; resolveEx = new ClassNotFoundException("null class"); &#125; else if (checksRequired) &#123; ReflectUtil.checkPackageAccess(cl); &#125; &#125; catch (ClassNotFoundException ex) &#123; resolveEx = ex; &#125; skipCustomData(); desc.initNonProxy(readDesc, cl, resolveEx, readClassDesc(false));// 初始化对象描述/*void initNonProxy(ObjectStreamClass model,Class&lt;?&gt; cl,ClassNotFoundException resolveEx,ObjectStreamClass superDesc) throws InvalidClassException&#123; this.cl = cl;// 将object的class保存起来 this.resolveEx = resolveEx; this.superDesc = superDesc;// 将父类的对象描述保存起来 name = model.name;// 类名称 suid = Long.valueOf(model.getSerialVersionUID());// 版本号 isProxy = false;// 非代理 isEnum = model.isEnum;// 非枚举 serializable = model.serializable;// 是否是常规序列化 externalizable = model.externalizable;// 是否是自定义序列化 hasBlockExternalData = model.hasBlockExternalData;// 是否有其它序列化数据 hasWriteObjectData = model.hasWriteObjectData;// 是否重写writeObject方法 fields = model.fields;// 属性字段 primDataSize = model.primDataSize;// 原始数据字段字节总数 numObjFields = model.numObjFields;// 非原始数据字段数量 if (cl != null) &#123; localDesc = lookup(cl, true);// 查找class对应的对象描述信息 if (localDesc.isProxy) &#123; throw new InvalidClassException("cannot bind non-proxy descriptor to a proxy class"); &#125; if (isEnum != localDesc.isEnum) &#123; throw new InvalidClassException(isEnum ? "cannot bind enum descriptor to a non-enum class" :"cannot bind non-enum descriptor to an enum class"); &#125; if (serializable == localDesc.serializable &amp;&amp; !cl.isArray() &amp;&amp; suid.longValue() != localDesc.getSerialVersionUID())&#123;// 如果序列化方式一样，版本号一样才可以反序列化 throw new InvalidClassException(localDesc.name,"local class incompatible: " + "stream classdesc serialVersionUID = " + suid + ", local class serialVersionUID = " + localDesc.getSerialVersionUID()); &#125; if (!classNamesEqual(name, localDesc.name)) &#123; throw new InvalidClassException(localDesc.name,"local class name incompatible with stream class " + "name \"" + name + "\""); &#125; if (!isEnum) &#123;// 如果不是枚举类型的,校验序列化类型 if ((serializable == localDesc.serializable) &amp;&amp; (externalizable != localDesc.externalizable))&#123; throw new InvalidClassException(localDesc.name,"Serializable incompatible with Externalizable"); &#125; if ((serializable != localDesc.serializable) || (externalizable != localDesc.externalizable) || !(serializable || externalizable)) &#123; deserializeEx = new ExceptionInfo(localDesc.name, "class invalid for deserialization"); &#125; &#125; cons = localDesc.cons;// 将构造函数保存到ObjectStreamClass中 writeObjectMethod = localDesc.writeObjectMethod;// 写入方法赋值 readObjectMethod = localDesc.readObjectMethod; // 读取方法赋值 readObjectNoDataMethod = localDesc.readObjectNoDataMethod; writeReplaceMethod = localDesc.writeReplaceMethod;// writeReplace方法赋值 readResolveMethod = localDesc.readResolveMethod;// readResolve方法赋值 if (deserializeEx == null) &#123; deserializeEx = localDesc.deserializeEx; &#125; &#125; fieldRefl = getReflector(fields, localDesc);// FieldReflector赋值 fields = fieldRefl.getFields();// Fields赋值&#125;*/ handles.finish(descHandle); passHandle = descHandle; return desc;&#125; 获取序列化信息中的对象描述信息123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110protected ObjectStreamClass readClassDescriptor() throws IOException, ClassNotFoundException&#123; ObjectStreamClass desc = new ObjectStreamClass(); desc.readNonProxy(this);// 获取对象描述信息 return desc;&#125;void readNonProxy(ObjectInputStream in) throws IOException, ClassNotFoundException&#123; name = in.readUTF();// 获取类名称 suid = Long.valueOf(in.readLong());// 获取类的序列化编号 isProxy = false; byte flags = in.readByte();// 拿出标志位进行校验 hasWriteObjectData = ((flags &amp; ObjectStreamConstants.SC_WRITE_METHOD) != 0);// 是否有writeObject方法 hasBlockExternalData = ((flags &amp; ObjectStreamConstants.SC_BLOCK_DATA) != 0);// 是否有其它序列化数据 externalizable = ((flags &amp; ObjectStreamConstants.SC_EXTERNALIZABLE) != 0);// 是否是自定义序列化 boolean sflag = ((flags &amp; ObjectStreamConstants.SC_SERIALIZABLE) != 0);// 是否是常规序列化 if (externalizable &amp;&amp; sflag) &#123;// 不允许既是常规序列化，又是自定义序列化 throw new InvalidClassException(name, "serializable and externalizable flags conflict"); &#125; serializable = externalizable || sflag; isEnum = ((flags &amp; ObjectStreamConstants.SC_ENUM) != 0);// 判断是否是枚举 if (isEnum &amp;&amp; suid.longValue() != 0L) &#123;// 枚举不允许有序列化版本号 throw new InvalidClassException(name,"enum descriptor has non-zero serialVersionUID: " + suid); &#125; int numFields = in.readShort();// 读取有多少个属性字段 if (isEnum &amp;&amp; numFields != 0) &#123;// 如果是枚举不允许有属性字段 throw new InvalidClassException(name,"enum descriptor has non-zero field count: " + numFields); &#125; fields = (numFields &gt; 0) ? new ObjectStreamField[numFields] : NO_FIELDS;// 创建ObjectStreamField数组用于保存描述信息 for (int i = 0; i &lt; numFields; i++) &#123;// 遍历字段描述信息 char tcode = (char) in.readByte(); String fname = in.readUTF();// 字段名称 String signature = ((tcode == 'L') || (tcode == '[')) ? in.readTypeString() : new String(new char[] &#123; tcode &#125;);// 字段类型。非原始数据类型，直接读取属性字段类型，原始数据类型就保存属性字段的字符类型 try &#123; fields[i] = new ObjectStreamField(fname, signature, false);// 生成一个该属性字段的ObjectStreamField描述信息/*ObjectStreamField(String name, String signature, boolean unshared) &#123; if (name == null) &#123; throw new NullPointerException(); &#125; this.name = name;// 保存名字 this.signature = signature.intern();// 保存类型或字符类型 this.unshared = unshared; field = null; switch (signature.charAt(0)) &#123;// 判断字段类型，保存字段类型到type上 case 'Z': type = Boolean.TYPE; break; case 'B': type = Byte.TYPE; break; case 'C': type = Character.TYPE; break; case 'S': type = Short.TYPE; break; case 'I': type = Integer.TYPE; break; case 'J': type = Long.TYPE; break; case 'F': type = Float.TYPE; break; case 'D': type = Double.TYPE; break; case 'L': case '[': type = Object.class; break; default: throw new IllegalArgumentException("illegal signature"); &#125;&#125;*/ &#125; catch (RuntimeException e) &#123; throw (IOException) new InvalidClassException(name,"invalid descriptor for field " + fname).initCause(e); &#125; &#125; computeFieldOffsets();// 计算属性字段的偏移量/*private void computeFieldOffsets() throws InvalidClassException &#123; primDataSize = 0; numObjFields = 0; int firstObjIndex = -1; for (int i = 0; i &lt; fields.length; i++) &#123; ObjectStreamField f = fields[i]; switch (f.getTypeCode()) &#123;// 判断属性字段的类型，从signature.charAt(0)获取 case 'Z': case 'B': f.setOffset(primDataSize++); break; case 'C': case 'S': f.setOffset(primDataSize); primDataSize += 2; break; case 'I': case 'F': f.setOffset(primDataSize); primDataSize += 4; break; case 'J': case 'D': f.setOffset(primDataSize); primDataSize += 8; break; case '[': case 'L': f.setOffset(numObjFields++); if (firstObjIndex == -1) &#123; firstObjIndex = i; &#125; break; default: throw new InternalError(); &#125; &#125; if (firstObjIndex != -1 &amp;&amp; firstObjIndex + numObjFields != fields.length)&#123; throw new InvalidClassException(name, "illegal field order"); &#125;&#125;*/&#125; 总结：获取对象的文件描述信息 创建一个ObjectStreamClass对象，变量名desc 创建一个ObjectStreamClass对象，变量名readDesc，表示是读取出来的文件描述信息 对象全名称 name 对象版本号 suid 有没有writeObject方法 hasWriteObjectData 有没有额外数据写入 hasBlockExternalData 是否是自定义序列化 externalizable 是否是常规序列化 serializable 是否是枚举 isEnum 属性字段数量 numFields 属性字段名称 fname 属性字段类型 tcode 非原始数据字段类型全称 signature 原始数据字段字节数量 primDataSize 非原始数据字段数量 numObjFields 生成ObjectStreamField对象 name：属性字段名称 signature：字段类型名称 type： 字段类型 offset：原始数据类型字段保存的是字节下标，非原始数据类型字段保存的是第几个非原始数据字段（从0开始） 调用desc.initNonProxy(readDesc, cl, resolveEx, readClassDesc(false));//readClassDesc(false)是获取父类的class描述信息 赋值class字段 cl是通过readDesc.name获取的 赋值resolveEx字段 赋值superDesc 是调用方法之前就读取到的父类的描述信息 赋值name 类名称（从readDesc获取） 赋值suid 版本号（从readDesc获取） 赋值isProxy 是否是代理类（从readDesc获取） 赋值isEnum 是否是枚举类（从readDesc获取） 赋值serializable 是否是常规序列化类（从readDesc获取） 赋值externalizable 是否是自定义序列化类（从readDesc获取） 赋值hasWriteObjectData 是否有额外数据序列化（从readDesc获取） 赋值fields 属性字段（从readDesc获取） 赋值primDataSize 原始数据字段字节数（从readDesc获取） 赋值numObjFields 非原始数据字段数量（从readDesc获取） 根据class获取本服务器中对该类的描述信息，赋值给localDesc 校验readDesc和localDesc的区别 赋值cons 构造函数（从localDesc获取） 赋值writeObjectMethod （从localDesc获取） 赋值readObjectMethod （从localDesc获取） 赋值readObjectNoDataMethod （从localDesc获取） 赋值writeReplaceMethod （从localDesc获取） 赋值readResolveMethod （从localDesc获取） 赋值deserializeEx （从localDesc获取） 赋值fieldRefl （从localDesc获取）//getReflector(readFields, localDesc); 因为之前调用过lookup(cl)，所以缓存中已经有这个fieldReflector了，直接就从缓存中拿了 重新赋值fields （从fieldRefl获取） 创建Object对象，通过cons.newInstance() 从输入流中获取原始数据类型的属性字节数据，保存在primVals字节数组中 通过fieldReflector，将原始数据类型的字节数组数据写入到指定的原始数据内存偏移量地址上 从输入流中读取非原始数据类型属性字段（Object类型的反序列化）,保存到objVals数组中 通过fieldReflector，将非原始数据类型的数据保存到指定内存偏移地址上 Serializable序列化demo123456789101112131415161718192021public static class Person implements Serializable &#123; // 控制哪些字段需要序列化，使用serialPersistentFields属性 // private static final ObjectStreamField[] serialPersistentFields = new ObjectStreamField[]&#123;new ObjectStreamField("name", String.class)&#125;; // 序列化编号，必须有 private static final long serialVersionUID = 6663004828040541458L; private int age; private String name; private transient String value;// transient修饰的属性不会被默认序列化 private Date date; private static String version = "1.0"; private void writeObject(ObjectOutputStream out) throws IOException &#123; out.defaultWriteObject();// 默认序列化属性字段 out.writeObject(value + " is transient"); &#125; private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException &#123; in.defaultReadObject();// 默认读取输入流序列化数据 value = (String) in.readObject(); &#125;&#125; Externalizable序列化demo1234567891011121314151617181920212223242526272829303132333435363738394041424344public static class User implements Externalizable &#123; private static final long serialVersionUID = 6663004828040541458L; private int age; private String name; private String value; private Date date; private static String version = "1.0"; @Override public void writeExternal(ObjectOutput out) throws IOException &#123; out.writeInt(age); out.writeObject(name); out.writeObject(value); out.writeObject(date); out.writeObject(version); &#125; @Override public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException &#123; this.age = in.readInt(); this.name = (String) in.readObject(); this.value = (String) in.readObject(); this.date = (Date) in.readObject(); version = (String) in.readObject(); &#125; public Object readResolve() &#123; User user = new User(); user.name = "lisi"; user.age = 28; user.date = new Date(); user.value = "abcd"; return user; &#125; private Object writeReplace()&#123;// 替换成别的Object序列化 Person p = new Person(); p.age=11; p.name="wangwu"; p.value="dddd"; p.date=new Date(); return p; &#125;&#125; Main调用demo1234567891011121314151617public static void main(String[] args) throws Exception &#123; File file = new File("D:/private/serialize1.txt"); User p = new User(); p.name = "zhangsan1"; p.value = "123"; p.age = 21; p.date = new Date(); p.version = "1.1"; ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(file)); out.writeObject(p); out.close(); p.version = "3.0"; ObjectInputStream in = new ObjectInputStream(new FileInputStream(file)); Person p2 = (Person) in.readObject();// 序列化的对象已经替换成了Person对象 System.out.println(p2.name + "," + p2.value + "," + p2.age + "," + "," + p2.date + "," + p2.version);&#125;]]></content>
      <categories>
        <category>源码解读</category>
      </categories>
      <tags>
        <tag>ObjectStreamClass</tag>
        <tag>ObjectStreamField</tag>
        <tag>FieldReflector</tag>
        <tag>序列化和反序列化</tag>
        <tag>Serializable</tag>
        <tag>Externalizable</tag>
        <tag>readResolve</tag>
        <tag>writeObject</tag>
        <tag>readObject</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[强软弱虚引用及ThreadLocal源码解读]]></title>
    <url>%2F2018%2F01%2F13%2F2018-01-13%E5%BC%BA%E8%BD%AF%E5%BC%B1%E8%99%9A%E5%BC%95%E7%94%A8%E5%8F%8AThreadLocal%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%2F</url>
    <content type="text"><![CDATA[Java中的各种引用强引用：StrongReference强引用是我们最常使用的引用类型，如果对象是一个强引用，则垃圾回收器不会在它的生命周期中对它进行垃圾回收 软引用：SoftReference如果一个对象只有一个软引用，没有强引用存在，那么在内存不足时，不管这个对象的生命周期，就会将该对象进行垃圾回收 弱引用：WeekReferce只具有弱引用的对象拥有更短的生命周期，如果垃圾回收过程中，发现对象强引用的生命周期结束，只具有弱引用，那就会立即将该对象内存回收掉 如果你不想介入一个对象的生命周期，那么就使用弱引用，比如ThreadLocal就使用的这种弱引用 虚引用：PhantomReference如果一个对象只有一个徐引用，那么这个对象就形同虚设，虚引用并不会决定对象的生命周期。如果该对象只有一个虚引用，在垃圾回收器执行回收操作的时候就会立刻将它进行回收，可以用来跟踪垃圾回收的活动 虚引用必须与引用队列（ReferenceQueue）联合使用，如果垃圾回收器在回收对象之前，发现对象还有虚引用，就会将虚引用放入与之关联的引用队列中 ThreadLocal源码解读1234567891011public void set(T value) &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t);// 每个线程都会持有一个ThreadLocal.ThreadLocalMap对象/*ThreadLocalMap getMap(Thread t) &#123;// Thread中的 return t.threadLocals;&#125;*/ if (map != null) map.set(this, value);// 拿到thread持有的私有Map对象，将该ThreadLocal当做Key，传入的value当做值保存起来 else createMap(t, value);&#125; 每个线程都会持有一个ThreadLocal.ThreadLocalMap对象，这个对象可以将当前的ThreadLocal对象当做key，保存其对应的Object，也就是说一个线程执行过程中，可以创建N多个ThreadLocal对象，使用ThreadLocal(A)对象保存的数据必须使用ThreadLocal(A)去获取，其它的ThreadLocal(B)是获取不到的 12345678910111213141516171819202122232425262728293031private void set(ThreadLocal&lt;?&gt; threadLocal, Object value) &#123;// Thread.threadLocals===ThreadLocal.ThreadLocalMap中的 Entry[] tab = table;// 每个线程的threadLocals====ThreadLocal.ThreadLocalMap对象都会有一个table数组，用于保存不同的 ThreadLocal对象与其对应的ObjectValue对象 int len = tab.length; int i = threadLocal.threadLocalHashCode &amp; (len-1);// 将当前ThreadLocal对象的hashCode与数组长度进行与操作，获取应保存的数组下标位置/*private final int threadLocalHashCode = nextHashCode();private static AtomicInteger nextHashCode = new AtomicInteger();private static int nextHashCode() &#123; return nextHashCode.getAndAdd(HASH_INCREMENT);&#125;*/ for (Entry e = tab[i]; e != null; e = tab[i = nextIndex(i, len)]) &#123;// 拿到下一个数组下标对应的Entry，如果Entry为null，就跳出循环/*private static int nextIndex(int i, int len) &#123; return ((i + 1 &lt; len) ? i + 1 : 0);// 将数组下标加一右移&#125;*/ ThreadLocal&lt;?&gt; k = e.get(); if (k == threadLocal) &#123;// 如果ThreadLocal相同，直接覆盖对应的value值就可以了 e.value = value; return; &#125; if (k == null) &#123;// 如果拿到一个ThreadLocal已被回收的Entry，直接复用 replaceStaleEntry(threadLocal, value, i); return; &#125; &#125; // 如果没有找到相同的ThreadLocal或者一个可以复用的Entry，那只能重新创建一个Entry了,创建好之后放到对应的i下标的空位置上 tab[i] = new Entry(threadLocal, value); int sz = ++size;// 更新数组长度 if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)// 如果生命周期结束的ThreadLocal被清理，并且数组元素个数大于阀值了，就需要对数组进行扩容 rehash();&#125; 替换key是null的节点，清除key是null的节点，整理位置不对的节点12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879private void replaceStaleEntry(ThreadLocal&lt;?&gt; key, Object value,int staleSlot) &#123;// 如果后面找不到key值相同的Entry，就替换这个key问null的Entry；随后是清理key为null的节点和整理位置不对的节点 Entry[] tab = table; int len = tab.length; Entry e; int slotToExpunge = staleSlot;// 需要覆盖的数组下标 for (int i = prevIndex(staleSlot, len);// 向前找一个key是null的Entry，直到遇到null节点，不一定找的到哦 (e = tab[i]) != null; i = prevIndex(i, len)) if (e.get() == null) slotToExpunge = i; for (int i = nextIndex(staleSlot, len);// 向后找，如果能找到key值相等的，直接替换旧可以了 (e = tab[i]) != null; i = nextIndex(i, len)) &#123; ThreadLocal&lt;?&gt; k = e.get(); if (k == key) &#123; // 找到一个key值相等的Entry，直接将那个Entry与当前需要替换的key为null的Entry交换位置 e.value = value; tab[i] = tab[staleSlot]; tab[staleSlot] = e; if (slotToExpunge == staleSlot)// 如果上面没找到key是null的节点，就把i（现在已经是key为null的节点了）赋值给它 slotToExpunge = i; cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);// 先是清除key是null的节点，移动位置不正确的Entry（expungeStaleEntry），然后再随便循环至少logN次（没key是null的Entry可清除的情况下）清除其它的key是null的Entry（expungeStaleEntry） return; &#125; if (k == null &amp;&amp; slotToExpunge == staleSlot)// 如果向后找，找到一个key是null的Entry，只要前面的循环没找到key是null的Entry，那么将slotToExpunge赋值为当前的key是null的下标 slotToExpunge = i; &#125; tab[staleSlot].value = null;// 如果没找到key相等的Entry，只好将这个key是null的Entry替换了 tab[staleSlot] = new Entry(key, value); if (slotToExpunge != staleSlot) // 不管是向前还是向后，只要找到了key是null的其它节点，清除一下 cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);&#125;// 随便循环logN次，清除key是null的节点数据private boolean cleanSomeSlots(int i, int n) &#123;// 从i下标之后开始，清除key是null的Entry，之后再移动下标位置不对的Entry boolean removed = false; Entry[] tab = table; int len = tab.length;// 数组长度 do &#123;// 遍历logN次，如果碰到key为null的需要清除的节点，再遍历logN次 i = nextIndex(i, len);// 一个一个的去找 Entry e = tab[i]; if (e != null &amp;&amp; e.get() == null) &#123;// 如果找到Key为null的节点，擦除这个节点，然后找到之后的空位置的下标，赋值给i n = len; removed = true; i = expungeStaleEntry(i); &#125; &#125; while ( (n &gt;&gt;&gt;= 1) != 0);// n=n/2 = 0 return removed;// 有节点被清除&#125;// 清除下标值是staleSlot的节点，并清理其之后的key是null的节点，和整理位置不正确的节点private int expungeStaleEntry(int staleSlot) &#123; Entry[] tab = table; int len = tab.length; tab[staleSlot].value = null; tab[staleSlot] = null; size--; Entry e; int i; for (i = nextIndex(staleSlot, len);// 继续向后查找数组下标Entry，碰到null节点就跳出循环 (e = tab[i]) != null; i = nextIndex(i, len)) &#123; ThreadLocal&lt;?&gt; k = e.get(); if (k == null) &#123;// 如果碰到key是null的Entry，清空 e.value = null; tab[i] = null; size--; &#125; else &#123; int h = k.threadLocalHashCode &amp; (len - 1);// 计算ThreadLocal对应的下标值，如果计算出来的下标值与现在的不一致，清除这个位置的Entry。从它计算出来的位置向后找，直到找到一个空的位置，将它放到那个位置（有可能还是放到这个地方吧！） if (h != i) &#123; tab[i] = null; while (tab[h] != null) h = nextIndex(h, len); tab[h] = e; &#125; &#125; &#125; return i;// 返回之后的一个空位置的下标值&#125; 数组扩容12345678910111213141516171819202122232425262728293031323334353637383940private void rehash() &#123; expungeStaleEntries();/*private void expungeStaleEntries() &#123; Entry[] tab = table; int len = tab.length; for (int j = 0; j &lt; len; j++) &#123; Entry e = tab[j]; if (e != null &amp;&amp; e.get() == null) expungeStaleEntry(j);// 清理key是null的节点并顺表整理位置不正确的节点 &#125;&#125;*/ if (size &gt;= threshold - threshold / 4)// 如果元素个数达到0.75倍的阀值（2/3的数组长度）了 resize();&#125;// 扩容数组并迁移数据private void resize() &#123; Entry[] oldTab = table; int oldLen = oldTab.length; int newLen = oldLen * 2; // 数组扩容两倍 Entry[] newTab = new Entry[newLen]; int count = 0; for (int j = 0; j &lt; oldLen; ++j) &#123; Entry e = oldTab[j]; if (e != null) &#123; ThreadLocal&lt;?&gt; k = e.get(); if (k == null) &#123; e.value = null; // Help the GC &#125; else &#123; int h = k.threadLocalHashCode &amp; (newLen - 1); while (newTab[h] != null) h = nextIndex(h, newLen); newTab[h] = e; count++; &#125; &#125; &#125; setThreshold(newLen); size = count; table = newTab;&#125; 总结： 每个Thread线程都会拥有一个叫threadLocals的属性，该属性是ThreadLocal.ThreadLocalMap的对象，该对象中使用数组保存这个线程所有的ThreadLocal及对应的Value值（Entry），ThreadLocal使用的是弱引用，如果ThreadLocal强引用的生命周期结束，该Entry也就会被回收掉 ThreadLocalMap使用一个数组当做环形队列来存储新进来的ThreadLocal及对应的Object的value值，维护起来有些复杂 ThreadLocal改进1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public static void main(String[] args) throws Exception &#123; ReferenceQueue&lt;Object&gt; rq = new ReferenceQueue&lt;&gt;(); ThreadLocal&lt;Object&gt; ThreadLocal = new ThreadLocal&lt;Object&gt;(); String value2 = new String("dddddd"); PhantomReference&lt;Object&gt; p3 = new PhantomReference&lt;Object&gt;(value2, rq); PhantomReference&lt;Object&gt; p4 = new PhantomReference&lt;Object&gt;(ThreadLocal, rq); ThreadLocal.set(value2); value2 = null; // ThreadLocal2.remove();//如果不调用这个方法的话，value2不会被回收，还是会在Entry的value上保存着，等待下一个ThreadLocal操作的时候才有可能将value彻底回收 ThreadLocal = null; System.gc(); Thread.sleep(3000); printQueue(1, rq); MyThreadLocal&lt;String&gt; threadLoca2 = new MyThreadLocal&lt;&gt;(); String value = new String("abc"); threadLoca2.setObj(value); PhantomReference&lt;Object&gt; p1 = new PhantomReference&lt;Object&gt;(value, rq); PhantomReference&lt;Object&gt; p2 = new PhantomReference&lt;Object&gt;(threadLoca2, rq); value = null;// value设置成null后，其强引用只在ThreadLocal属性里面，会伴随着ThreadLocal被回收而被回收。不用调用ThreadLocal.remove()方法就可以回收 threadLoca2 = null; System.gc(); Thread.sleep(3000); printQueue(2, rq);&#125;public static class MyThreadLocal&lt;T&gt; extends ThreadLocal&lt;WeakReference&lt;T&gt;&gt; &#123; T t; public MyThreadLocal() &#123; super(); &#125; public void setObj(T t) &#123; super.set(new WeakReference&lt;T&gt;(t)); this.t = t; &#125; public T getObj() &#123; WeakReference&lt;T&gt; wt = super.get(); return wt == null ? null : wt.get(); &#125;&#125;public static void printQueue(int count, ReferenceQueue&lt;Object&gt; rq) throws InterruptedException &#123; System.out.println("第" + count + "次查看"); PhantomReference&lt;Object&gt; wr; while ((wr = (PhantomReference&lt;Object&gt;) rq.remove(100)) != null) &#123; System.out.println("gc回收了:" + wr); &#125;&#125;]]></content>
      <categories>
        <category>源码解读</category>
      </categories>
      <tags>
        <tag>强引用</tag>
        <tag>软引用</tag>
        <tag>弱引用</tag>
        <tag>虚引用</tag>
        <tag>ThreadLocal</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[集合排序源码解读及常用排序]]></title>
    <url>%2F2018%2F01%2F12%2F2018-01-12%E9%9B%86%E5%90%88%E6%8E%92%E5%BA%8F%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%E5%8F%8A%E5%B8%B8%E7%94%A8%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[在软件开发过程中，我们经常会使用到集合类的排序操作，那么java给我们实现的排序到底是如何实现的，我们先看一下ArrayList集合类的排序源码（jdk1.8） Collections测试demo123456ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();Random random = new Random();for (int i = 0; i &lt; 1000; i++) &#123; list.add(random.nextInt(1000));&#125;Collections.sort(list); Collections.sort(obj)排序实际上是调用了obj自己的sort(null)方法123public static &lt;T extends Comparable&lt;? super T&gt;&gt; void sort(List&lt;T&gt; list) &#123;// Collections中的 list.sort(null);// 调用的是集合自己的排序方法，这里的list就是ArrayList&#125; ArrayList.sort下面我们看看ArrayList.sort(null)是如何处理的12345678public void sort(Comparator&lt;? super E&gt; comparator) &#123; // ArrayList中的 final int expectedModCount = modCount; Arrays.sort((E[]) elementData, 0, size, comparator);// 调用的是Arrays.sort方法 if (modCount != expectedModCount) &#123; throw new ConcurrentModificationException(); &#125; modCount++;&#125; LinkedList.sort123456789default void sort(Comparator&lt;? super E&gt; c) &#123; // List中的方法 Object[] a = this.toArray(); Arrays.sort(a, (Comparator) c);// 这里也使用到了Arrays.sort()方法 ListIterator&lt;E&gt; i = this.listIterator(); for (Object e : a) &#123; i.next(); i.set((E) e); &#125;&#125; Arrays.sort最终用到了Arrays的sort方法123456789101112131415161718public static &lt;T&gt; void sort(T[] a, int fromIndex, int toIndex,Comparator&lt;? super T&gt; c) &#123;// Arrays中的 if (c == null) &#123; sort(a, fromIndex, toIndex);// 如果排序方法为空，使用默认排序 &#125; else &#123; rangeCheck(a.length, fromIndex, toIndex); if (LegacyMergeSort.userRequested) legacyMergeSort(a, fromIndex, toIndex, c); else TimSort.sort(a, fromIndex, toIndex, c, null, 0, 0); &#125;&#125;public static void sort(Object[] a, int fromIndex, int toIndex) &#123;// Arrays中的 rangeCheck(a.length, fromIndex, toIndex); if (LegacyMergeSort.userRequested) legacyMergeSort(a, fromIndex, toIndex); else ComparableTimSort.sort(a, fromIndex, toIndex, null, 0, 0);// 使用ComparableTimeSort.sort进行排序&#125; 用到了一个叫ComparableTimSort的排序工具类，最终是用这个类进行数组的排序操作 那么我们来看看这个ComparableTimSort这个类是如何实现排序的123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869static void sort(Object[] a, int lo, int hi, Object[] work, int workBase, int workLen) &#123;// ComparableTimeSort中的 assert a != null &amp;&amp; lo &gt;= 0 &amp;&amp; lo &lt;= hi &amp;&amp; hi &lt;= a.length; int nRemaining = hi - lo;// 要排序数组长度 if (nRemaining &lt; 2) // 如果要排序的数组长度小于2，不用排序 return; if (nRemaining &lt; MIN_MERGE) &#123; // 如果要排序的数组长度小于32，直接进行排序就可以了 int initRunLen = countRunAndMakeAscending(a, lo, hi); binarySort(a, lo, hi, lo + initRunLen); return; &#125; // 如果要排序的数组长度大于等于32，使用ComparableTimSort工具进行排序 ComparableTimSort ts = new ComparableTimSort(a, work, workBase, workLen); int minRun = minRunLength(nRemaining);/*private static int minRunLength(int n) &#123;// 计算分隔成块的每块大小是多少 assert n &gt;= 0; int r = 0; // Becomes 1 if any 1 bits are shifted off while (n &gt;= MIN_MERGE) &#123; r |= (n &amp; 1); n &gt;&gt;= 1; &#125; return n + r;&#125;*/ do &#123; int runLen = countRunAndMakeAscending(a, lo, hi);/*private static int countRunAndMakeAscending(Object[] a, int lo, int hi) &#123; assert lo &lt; hi; int runHi = lo + 1; if (runHi == hi)// 如果只有一个数，直接返回1 return 1; if (((Comparable) a[runHi++]).compareTo(a[lo]) &lt; 0) &#123; // 如果后面的数比前面的数小，runHi顺便加一 while (runHi &lt; hi &amp;&amp; ((Comparable) a[runHi]).compareTo(a[runHi - 1]) &lt; 0)// 如果一直是后面的数比前面的数小的话，这顺序得倒过来 runHi++; reverseRange(a, lo, runHi);// 到现在，runHi的值小于runHi-1的值 &#125; else &#123; // 如果后面的数比前面的都大，顺序不错，是理想中要排完后的顺序 while (runHi &lt; hi &amp;&amp; ((Comparable) a[runHi]).compareTo(a[runHi - 1]) &gt;= 0) runHi++; &#125; return runHi - lo;// 返回数组前面有多少个已经排好队的数据数量&#125;private static void reverseRange(Object[] a, int lo, int hi) &#123;// 顺序正好是倒序，要变成正序 hi--;// 先对runHi减一 while (lo &lt; hi) &#123;// 当低位下标小于高位下标时 Object t = a[lo];// 低下标数保存一下 a[lo++] = a[hi];// 低下标数设置成高下标数 a[hi--] = t;// 高下标数设置成低下标数 &#125;&#125;*/ if (runLen &lt; minRun) &#123; // 如果已经排好队的数量小于每块大小 int force = nRemaining &lt;= minRun ? nRemaining : minRun;// 数组要排序的数量如果小于最小运行数量，就是要排序的数量，否则最小运行数量 binarySort(a, lo, lo + force, lo + runLen);// 对当前块进行排序 runLen = force; &#125; // 将当前块的起始下标和排序的数据数量保存起来 ts.pushRun(lo, runLen);/*private void pushRun(int runBase, int runLen) &#123; this.runBase[stackSize] = runBase; // 保存块的起始位置 this.runLen[stackSize] = runLen; // 保存块的大小 stackSize++; //保存需要归并排序的块的数量&#125;*/ // 对多个块进行归并排序 ts.mergeCollapse(); lo += runLen;// 起始下标右移到下一块的起始下标位置 nRemaining -= runLen;// 需要排序的数据数量更新 &#125; while (nRemaining != 0); assert lo == hi; ts.mergeForceCollapse(); assert ts.stackSize == 1;&#125; 最终使用到了插入排序和归并排序算法 下面是插入排序1234567891011121314151617181920212223242526272829private static void binarySort(Object[] a, int lo, int hi, int start) &#123;// 对a数组进行排序，最低下标是lo，最高下标是hi，开始排序下标是start assert lo &lt;= start &amp;&amp; start &lt;= hi; if (start == lo)// 如果开始排序的下标等于最低下标，将开始下标右移一位 start++; for ( ; start &lt; hi; start++) &#123;// 如果开始下标小于最高下标，也就是排序到最高下标的前一位置，这里的hi是要排序数据最大下标加一的值 Comparable pivot = (Comparable) a[start]; int left = lo;// left是当前数组最低位的下标 int right = start;// right是顺序不对的第一个数下标 assert left &lt;= right; while (left &lt; right) &#123;// 插入排序开始 int mid = (left + right) &gt;&gt;&gt; 1;// 最低位下标和顺序不对的下标除以2，得到中间的一个下标 if (pivot.compareTo(a[mid]) &lt; 0)// 如果顺序不对的第一个数比中间下标的数小,高位下标左移,然后再取中间下标进行比较 right = mid; else left = mid + 1;// 如果顺序不对的第一个数比中间下标的数大，低位下标右移，然后再自旋取中间下标 // 直到低位下标与高位下标相等才会跳出循环 &#125; assert left == right; int n = start - left; // The number of elements to move switch (n) &#123;// 看看移动的位数多不，如果多就用System.arraycopy进行插入操作中的整体数据右移 case 2: a[left + 2] = a[left + 1]; case 1: a[left + 1] = a[left]; break; //Object src, int srcPos, Object dest, int destPos, int length default: System.arraycopy(a, left, a, left + 1, n); &#125; a[left] = pivot; &#125;&#125; 下面是归并排序12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// 插入排序之后就是归并排序了private void mergeCollapse() &#123;// ComparableTimSort中的 while (stackSize &gt; 1) &#123; // 如果需要归并排序的块的数量大于等于2个才能进行归并排序 int n = stackSize - 2;// 找到倒数第二个需要归并排序的块 if (n &gt; 0 &amp;&amp; runLen[n-1] &lt;= runLen[n] + runLen[n+1]) &#123;// 如果前一个块数量小于等于后两个块数量 if (runLen[n - 1] &lt; runLen[n + 1])// 如果前一个块需要归并的数量比后一个块需要归并的数量少，从前一个块开始归并，否则还是从当前块开始归并 n--; mergeAt(n); &#125; else if (runLen[n] &lt;= runLen[n + 1]) &#123;// 如果当前块需要归并的数量小于等于后面块需要归并的数量的时候 mergeAt(n); &#125; else &#123; break; // Invariant is established &#125; &#125;&#125;private void mergeAt(int i) &#123;// 这里是归并排序的关键代码 assert stackSize &gt;= 2; assert i &gt;= 0; assert i == stackSize - 2 || i == stackSize - 3; int base1 = runBase[i];// 当前块的初始下标 int len1 = runLen[i];// 当前块的数据数量 int base2 = runBase[i + 1];// 下一块的初始下标 int len2 = runLen[i + 1];// 下一块的数据数量 // assert len1 &gt; 0 &amp;&amp; len2 &gt; 0; // assert base1 + len1 == base2; runLen[i] = len1 + len2;// 当前块的数量设置成当前块和下一块的数量 if (i == stackSize - 3) &#123;// 如果当前块是处理的前一个块数据，基本上不会有这种情况吧 runBase[i + 1] = runBase[i + 2]; runLen[i + 1] = runLen[i + 2]; &#125; stackSize--;// 要归并块的数量缩减为1 // 计算第一块中有多少个比第二块第一个数据小的数据数量 int k = gallopRight((Comparable&lt;Object&gt;) a[base2], a, base1, len1, 0); // assert k &gt;= 0; base1 += k;// 第一块数据的下标右移K个位置 len1 -= k;// 第一块数据的需要排序的长度重新计算 if (len1 == 0)// 如果都比第二块数据的第一个数小，那么len1计算出来就是0，就不用排队了，已经排好了 return; // 找到第二块数据中还有多少个数据比第一块最大数据大，然后把比第一块数据小的需要重新排队，需要重新排队的数量 len2 = gallopLeft((Comparable&lt;Object&gt;) a[base1 + len1 - 1], a, base2, len2, len2 - 1); // assert len2 &gt;= 0; if (len2 == 0) return; if (len1 &lt;= len2)// 如果第一块待整理的数据更少一下，使用mergeLo mergeLo(base1, len1, base2, len2); else // 如果第二块待整理的数据更少一些，使用mergeHi mergeHi(base1, len1, base2, len2);&#125; 归并排序中用到了两个驰骋算法，一个是gallopRight，另一个是gallopLeft，其实这两个算法实现原理是一样的，完全可以去掉一个 gallopRight123456789101112131415161718192021222324252627282930313233343536373839404142434445// a[25] a 0 25 0// 给定一个数据，看看数组中所有比这个数据小的数量(hint=0)，或者所有比这个数据大的偏移量(hint&gt;0)，这个方法与gallopLeft一样的效果啊private static int gallopRight(Comparable&lt;Object&gt; key, Object[] a, int base, int len, int hint) &#123; // assert len &gt; 0 &amp;&amp; hint &gt;= 0 &amp;&amp; hint &lt; len; int ofs = 1;// 这个ofs是个啥意思？ int lastOfs = 0;// 上一个ofs啥意思？ if (key.compareTo(a[base + hint]) &lt; 0) &#123; // 从数组右边找比给定数据大的数据下标，这个时候hint为数组最后那个下标，hint &gt; 0 int maxOfs = hint + 1; while (ofs &lt; maxOfs &amp;&amp; key.compareTo(a[base + hint - ofs]) &lt; 0) &#123; lastOfs = ofs; ofs = (ofs &lt;&lt; 1) + 1; if (ofs &lt;= 0) ofs = maxOfs; &#125; if (ofs &gt; maxOfs) ofs = maxOfs; int tmp = lastOfs; lastOfs = hint - ofs; ofs = hint - tmp; &#125; else &#123; // 从数组左边找比给定数据小的数据个数,hint=0 int maxOfs = len - hint;// 设定一个最大的限制下标 while (ofs &lt; maxOfs &amp;&amp; key.compareTo(a[base + hint + ofs]) &gt;= 0) &#123; // 既然第一个数比给定的数小，继续比较第二个数 lastOfs = ofs;// 记录上次的lastOfs，用于确定哪个下标是最后那个比给定数据小的 ofs = (ofs &lt;&lt; 1) + 1;// 疯狂向右移动，看看是不是都比给定数据小 if (ofs &lt;= 0) // 不能超过int最大值，估计到不了最大值吧，这个循环也就最多能疯狂向后移动32次，就超过int最大值了 ofs = maxOfs; &#125; if (ofs &gt; maxOfs)// 看看移动的是不是太过了，都超出数组最大值就不好了，重新归位到数组最大值 ofs = maxOfs; lastOfs += hint;// 上一个比给定数据小的下标加上偏移 ofs += hint;// 这一个跟给定数据比较却比给定数据大的下标 &#125; // assert -1 &lt;= lastOfs &amp;&amp; lastOfs &lt; ofs &amp;&amp; ofs &lt;= len; lastOfs++;// 确定了的比给定数据小的数组下标再往右小小移动一位 while (lastOfs &lt; ofs) &#123; int m = lastOfs + ((ofs - lastOfs) &gt;&gt;&gt; 1);// 取中间数，看看中间数是比给定的数小还是大 if (key.compareTo(a[base + m]) &lt; 0) // 如果中间数比给定的数据大，就把中间数往左移动（通过将ofs移动到中间数，再重新求中间数的方法） ofs = m; else // 如果中间数比给定的数据小，那就把中间数往右移动（通过将左边的lastOfs+1，再求中间数的方法） lastOfs = m + 1; // 直到左边数和右边数相等才会退出循环 &#125; assert lastOfs == ofs; // so a[b + ofs - 1] &lt;= key &lt; a[b + ofs] 求的的ofs是所有比给定数据小的数量 return ofs; // 这里返回的是有多少个比给定的数据小&#125; gallopLeft1234567891011121314151617181920212223242526272829303132333435363738394041424344// len2 = gallopLeft((Comparable&lt;Object&gt;) a[base1 + len1 - 1], a, base2, len2, len2 - 1);// 给定一个数据，看看数组中所有比这个数据小的数量(hint=0)，或者所有比这个数据大的偏移量(hint&gt;0),这个方法与gallopRight一样的效果啊private static int gallopLeft(Comparable&lt;Object&gt; key, Object[] a,int base, int len, int hint) &#123; // assert len &gt; 0 &amp;&amp; hint &gt;= 0 &amp;&amp; hint &lt; len; int lastOfs = 0; int ofs = 1; if (key.compareTo(a[base + hint]) &gt; 0) &#123; // 如果数组中的数据比给定数据小，就找左边的所有比给定数据小的数量 int maxOfs = len - hint; while (ofs &lt; maxOfs &amp;&amp; key.compareTo(a[base + hint + ofs]) &gt; 0) &#123; lastOfs = ofs; ofs = (ofs &lt;&lt; 1) + 1; if (ofs &lt;= 0) // int overflow ofs = maxOfs; &#125; if (ofs &gt; maxOfs) ofs = maxOfs; lastOfs += hint; ofs += hint; &#125; else &#123; // 如果给定的数据比数组中的最右边的数据小，那正好，开始狂奔吧 final int maxOfs = hint + 1;// 这里等于第二块的数组长度 while (ofs &lt; maxOfs &amp;&amp; key.compareTo(a[base + hint - ofs]) &lt;= 0) &#123;// 不超过第二块数组长度的情况下，从第二块数组倒数第二个数开始比较，如果比给定的数据大的话，就可以向左狂奔了，ofs起始是0 lastOfs = ofs;// 记录上次狂奔成功的向左便宜量 ofs = (ofs &lt;&lt; 1) + 1; if (ofs &lt;= 0) ofs = maxOfs; &#125; if (ofs &gt; maxOfs) // 如果偏移量都超过数组长度了，那就设置偏移量为数组长度 ofs = maxOfs; int tmp = lastOfs; lastOfs = hint - ofs;// 这里不使用偏移量，只使用下标，所以还是计算出对应的下标值吧 ofs = hint - tmp;// 计算最右边的比给定数据大的下标 &#125; assert -1 &lt;= lastOfs &amp;&amp; lastOfs &lt; ofs &amp;&amp; ofs &lt;= len; lastOfs++; while (lastOfs &lt; ofs) &#123; int m = lastOfs + ((ofs - lastOfs) &gt;&gt;&gt; 1);// 左边比给定数据小的下标，和右边比给定数据大的下标求中间下标 if (key.compareTo(a[base + m]) &gt; 0) // 如果中间下标数据比给定数据小，那么左边下标就向右移动到中间下标位置再加1 lastOfs = m + 1; else // 如果中间下标数据比给定数据大，那么右边下标就移动到中间下边位置 ofs = m; &#125; assert lastOfs == ofs; // so a[base + ofs - 1] &lt; key &lt;= a[base + ofs] return ofs;// 这里的ofs是比给定的数据大的那个数据的偏移量，也就是说还有ofs个数据等着排序&#125; 驰骋过后，就是将两个插入排序完成的块进行归并排序了，归并排序中也用到了驰骋算法。。。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697// 第二块待整理的数据更少一些，使用下面的方法整理private void mergeHi(int base1, int len1, int base2, int len2) &#123; // assert len1 &gt; 0 &amp;&amp; len2 &gt; 0 &amp;&amp; base1 + len1 == base2; Object[] a = this.a; Object[] tmp = ensureCapacity(len2); int tmpBase = this.tmpBase; System.arraycopy(a, base2, tmp, tmpBase, len2);// 将第二块待整理的数据都拷贝到临时数组里面 int cursor1 = base1 + len1 - 1; // 第一块待整理数据的最大下标 int cursor2 = tmpBase + len2 - 1; // 临时表数据的最大下标 int dest = base2 + len2 - 1; // 要存放最大数据的下标，最大数据肯定要放到第二块的最大下标那个地方 a[dest--] = a[cursor1--]; // 前面我们已经知道了第一块数据的最后那个数据比第二块待整理的那个数据大（否则还会继续向左驰骋），那么就将第一块数据的最大数据摆放在第二块待整理的那个最大下标那 if (--len1 == 0) &#123;// 如果把第一块最大下标放到第二块最大下标那后，第一块数据都整理完了，那么只需将第二块的数据从第一块最大数据下标开始放置就可以了 System.arraycopy(tmp, tmpBase, a, dest - (len2 - 1), len2); return; &#125; if (len2 == 1) &#123; // 如果第二块待整理的数据只有一个，我们事先知道第一块待整理的数据的第一个数据比第二块的第一个数据大（否则还会向右继续驰骋），我们只需将这个数据放到第一块数据上，然后将第一块待整理的数据都放到这个数据右边就可以了 dest -= len1; // 当前dest应该就在第二块那唯一的数据下标上了 cursor1 -= len1;// 第一块的最大下标已经减一了 System.arraycopy(a, cursor1 + 1, a, dest + 1, len1); a[dest] = tmp[cursor2];// 将第二块唯一的数据放到第一块数据的首位置 return; &#125; int minGallop = this.minGallop; // 设置一个驰骋的阀值outer: while (true) &#123; int count1 = 0; int count2 = 0; do &#123; assert len1 &gt; 0 &amp;&amp; len2 &gt; 1; // 第一块，第二块数据一块比较，拿出最大的数据来放到原数组a中的最后那个待排序的下标那 if (((Comparable) tmp[cursor2]).compareTo(a[cursor1]) &lt; 0) &#123; a[dest--] = a[cursor1--]; count1++; count2 = 0; if (--len1 == 0)// 如果有一个块数据没有了，那就表明排序完成了 break outer; &#125; else &#123; a[dest--] = tmp[cursor2--]; count2++; count1 = 0; if (--len2 == 1)// 如果有一个块数据没有了，那就表明排序完成了 break outer; &#125; &#125; while ((count1 | count2) &lt; minGallop);// 如果一段连续时间内都在某一块上拿最大的数据，次数大于等于7就可以尝试驰骋的方案了 // 下面开始进行驰骋 do &#123; assert len1 &gt; 0 &amp;&amp; len2 &gt; 1; count1 = len1 - gallopRight((Comparable) tmp[cursor2], a, base1, len1, len1 - 1);// 找到比第二块中最大数据都大的最左那个大数据偏移量 if (count1 != 0) &#123;// 如果待排序的数量不等于0 dest -= count1; cursor1 -= count1; len1 -= count1; System.arraycopy(a, cursor1 + 1, a, dest + 1, count1); if (len1 == 0) break outer; &#125; a[dest--] = tmp[cursor2--]; if (--len2 == 1) break outer; count2 = len2 - gallopLeft((Comparable) a[cursor1], tmp, tmpBase, len2, len2 - 1);// 找到比第一块最大数据还大的第二块数据的偏移量 if (count2 != 0) &#123; dest -= count2; cursor2 -= count2; len2 -= count2; System.arraycopy(tmp, cursor2 + 1, a, dest + 1, count2); if (len2 &lt;= 1) break outer; // len2 == 1 || len2 == 0 &#125; a[dest--] = a[cursor1--]; if (--len1 == 0) break outer; minGallop--; &#125; while (count1 &gt;= MIN_GALLOP | count2 &gt;= MIN_GALLOP);// 如果驰骋的数量不达标，还是继续老老实实的进行归并排序吧 if (minGallop &lt; 0) minGallop = 0; minGallop += 2; // Penalize for leaving gallop mode &#125; // End of "outer" loop this.minGallop = minGallop &lt; 1 ? 1 : minGallop; // Write back to field if (len2 == 1) &#123; // 如果第二块还剩一个数据，就把第一块数据的所有待排序数据右移一位，将第二块剩下的唯一一个数据放到第一块待排序的第一个位置上，因为调用mergeHi之前已经驰骋过了，第二块第一个待排序的数据肯定比第一块第一个待排序的数据小 assert len1 &gt; 0; dest -= len1; cursor1 -= len1; System.arraycopy(a, cursor1 + 1, a, dest + 1, len1); a[dest] = tmp[cursor2]; // Move first elt of run2 to front of merge &#125; else if (len2 == 0) &#123; throw new IllegalArgumentException( "Comparison method violates its general contract!"); &#125; else &#123;// 退出循环的时候第一块都排序完了，将第二块的临时数据都搬到没排序的位置上就可以了 assert len1 == 0; assert len2 &gt; 0; System.arraycopy(tmp, tmpBase, a, dest - (len2 - 1), len2); &#125;&#125; 冒泡法排序12345678910111213141516int[] arr = new int[10];Random random = new Random();for (int i = 0; i &lt; 10; i++) &#123; arr[i] = random.nextInt(1000);&#125;System.out.println(org.apache.commons.lang3.StringUtils.join(arr,','));for (int i = 0; i &lt; arr.length - 1; i++) &#123;// 这里的关键点是要冒泡几次，length-1次 int dest = arr.length - i - 1;// 每次冒泡的目的地是哪，length-i-1,第一次冒泡目的地是length-1,第二次目的地就是length-2 for (int j = 0; j &lt; dest; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; arr[j] ^= arr[j + 1]; arr[j + 1] ^= arr[j]; arr[j] ^= arr[j + 1]; &#125; &#125;&#125; 最佳情况时间复杂度：1+2+3+…+N-1 = N^2/2 时间复杂度是O(N^2) 改进后的冒泡法排序12345678910111213141516171819202122int[] arr = new int[10];Random random = new Random();for (int i = 0; i &lt; 10; i++) &#123; arr[i] = random.nextInt(1000);&#125;System.out.println(org.apache.commons.lang3.StringUtils.join(arr,','));boolean doSwap;for (int i = 0; i &lt; arr.length - 1; i++) &#123;// 这里的关键点是要冒泡几次，length-1次 doSwap = false; int dest = arr.length - i - 1;// 每次冒泡的目的地是哪，length-i-1,第一次冒泡目的地是length-1,第二次目的地就是length-2 for (int j = 0; j &lt; dest; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; arr[j] ^= arr[j + 1]; arr[j + 1] ^= arr[j]; arr[j] ^= arr[j + 1]; doSwap = true; &#125; &#125; if(!doSwap)&#123; break; &#125;&#125; 改进后的最佳时间复杂度为：O(N) 选择排序123456789101112131415161718192021int[] arr = new int[10];Random random = new Random();for (int i = 0; i &lt; 10; i++) &#123; arr[i] = random.nextInt(1000);&#125;System.out.println(org.apache.commons.lang3.StringUtils.join(arr, ','));int minIdx,temp;for (int i = 0; i &lt; arr.length-1; i++) &#123; minIdx = i; for (int j = i + 1; j &lt; arr.length; j++) &#123; if (arr[minIdx] &gt; arr[j]) &#123; minIdx = j; &#125; &#125; if (minIdx != i) &#123; temp = arr[minIdx]; arr[minIdx] = arr[i]; arr[i] = temp; &#125;&#125;System.out.println(org.apache.commons.lang3.StringUtils.join(arr, ',')); 优点 如果数据在正确的位置上，不会移动位置 每次只交换一对元素 在完全依靠交换去移动元素的排序方法中，选择排序是非常好的一种 选择排序比较次数：n(n-1)/2 O(n^2) 交换次数：0…n-1 之间 O(n) 由于比较比交换耗用CPU时间少，所以n值较小时选择排序比冒泡排序快 实际适用的场合非常罕见 插入排序1234567891011121314151617181920212223242526int[] arr = new int[10];Random random = new Random();for (int i = 0; i &lt; 10; i++) &#123; arr[i] = random.nextInt(1000);&#125;System.out.println(org.apache.commons.lang3.StringUtils.join(arr, ','));int temp;for (int i = 1; i &lt; arr.length; i++) &#123; temp = arr[i]; loop2: for (int j = i - 1; j &gt;= 0; j--) &#123; // 从右向左找可以解决本来就已经排好队时不必要的比较操作 if (temp &gt;= arr[j]) &#123; // 将j+1之后的数据右移一位，空出来的j+1位置填充arr[i] if (j + 1 != i) &#123; System.arraycopy(arr, j + 1, arr, j + 2, i - (j + 1));// 将比它大的数据都右移一位 arr[j + 1] = temp;// 将当前数放到这个比它大的数的位置上 &#125; break loop2; &#125; else if (j == 0) &#123; System.arraycopy(arr, 0, arr, 1, i);// 将比它大的数据都右移一位 arr[0] = temp;// 将当前数放到这个比它大的数的位置上 &#125; &#125;&#125;System.out.println(org.apache.commons.lang3.StringUtils.join(arr, ',')); 另一种方法，一个一个挪123456789101112131415161718int[] arr = new int[10];Random random = new Random();for (int i = 0; i &lt; 10; i++) &#123; arr[i] = random.nextInt(1000);&#125;System.out.println(org.apache.commons.lang3.StringUtils.join(arr, ','));int temp;for (int i = 1; i &lt; arr.length; i++) &#123; temp = arr[i]; int j = i - 1; // 从右向左找可以解决本来就已经排好队时不必要的比较操作 // 如果arr[i] 一直比arr[0]...arr[i-1]的数小，就一直往后挪数据 for (; j &gt;= 0 &amp;&amp; temp &lt; arr[j]; j--) &#123; arr[j + 1] = arr[j]; &#125; arr[j + 1] = temp;&#125;System.out.println(org.apache.commons.lang3.StringUtils.join(arr, ',')); 最好情况下，数组已经排好序，只需要比较N-1次就可以了 最坏情况下，数组是倒序的，需要比较(N-1+1)*(N-1)/2 = N(N-1)/2次 平均来说插入算法时间复杂度是O(N^2) 插入排序不适合大数据量(&gt;1000)的使用，如果已知元素大致上是按照顺序排列，那么插入排序还是比较好的选择 堆排序1234567891011121314151617181920212223242526272829303132333435363738public static void sort(int[] arr) &#123; int len = arr.length - 1; // 从第一个非叶子节点开始，往前进行堆话，就是将最大值尽量往上推 int beginIndex = (len - 1) &gt;&gt; 1; for (int i = beginIndex; i &gt;= 0; i--) &#123; maxHeapify(arr, i, len); &#125; // 真正的排序开始，拿出最大值，重新堆话 for (int i = len; i &gt; 0; i--) &#123; swap(arr, 0, i);// 这里才是真正的排序操作，将最大数放到最末尾 maxHeapify(arr, 0, i - 1);// 再去将次大的挪动到下标是0的位置上，要排除刚才放到末尾的那个最大值，要不然有可能白做无用功 &#125;&#125;private static void swap(int[] arr, int i, int j) &#123; int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp;&#125;// 堆化数组，将最大数挪动到最顶层，注意，这里没有排序，只是挪动最大数保持父节点比子节点数据大的特性private static void maxHeapify(int[] arr, int idx, int endIdx) &#123; int leftIdx = (idx &lt;&lt; 1) + 1; int rightIdx = leftIdx + 1; int maxIdx = leftIdx; // 如果左边的子节点都比len大，那就不用比较了 if (leftIdx &gt; endIdx) return; // 如果右边的子节点大，那就拿右边的跟父节点比较和转换 if (rightIdx &lt;= endIdx &amp;&amp; arr[rightIdx] &gt; arr[leftIdx])&#123; maxIdx = rightIdx; &#125; // 如果子节点中最大的那个数据，比父节点数据大，将子节点和父节点进行调换 if (arr[maxIdx] &gt; arr[idx]) &#123; swap(arr,maxIdx, idx); // 调换完成后再去比较刚才的父节点的顺序是否合适 // 因为最大堆排序是从第一个非叶子节点开始，向上进行堆排序，如果调换下来的父节点很小，就得对它重新排序 maxHeapify(arr, maxIdx, endIdx); &#125;&#125; 堆排序时间复杂度：O(N*logN), 空间复杂度O(1) 快速排序123456789101112131415161718192021222324252627public static void qSort(int[] arr, int head, int tail) &#123; if (head &gt;= tail || arr == null || arr.length &lt;= 1) &#123; return; &#125; int i = head, j = tail; int pivot = arr[(head + tail) / 2];// 找到中间的一个数据当作比较对象 while (i &lt;= j) &#123; while (arr[i] &lt; pivot) &#123;// 从最左边开始找比这个数大的或相等的 ++i; &#125; while (arr[j] &gt; pivot) &#123;// 从最右边开始找比这个数小的或相等的 --j; &#125; if (i &lt; j) &#123;// 极端情况下找到的两个数都与pivot相等，那还得倒换一遍， int t = arr[i]; arr[i] = arr[j]; arr[j] = t; ++i; --j; &#125; else if (i == j) &#123;// 如果i==j了，对i+1跳出循环 ++i; &#125; // i如果比j大，说明区间中没有比它大或相等的数或者区间中没有比它小或相等的数，现在j+1=i &#125; qSort(arr, head, j); qSort(arr, i, tail);&#125; 快速排序平均时间复杂度：O(NlogN)，最差情况下，退化成冒泡排序，时间复杂度为O(N^2)快速排序的改进和优化：第一个：小数组适用插入排序第二个：双枢轴，大于枢轴、等于枢轴、小于枢轴（快速三向切分）第三个：划分策略优化（五取样划分）经过优化后的快速排序算法时间复杂度可以介于O(N)到O(NlogN)之间可以看java中DualPivotQuicksort的源码 归并排序12345678910111213141516171819202122232425262728293031323334353637383940public static void main(String[] args) throws IOException &#123; Random random = new Random(); int[] arr = new int[30]; for (int i = 0; i &lt; 30; i++) &#123; arr[i] = random.nextInt(1000); &#125; System.out.println(org.apache.commons.lang3.StringUtils.join(arr, ',')); sort(arr,0,arr.length-1,new int[arr.length]); System.out.println(org.apache.commons.lang3.StringUtils.join(arr, ','));&#125;public static void sort(int[] arr, int first, int last, int[] temp) &#123; if (first &lt; last) &#123; int mid = (first + last) / 2;// 当first和last紧靠着，mid就是first，mid+1就是last，那么下次递归就不会进入这个代码里面了，然后就是两个单个数的数组进行归并排序 sort(arr, first, mid, temp);// 排序第一个数组 sort(arr, mid + 1, last, temp);// 排序第一个数组 merge(arr, first, mid, last, temp);// 归并两个数组 &#125;&#125;private static void merge(int[] arr, int first, int mid, int last, int[] temp) &#123; int i = first, j = mid + 1; int end1 = mid, end2 = last; int k = 0; while (i &lt;= end1 &amp;&amp; j &lt;= end2) &#123; if(arr[i]&lt;arr[j])&#123; temp[k++] = arr[i++]; &#125;else&#123; temp[k++]=arr[j++]; &#125; &#125; while(i&lt;=end1)&#123; temp[k++]=arr[i++]; &#125; while(j&lt;=end2)&#123; temp[k++]=arr[j++]; &#125; for(i=0;i&lt;k;i++)&#123; arr[first+i] = temp[i]; &#125;&#125; 优点：速度紧次于快速排序，为稳定排序算法 时间复杂度：将数组分成小数组以供需要logN步，每步都是合并有序数列的的过程，时间复杂度可以记为O(N)， 所以时间复杂度就是O(N*logN) 分配排序 桶排序1234567891011121314151617Random random = new Random();int[] arr = new int[30];for (int i = 0; i &lt; 30; i++) &#123; arr[i] = random.nextInt(100);&#125;System.out.println(org.apache.commons.lang3.StringUtils.join(arr, ','));int[] bucket = new int[100];// 我们必须事先知道数组的数据大小范围是0-100for (int i = 0; i &lt; arr.length; i++) &#123; bucket[arr[i]]++;&#125;int idx=0;for (int i = 0; i &lt; bucket.length; i++) &#123; for (int j = 0; j &lt; bucket[i]; j++) &#123; arr[idx++]=i; &#125;&#125;System.out.println(org.apache.commons.lang3.StringUtils.join(arr, ',')); 时间复杂度，O(n) 我们必须知道数组中的数据范围 只能对整数进行排序 变种的话，将数据区间平均分配到N个区间，每个区间一个桶，再对桶中的数据进行插入排序，然后将所有的非空桶中数据依次拿出来就可以了]]></content>
      <categories>
        <category>源码</category>
      </categories>
      <tags>
        <tag>Collections</tag>
        <tag>Sort</tag>
        <tag>ArrayList</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux下的常用命令]]></title>
    <url>%2F2018%2F01%2F11%2F2018-01-11Linux%E4%B8%8B%E7%9A%84%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[运行脚本失败，回车换行符问题如下报错信息：1-bash: ./start.sh: /bin/bash^M: 坏的解释器: 没有那个文件或目录 查看文件是否有^M换行符存在12345cat -v start.sh或者vi -b start.sh 或者vi start.sh 后输入命令: :e ++ff=unix start.sh 可以看到整个文件的换行都有^M符号 解决方法 使用vi打开脚本文件，输入下面命令 1:set ff=unix 使用cat tr命令,注意，这里的^M是Ctrl+V，Ctrl+M输入的 1cat start.sh | tr -d "^M" &gt; new_start.sh 使用sed命令替换 1sed 's/^M//g' start.sh &gt;new_start.sh 使用vi打开文件，输入下面命令,或者直接使用vi -b 文件名的方式打开文件 1:e ++ff=unix start.sh // 以unix格式打开文件 然后执行替换命令,这里的^M也是通过Ctrl+V，Ctrl+M输入的1:%s/^M//g 查看命令可以输入下面指令123:h ++:h ff:h ffs 查找某个文本文件中指定内容数据比如说日志文件中有userId=1234,date=2018-10-11,我们想获取到所有userId的值，保存到指定文件里面，可以使用下面的命令 1cat xxx.log | grep "xxxxxxx" | awk 'BEGIN&#123;FS="userId="&#125; &#123;print $2&#125;' | awk 'BEGIN&#123;FS=",date="&#125; &#123;print $1&#125;' &gt; temp.txt 查找文件内容，返回查找到的内容之前，之后的多少行数据1grep -A 5 -B 5 "userId=6789" xxx.log 查看进程中的线程数1234ps -mp [进程ID] | wc -lps -Lf [进程ID] | wc -lps -T -p [进程ID] | wc -ltop -Hp [进程ID] 查看进程中线程执行了多长时间1ps -mp [进程ID] -o THREAD,tid,time centos开放端口的方法centos开放端口方法1.查看firewalld有没有安装1ps -ef|grep firewalld 2.没有安装安装上1yum install firewalld firewall-config 3.运行、停止、禁用firewalld启动1systemctl start firewalld 查看状态1systemctl status firewalld 或者 firewall-cmd --state 停止1systemctl disable firewalld 禁用1systemctl stop firewalld 4.查看版本1firewall-cmd --version 查看帮助1firewall-cmd --help 5.显示状态1firewall-cmd --state 查看区域信息1firewall-cmd --get-active-zones 查看指定接口所属区域1firewall-cmd --get-zone-of-interface=eth0 6.查看所有打开的端口1firewall-cmd --zone=public --list-ports 7.加入一个端口到区域：12firewall-cmd --zone=public --add-port=6379/tcp永久生效再加上 --permanent 然后reload防火墙 8.更新防火墙规则：123firewall-cmd --reloadfirewall-cmd --complete-reload两者的区别就是第一个无需断开连接，就是firewalld特性之一动态添加规则，第二个需要断开连接，类似重启服务 拒绝所有包1firewall-cmd --panic-on 取消拒绝状态1firewall-cmd --panic-off 查看是否拒绝1firewall-cmd --query-panic 设置默认接口区域1firewall-cmd --set-default-zone=public 立即生效无需重启 打开一个服务，类似于将端口可视化，服务需要在配置文件中添加，/etc/firewalld 目录下有services文件夹，这个不详细说了，详情参考文档1firewall-cmd --zone=work --add-service=smtp 移除服务1firewall-cmd --zone=work --remove-service=smtp Linux Shell编程获取当前脚本运行目录123cd `dirname $0`BIN_DIR=`pwd`echo $BIN_DIR 遍历目录下的所有文件或文件夹123456789for file in $BIN_DIR/*do if test -d $file then echo "$file这是个文件夹" else echo "$file这是个文件" fidone 判断指定路径下是否是文件或文件夹123456if test -f $file/bin/start.shthen echo "$file/bin/start.sh文件存在"else echo "$file/bin/start.sh文件不存在"fi 判断文件路径是否存在12345678if test -e $file/bin/startt.shthen echo "$file/bin/startt.sh存在"fiif test ! -e $file/bin1then echo "$file/bin1文件不存在"fi 判断文件是否可读、可写、可执行123if test -r $file/bin/start.shif test -w $file/bin/start.shif test -x $file/bin/start.sh 字符串正则比较12345678for file in $BIN_DIR/*do #支持bash中的通配符扩展 if [[ $file = *.war ]] then echo "找到一个war包$file" fidone 数字计算123count=`expr $count + 1`或者let "count=$count+1" 使用命令快速跳转目录在 ~/.bashrc配置文件中配置快捷键对应的命令，然后再source ~/.bashrc12345678910alias dubbo='cd /apps/product/dubbo'alias tomcat='cd /apps/product/tomcat'alias tomcatbin='cd /apps/product/tomcat/bin'alias tomcatweb='cd /apps/product/tomcat/webapps'alias log1='sh /apps/product/dubbo/log.sh 1'alias log2='sh /apps/product/dubbo/log.sh 2'alias log3='sh /apps/product/dubbo/log.sh 3'alias log4='sh /apps/product/dubbo/log.sh 4'alias log5='sh /apps/product/dubbo/log.sh 5'alias logtomcat='tail -f /apps/product/tomcat/logs/*.out' 多个dubbo服务放到同一个目录下，启动脚本和停止脚本如下启动脚本 start.sh12345678910111213141516171819202122232425262728293031323334353637#!/bin/shcd `dirname $0`BIN_DIR=`pwd`TOMCAT_DIR=/apps/product/tomcat/webappsecho "开始移动war包..."for file in $BIN_DIR/*do if [[ $file = *.war ]] then echo "找到一个war包$file，移动到文件夹$TOMCAT_DIR目录下" mv $file $TOMCAT_DIR fidoneecho "war包移动完成..."echo "开始解压tar包..."for file in $BIN_DIR/*do if [[ $file = *.tar.gz ]] then echo "开始解压压缩包$file" tar -zxf $file rm -rf $file fidoneecho "tar包解压完成..."for file in $BIN_DIR/*do if test -d $file then if test -f $file/bin/startt.sh then sh $file/bin/startt.sh fi fidoneps -aux | grep java 停止脚本 stop.sh123456789101112131415#!/bin/shcd `dirname $0`BIN_DIR=`pwd`echo $0for file in $BIN_DIR/*do if test -d $file then if test -f $file/bin/stop.sh then sh $file/bin/stop.sh fi fidone 查看dubbo日志脚本 log.sh使用方式sh log.sh 112345678910111213141516171819#!/bin/shnum=$1cd `dirname $0`BIN_DIR=`pwd`count=1for file in $BIN_DIR/*do if [ -e $file/logs/stdout.log ] then if [ $1 -eq $count ] then echo "开始查看日志文件$file/logs/stdout.log" tail -f $file/logs/stdout.log break; else count=`expr $count + 1` fi fidone]]></content>
      <categories>
        <category>整理</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>vi</tag>
        <tag>vim</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ConcurrentHashMap源码解析]]></title>
    <url>%2F2018%2F01%2F10%2F2018-01-10ConcurrentHashMap%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[HashMap123456789101112131415161718public V put(K key, V value) &#123; // HashMap中的 return putVal(hash(key), key, value, false, true);&#125;static final int hash(Object key) &#123;// HashMap中的，获取Object的hashCode并且将hashCode进行预处理（高16位与低16位进行异或运算，并且将计算结果替换低16位的值） int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125;public int hashCode() &#123; // String中的，计算String字符串的HashCode值 int h = hash; if (h == 0 &amp;&amp; value.length &gt; 0) &#123; char val[] = value; for (int i = 0; i &lt; value.length; i++) &#123; h = 31 * h + val[i]; &#125; hash = h; &#125; return h;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123;// hashcode值，key，value，false，true Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; if ((tab = table) == null || (n = tab.length) == 0)// 如果数组的长度为0，需要初始化数组，并把数组长度赋值给n n = (tab = resize()).length; if ((p = tab[i = (n - 1) &amp; hash]) == null)// 通过将要保存的数据key的hashCode与数组长度减一取与运算（相当于对数组长度取余运算），获取新进来的节点要保存的数组下标位置，如果该位置上已经有节点数据，将该节点数据赋值给p tab[i] = newNode(hash, key, value, null);// 如果数组下标上的第一个节点是个空置，那么这个新进来的数据就可以保存位第一个节点/*Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; return new Node&lt;&gt;(hash, key, value, next);&#125;Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; this.hash = hash;//这个节点拥有hash值 this.key = key;// key值 this.value = value;// value值 this.next = next;// next值=null&#125;*/ else &#123; // 如果数组下标第一个节点p不是空置 Node&lt;K,V&gt; e; K k; if (p.hash == hash &amp;&amp; // 判断数组下标上的第一个节点的key值与新进来的数据key值是不是一样，如果一样，将第一个节点赋值给e ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; else if (p instanceof TreeNode)// 如果数组下标上的第一个节点是个TreeNode类型数据（当数组下标上挂着的链表长度达到指定数值时会将链表转换成TreeNode） e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); else &#123; // 如果不是TreeNode类型，那么还是保存的链表 for (int binCount = 0; ; ++binCount) &#123;// 定义一个binCount变量，用来保存链表长度，不断遍历链表 if ((e = p.next) == null) &#123;// 当遍历到链表尾部 p.next = newNode(hash, key, value, null);// 创建一个新节点，并挂到链表尾部 if (binCount &gt;= TREEIFY_THRESHOLD - 1) // 如果链表长度达到阀值TREEIFY_THRESHOLD=8，将链表转换成TreeNode treeifyBin(tab, hash);/*final void treeifyBin(Node&lt;K,V&gt;[] tab, int hash) &#123; int n, index; Node&lt;K,V&gt; e; if (tab == null || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)// 如果数组长度小于MIN_TREEIFY_CAPACITY=64（8，16，32，64），不会将链表转换成TreeNode，而是将HashMap的数组扩容 resize(); else if ((e = tab[index = (n - 1) &amp; hash]) != null) &#123;// 如果数组长度大于等于64,就需要将数组下标的链表转换成TreeNode TreeNode&lt;K,V&gt; hd = null, tl = null; do &#123; TreeNode&lt;K,V&gt; p = replacementTreeNode(e, null);// 将链表中的节点数据转换成TreeNode类型数据 if (tl == null)// 如果是第一个节点 hd = p; // 设置hd变量为头节点 else &#123; // 如果是下面的节点 p.prev = tl;// 设置当前节点的上一个节点 tl.next = p;// 设置上一个节点的下一个节点为当前节点 &#125; tl = p;// 保存当前TreeNode节点 &#125; while ((e = e.next) != null);// 如果节点不是null if ((tab[index] = hd) != null) hd.treeify(tab);//排序？ &#125;&#125;*/ break; &#125; if (e.hash == hash &amp;&amp; // 遍历链表的时候发现有key值相同的节点，直接跳出循环 ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e;// 往下遍历 &#125; &#125; if (e != null) &#123; // 如果存在key值相同的链表节点，看看是否允许覆盖掉原值，允许的话就覆盖 V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; &#125; &#125; ++modCount;// 更新修改的次数 if (++size &gt; threshold)// 如果数组长度大于阀值，将HashMap的数组进行扩容 resize(); afterNodeInsertion(evict);// 空的 return null;&#125; 扩展数组容量1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374// 扩展数组容量final Node&lt;K,V&gt;[] resize() &#123; Node&lt;K,V&gt;[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length;// 现在的数组容量 int oldThr = threshold;// 扩展的阀值 int newCap, newThr = 0;// 扩展后的数组容量及阀值 if (oldCap &gt; 0) &#123; if (oldCap &gt;= MAXIMUM_CAPACITY) &#123;// 如果当前数组容量已经达到或超过了（1 &lt;&lt; 30），就不允许再扩容了，阀值直接设置成Integer最大值，也就是说以后不会触发扩容了 threshold = Integer.MAX_VALUE; return oldTab; &#125; else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;// 数组扩容一倍，容量还小于最大容量值（1 &lt;&lt; 30），并且容量大于等于初始容量 oldCap &gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &lt;&lt; 1; // double threshold 阀值扩容一倍 &#125; else if (oldThr &gt; 0) // 如果旧的数组大小为0，但是阀值不为0，设置新的数组大小为阀值的大小 newCap = oldThr; else &#123; // 旧的数组大小为0，旧的阀值大小也为0，初始化新的数组大小以及阀值 newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); &#125; if (newThr == 0) &#123;// 如果新的阀值为0，那么这种可能就是我们自己定制的hashMap的容量以及loadFactor float ft = (float)newCap * loadFactor;// 计算出来阀值的float是多少 newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?// 如果新的数组大小 小于最大容量大小（1 &lt;&lt; 30），并且计算出的阀值也小于最大容量，就重新设置一下（int）阀值，如果容量或计算出的float阀值大于最大容量，就设置阀值Integer的最大值，也就是没有阀值，不会触发扩容 (int)ft : Integer.MAX_VALUE); &#125; threshold = newThr; @SuppressWarnings(&#123;"rawtypes","unchecked"&#125;) Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];// 重新创建一个数组 table = newTab; if (oldTab != null) &#123;// 将旧的数组数据拷贝到新的数组中去 for (int j = 0; j &lt; oldCap; ++j) &#123; Node&lt;K,V&gt; e; if ((e = oldTab[j]) != null) &#123;// 拿到第j个元素 oldTab[j] = null;// 清空旧数组中的数据，便于内存回收 if (e.next == null)// 如果该数组元素下没有元素挂载 newTab[e.hash &amp; (newCap - 1)] = e;// 将该元素挂到新数组下面 else if (e instanceof TreeNode)// 如果元素下挂载一个TreeNode的元素，需要将TreeNode上的各个节点重新计算数组下标位置 ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); else &#123; // preserve order Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; do &#123; next = e.next; if ((e.hash &amp; oldCap) == 0) &#123; if (loTail == null) loHead = e; else loTail.next = e; loTail = e; &#125; else &#123; if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); if (loTail != null) &#123; loTail.next = null; newTab[j] = loHead; &#125; if (hiTail != null) &#123; hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; &#125; return newTab;&#125; Hashtable123456789101112131415161718192021222324252627282930313233343536public synchronized V put(K key, V value) &#123; if (value == null) &#123;// 注意：Hashtable的key和value值都不允许为null throw new NullPointerException(); &#125; Entry&lt;?,?&gt; tab[] = table;// 拿到数组 int hash = key.hashCode(); int index = (hash &amp; 0x7FFFFFFF) % tab.length;// 通过取余操作获取该数据应该保存的数组下标位置 // HashMap 数据节点 Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; HashMap中的class定义 // Hashtable数据节点Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; Hashtable中的class定义 Entry&lt;K,V&gt; entry = (Entry&lt;K,V&gt;)tab[index];// Hashtable是使用的Entry当作数据存储单位 // 如果查找到key相等的节点，直接将旧节点value更新，并将旧节点返回 for(; entry != null ; entry = entry.next) &#123; if ((entry.hash == hash) &amp;&amp; entry.key.equals(key)) &#123; V old = entry.value; entry.value = value; return old; &#125; &#125; // 如果没有重复的，需要新增节点数据 addEntry(hash, key, value, index); return null;&#125;private void addEntry(int hash, K key, V value, int index) &#123; modCount++;// 更新修改数量统计 Entry&lt;?,?&gt; tab[] = table; if (count &gt;= threshold) &#123; rehash();// 如果Hashtable保存的数据数量达到了阀值，需要扩展Hashtable的数组长度 tab = table;// 重新获取扩展后的数组 hash = key.hashCode(); index = (hash &amp; 0x7FFFFFFF) % tab.length;// 重新计算扩展后的对应数组下标 &#125; Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;) tab[index];// 拿到数组下标下的第一个节点数据 tab[index] = new Entry&lt;&gt;(hash, key, value, e);// 创建新节点，并将新节点的下一个节点设置为原来的数组下标节点 count++;&#125; 注意，Hashtable并没有将数组下挂着的链表达到一定数量节点后转为TreeNode ConcurrentHashMap123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105public V put(K key, V value) &#123; return putVal(key, value, false);&#125;final V putVal(K key, V value, boolean onlyIfAbsent) &#123; // 如果key或value有一个是null，就会抛出异常 if (key == null || value == null) throw new NullPointerException(); int hash = spread(key.hashCode());/*static final int spread(int h) &#123;// 重新处理key的hashCode值，比HashMap中的hash多了一步操作，跟0x7fffffff进行与操作，将符号位去掉 return (h ^ (h &gt;&gt;&gt; 16)) &amp; HASH_BITS;&#125;*/ int binCount = 0; for (Node&lt;K,V&gt;[] tab = table;;) &#123;// 将数组赋值给tab Node&lt;K,V&gt; f; int n, i, fh; if (tab == null || (n = tab.length) == 0)// 如果数组是空的，需要初始化数组 tab = initTable(); else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) &#123;// 如果放置的数组下标位置没有数据，就直接将当前新数据放在这个位置就可以了，数组也不会进行扩容 if (casTabAt(tab, i, null, new Node&lt;K,V&gt;(hash, key, value, null)))// 使用cas放置当前节点为数组下标上的头节点 break; // no lock when adding to empty bin &#125; else if ((fh = f.hash) == MOVED)// 如果头节点是个已经迁移完成的数据 tab = helpTransfer(tab, f);/*final Node&lt;K,V&gt;[] helpTransfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt; f) &#123; Node&lt;K,V&gt;[] nextTab; int sc; if (tab != null &amp;&amp; (f instanceof ForwardingNode) &amp;&amp; (nextTab = ((ForwardingNode&lt;K,V&gt;)f).nextTable) != null) &#123;// 旧数组下标迁移完成的头节点持有新数组的引用 int rs = resizeStamp(tab.length); while (nextTab == nextTable &amp;&amp; table == tab &amp;&amp; (sc = sizeCtl) &lt; 0) &#123; if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 || sc == rs + MAX_RESIZERS || transferIndex &lt;= 0) break; if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1)) &#123; transfer(tab, nextTab); break; &#125; &#125; return nextTab;// 返回新数组，新进来的数据就放到新数组上就可以了 &#125; return table;&#125;static final int resizeStamp(int n) &#123; return Integer.numberOfLeadingZeros(n) | (1 &lt;&lt; (RESIZE_STAMP_BITS - 1));//RESIZE_STAMP_BITS=16,1左移15次，与n的左边连续0的次数求或运算&#125;public static int numberOfLeadingZeros(int i) &#123;// 按1/2倍数递减查找整数的二进制位上非0之前的连续0的个数 // HD, Figure 5-6 if (i == 0) return 32; int n = 1; if (i &gt;&gt;&gt; 16 == 0) &#123; n += 16; i &lt;&lt;= 16; &#125; if (i &gt;&gt;&gt; 24 == 0) &#123; n += 8; i &lt;&lt;= 8; &#125; if (i &gt;&gt;&gt; 28 == 0) &#123; n += 4; i &lt;&lt;= 4; &#125; if (i &gt;&gt;&gt; 30 == 0) &#123; n += 2; i &lt;&lt;= 2; &#125; n -= i &gt;&gt;&gt; 31; return n;&#125;*/ else &#123; // 如果数组下标上的节点不是null，hash值也不是MOVED V oldVal = null; synchronized (f) &#123;// 对这个下标头节点进行加锁，删除数组下标头结点的时候是不是也需要加锁？ if (tabAt(tab, i) == f) &#123;/*static final &lt;K,V&gt; Node&lt;K,V&gt; tabAt(Node&lt;K,V&gt;[] tab, int i) &#123; return (Node&lt;K,V&gt;)U.getObjectVolatile(tab, ((long)i &lt;&lt; ASHIFT) + ABASE);// 数组下标乘以4，再加16，这就是当前头节点的数据。对头节点加完锁之后再判断头结点还是不是头结点，如果还是头结点就可以放心的修改了&#125;*/ if (fh &gt;= 0) &#123; // 如果头节点的hash值大于等于0，这里的节点hash值都是经过处理过的（将符号位去掉，都是正数），如果是负数表示特殊意义 binCount = 1; for (Node&lt;K,V&gt; e = f;; ++binCount) &#123;// 将头结点拿出来 K ek; if (e.hash == hash &amp;&amp; ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek)))) &#123;// 如果节点的hash值与新数据key的hash值一致，修改数据旧可以了 oldVal = e.val; if (!onlyIfAbsent) e.val = value; break; &#125; Node&lt;K,V&gt; pred = e; if ((e = e.next) == null) &#123;// 如果遍历到尾部，所有的节点与新数据key的hash值都不一致，旧创建一个新节点挂到链表的尾部 pred.next = new Node&lt;K,V&gt;(hash, key,value, null); break; &#125; &#125; &#125;else if (f instanceof TreeBin) &#123;// 如果头节点的hash值小于0，并且头结点的数据类型是个TreeBin类型 Node&lt;K,V&gt; p; binCount = 2; if ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,value)) != null) &#123;// 尝试将新数据放入TreeBin中，如果已经有重复的Key，返回那个重复的key对应的节点，将该节点的value设置成新值 oldVal = p.val; if (!onlyIfAbsent) p.val = value; &#125; &#125; &#125; &#125; if (binCount != 0) &#123;// 如果binCount不为0 if (binCount &gt;= TREEIFY_THRESHOLD)// 判断该链表长度是否大于等于TREEIFY_THRESHOLD=8，如果大于等于8，将链表转换成TreeBin类型数据 treeifyBin(tab, i); if (oldVal != null)// 如果是重写value值，直接返回旧的value值 return oldVal; break; &#125; &#125; &#125; addCount(1L, binCount);// 如果不是重写value值，需要新增HashMap的数量 return null;&#125; map保存的key-value数量更新及数组扩容12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667private final void addCount(long x, int check) &#123; CounterCell[] as; long b, s; if ((as = counterCells) != null || // 如果counterCells不为null，就将要增加的数量保存到counterCells数组中去。如果为null就直接更新baseCount的值。多线程并发情况下，更新CAS失败再去放入counterCells数组中保存新增的节点数量，最后想获取map的节点数量的时候用baseCount+counterCells数组中各个节点的value值 !U.compareAndSwapLong(this, BASECOUNT, b = baseCount, s = b + x)) &#123; CounterCell a; long v; int m; boolean uncontended = true;// 非竞争 if (as == null // 如果数组等于null || (m = as.length - 1) &lt; 0 // 如果counterCells数组长度为0 || (a = as[ThreadLocalRandom.getProbe() &amp; m]) == null // as的数组长度-1,一堆的111111，与线程的probe数值求与，就找到了这个线程对应的counterCells数组下标。找到下标下的节点，如果这个Cell是null，也要进行FullAddCount(); || !(uncontended = U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) &#123;// 如果找到了这个线程对应的数组下标，并且数组下标上的节点不是null，并且修改节点的value值，如果修改失败的话，这个时候就是有竞争了（uncontended设置成false了），也得进行fullAddCount()操作 fullAddCount(x, uncontended);// 没法将新增节点数量保存到counterCells数组中了，执行fullAddCount操作 return; &#125; if (check &lt;= 1)// 如果tab数组下标上只挂着一个节点或者带新节点共两个节点，就不会对数组进行扩容 return; s = sumCount();// 重新计算节点数量 &#125; if (check &gt;= 0) &#123;// 这里的check为链表长度，-1时是删除数据 Node&lt;K,V&gt;[] tab, nt; int n, sc; while (s &gt;= (long)(sc = sizeCtl) &amp;&amp; (tab = table) != null &amp;&amp; // 如果新增完数据后，数据总数大于等于阀值，将会对数组进行扩容 (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;// 数组长度不能超过1 &lt;&lt; 30，也就是说数组扩容只能扩容30-4=26次 int rs = resizeStamp(n);// 统计数组长度值中非0前面的0的个数与1&lt;&lt;15取或运算，数组长度都是2的整数倍/*static final int resizeStamp(int n) &#123; return Integer.numberOfLeadingZeros(n) | (1 &lt;&lt; (RESIZE_STAMP_BITS - 1));//RESIZE_STAMP_BITS=16,1左移15次，与n的左边连续0的次数求或运算&#125;public static int numberOfLeadingZeros(int i) &#123;// 按1/2倍数递减查找整数的二进制位上非0之前的连续0的个数 // HD, Figure 5-6 if (i == 0) return 32; int n = 1; if (i &gt;&gt;&gt; 16 == 0) &#123; n += 16; i &lt;&lt;= 16; &#125; if (i &gt;&gt;&gt; 24 == 0) &#123; n += 8; i &lt;&lt;= 8; &#125; if (i &gt;&gt;&gt; 28 == 0) &#123; n += 4; i &lt;&lt;= 4; &#125; if (i &gt;&gt;&gt; 30 == 0) &#123; n += 2; i &lt;&lt;= 2; &#125; n -= i &gt;&gt;&gt; 31; return n;&#125;*/ if (sc &lt; 0) &#123;// 如果阀值小于0，表示其它线程正在进行数据迁移操作 if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs // 如果扩容的不是当前这一轮 || sc == rs + 1 // rs+1怎么可能是负数sc？ || sc == rs + MAX_RESIZERS //rs+ (1 &lt;&lt; 16) - 1 || (nt = nextTable) == null // nextTable是null的 || transferIndex &lt;= 0)// 迁移下标值到0，快完成迁移了 break; if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1)) transfer(tab, nt); &#125; else if (U.compareAndSwapInt(this, SIZECTL, sc, (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2))// rs左移16位再加2，如果数组长度是16，那么二进制就是10000，那么左边非1的个数就是32-5=27，那么这个值的二进制数就是10000000000110110000000000000010，值是-2145714174，加锁用的值 transfer(tab, null);// 迁移数据到新的数组 s = sumCount();// 重新计算map中保存的数据的个数/*final long sumCount() &#123; CounterCell[] as = counterCells; CounterCell a; long sum = baseCount; if (as != null) &#123; for (int i = 0; i &lt; as.length; ++i) &#123; if ((a = as[i]) != null) sum += a.value; &#125; &#125; return sum;&#125;*/ &#125; &#125;&#125; 将旧数组中的数据迁移到新数组中去123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129private final void transfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab) &#123; int n = tab.length, stride; // cpu核数如果大于1，将数组长度除以8再除以核数，否则就是数组长度；如果小于16，那么还是设置stride为16 if ((stride = (NCPU &gt; 1) ? (n &gt;&gt;&gt; 3) / NCPU : n) &lt; MIN_TRANSFER_STRIDE) stride = MIN_TRANSFER_STRIDE; // 细分范围为16，如果cpu是多核的，那么将数组长度除以8再除以核数，如果值小于16，那么就设置细分数是16 if (nextTab == null) &#123; // 初始化新数组 try &#123; Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n &lt;&lt; 1];// 新数组长度是旧数组长度的2倍 nextTab = nt; &#125; catch (Throwable ex) &#123; // 数组过长，出现OOM异常 sizeCtl = Integer.MAX_VALUE; return; &#125; nextTable = nextTab; transferIndex = n;// 要迁移的数组下标，赋值为旧数组长度 &#125; int nextn = nextTab.length;// 获取新数组长度 ForwardingNode&lt;K,V&gt; fwd = new ForwardingNode&lt;K,V&gt;(nextTab);// 迁移完成旧数组下标上的链表数据后，将数组下标节点设置成ForwardingNode节点 boolean advance = true; boolean finishing = false; for (int i = 0, bound = 0;;) &#123; Node&lt;K,V&gt; f; int fh; while (advance) &#123;// 预处理 int nextIndex, nextBound; if (--i &gt;= bound || finishing)// 要迁移的数组从最大下标开始递减，不能小于0 advance = false; else if ((nextIndex = transferIndex) &lt;= 0) &#123;// 如果遍历到旧数组的0下标，走下面的if (i &lt; 0 || i &gt;= n || i + n &gt;= nextn)逻辑块内容 i = -1; advance = false; &#125; // 如果当前线程拿到数据迁移锁transferIndex,从16转成0 else if (U.compareAndSwapInt(this, TRANSFERINDEX, nextIndex,nextBound = (nextIndex &gt; stride ? nextIndex - stride : 0))) &#123; bound = nextBound;// 迁移的数组下标最低值 i = nextIndex - 1;// i从就数组长度减一开始递减遍历数组下标上的数据 advance = false; // 预处理完成 &#125; &#125; if (i &lt; 0 || i &gt;= n || i + n &gt;= nextn) &#123;// 旧数组数据遍历完成 int sc; if (finishing) &#123;// 再次检查也完成，所有旧数组中的数据全部迁移到新数组下面了 nextTable = null;// 将nextTable变量设置成null table = nextTab;// 将table设置成新的table sizeCtl = (n &lt;&lt; 1) - (n &gt;&gt;&gt; 1);// 重新设置阀值为现在数组长度的0.75倍 return; &#125; if (U.compareAndSwapInt(this, SIZECTL, sc = sizeCtl, sc - 1)) &#123;// 如果当前线程拿到sizeCtl锁（现在sizeCtl是个负数，只是当锁用） if ((sc - 2) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)// 拿到sizeCtl锁后，判断阀值是否还是原来的值，如果阀值已经被改变了，说明这一轮数据迁移早就完成了 return; finishing = advance = true;// 表示数据迁移完成，可以准备退出循环了 i = n; // 再检查一遍，看是否都迁移完成 &#125; &#125; else if ((f = tabAt(tab, i)) == null)// 如果旧数组下标上的节点是空值，将该下标节点上的值设置成fwd advance = casTabAt(tab, i, null, fwd); else if ((fh = f.hash) == MOVED)// 如果数组下标上的节点hash值是MOVED，表示这个下标上的数据已经迁移完成 advance = true; else &#123; synchronized (f) &#123;// 如果数组下标上的节点数据还没有迁移完成，对该节点加锁进行迁移 if (tabAt(tab, i) == f) &#123;// 加锁成功后，判断该数组下标上的节点有没有变动 Node&lt;K,V&gt; ln, hn; if (fh &gt;= 0) &#123;// 判断该节点的hash值是否大于等于0，大于等于0才是正常的数据，小于0的要么是已经迁移完成的fwd，要么是TREEBIN类型的节点数据 int runBit = fh &amp; n;// 将hash值与16*（10000）进行取与操作，看看是不是应该放到高16位的数组下标上，因为数组长度扩容了嘛，数据要么放到高16位下标上，要么放到低16位下标上 Node&lt;K,V&gt; lastRun = f;// 保存数组下标节点 for (Node&lt;K,V&gt; p = f.next; p != null; p = p.next) &#123;// 查找到数组下标节点链表上的最后一个节点，判断它是放到高位，还是放到低位 int b = p.hash &amp; n; if (b != runBit) &#123; runBit = b; lastRun = p; &#125; &#125; if (runBit == 0) &#123;// 如果是放到低16位上，就把最后这个节点赋值给ln ln = lastRun; hn = null; &#125; else &#123; // 如果需要放到高16位下标数组上，就把这个节点赋值个hn hn = lastRun; ln = null; &#125; // 拿到头节点，遍历非尾节点的所有节点，将节点分别放入高位链表或低位链表上面 for (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123; int ph = p.hash; K pk = p.key; V pv = p.val; if ((ph &amp; n) == 0) ln = new Node&lt;K,V&gt;(ph, pk, pv, ln); else hn = new Node&lt;K,V&gt;(ph, pk, pv, hn); &#125; setTabAt(nextTab, i, ln);// 低位节点链表挂到新数组的低位下标上，因为新数组里面肯定没有值，直接用cas挂上就可以 setTabAt(nextTab, i + n, hn);// 高位节点链表挂到新数组的高位下标上 setTabAt(tab, i, fwd);// 设置旧数组下标上的头节点为ForwardingNode节点，表示旧数组下标上的节点已经全部迁移到新数组下标上了 advance = true;// 继续推进下一个数组下标节点 &#125; else if (f instanceof TreeBin) &#123; TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f; TreeNode&lt;K,V&gt; lo = null, loTail = null; TreeNode&lt;K,V&gt; hi = null, hiTail = null; int lc = 0, hc = 0; for (Node&lt;K,V&gt; e = t.first; e != null; e = e.next) &#123; int h = e.hash; TreeNode&lt;K,V&gt; p = new TreeNode&lt;K,V&gt;(h, e.key, e.val, null, null); if ((h &amp; n) == 0) &#123;// 如果hash值与10000取与操作后为0，表示得放到数组的低下标上 if ((p.prev = loTail) == null)// 如果上一个节点是null lo = p;// 将lo赋值成p else loTail.next = p;// 如果上一个节点不为null，那将当前节点挂到上一节点下面 loTail = p; ++lc; &#125; else &#123; if ((p.prev = hiTail) == null) hi = p; else hiTail.next = p; hiTail = p; ++hc; &#125; &#125; ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :// 如果数组下标上挂着的节点数不足8个，将treeNode转成链表 (hc != 0) ? new TreeBin&lt;K,V&gt;(lo) : t;// 如果高位上一个都没分配到，那就直接将原TreeBin挂到低位上就可以了 hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :// 如果数组下标上挂着的节点数不足8个，将treeNode转成链表 (lc != 0) ? new TreeBin&lt;K,V&gt;(hi) : t;// 如果低位上一个都没分配到，那就直接将原TreeBin挂到高位上就可以了 setTabAt(nextTab, i, ln); setTabAt(nextTab, i + n, hn); setTabAt(tab, i, fwd); advance = true; &#125; &#125; &#125; &#125; &#125;&#125; 当修改ConcurrentHashMap中保存的节点数量失败时，将新增的数量保存到counterCells数组下面，当要计算ConcurrentHashMap的size的时候需要将baseCount+counterCells数组上的各个value值123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990private final void fullAddCount(long x, boolean wasUncontended) &#123; int h; if ((h = ThreadLocalRandom.getProbe()) == 0) &#123;// 如果拿到的Probe值是0，说明是还没初始化ThreadLocalRandom ThreadLocalRandom.localInit();/*static final void localInit() &#123;// 直接初始化ThreadLocalRandom int p = probeGenerator.addAndGet(PROBE_INCREMENT);// AtomicInteger.addAndGet(0x9e3779b9);// 将probeGenerator增加到0x9e3779b9 int probe = (p == 0) ? 1 : p; // 如果是0的话，那就用1 long seed = mix64(seeder.getAndAdd(SEEDER_INCREMENT)); Thread t = Thread.currentThread(); UNSAFE.putLong(t, SEED, seed); UNSAFE.putInt(t, PROBE, probe);&#125;*/ h = ThreadLocalRandom.getProbe(); wasUncontended = true;// 如果连probe值都没有，那肯定不是同一个Cell节点同时被多个线程修改value值的时冲突的情况 &#125; boolean collide = false; for (;;) &#123; CounterCell[] as; CounterCell a; int n; long v; if ((as = counterCells) != null &amp;&amp; (n = as.length) &gt; 0) &#123;// 如果counterCells数组已经初始化过 if ((a = as[(n - 1) &amp; h]) == null) &#123;// 如果数组对应线程hash下标节点是null值，需要创建下标节点 if (cellsBusy == 0) &#123; // 如果别的线程没有在争用counterCells数组 CounterCell r = new CounterCell(x); // 创建一个CounterCell数组 if (cellsBusy == 0 &amp;&amp; U.compareAndSwapInt(this, CELLSBUSY, 0, 1)) &#123;// 如果修改busy状态成功，就表明自己有修改数组结构的权限，加锁成功 boolean created = false; try &#123; CounterCell[] rs; int m, j; if ((rs = counterCells) != null &amp;&amp; (m = rs.length) &gt; 0 &amp;&amp; rs[j = (m - 1) &amp; h] == null) &#123;// 如果加锁后counterCells数组对应该线程的节点依然是null rs[j] = r; // 将数组下标上的节点赋一个新值 created = true;// 创建成功 &#125; &#125; finally &#123; cellsBusy = 0;// 释放数组锁 &#125; if (created)// 如果创建成功了，跳出循环，任务完成 break; continue; // 如果加锁后该下标节点已经存在，继续for循环处理 &#125; &#125; collide = false;// 如果别的线程也在争用该数组的锁 &#125; else if (!wasUncontended) // 如果是修改counterCells数组下标节点的value值时冲突了，wasUncontended=false wasUncontended = true; else if (U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))// 如果数组下标节点不是null了，尝试修改value值 break; else if (counterCells != as || n &gt;= NCPU)// 如果counterCells是陈旧的数组，或者数组长度超过了cpu核心数 collide = false; else if (!collide)// 如果依然没有修改counterCells对应下面的节点value成功，设置collide为true collide = true; else if (cellsBusy == 0 &amp;&amp; U.compareAndSwapInt(this, CELLSBUSY, 0, 1)) &#123;// 竞争太激烈了，一直修改不成功，尝试着扩展数组的长度来减少单个数组节点竞争 try &#123; if (counterCells == as) &#123;// 如果依然还是旧的数组，进行数组扩展，扩展2倍 CounterCell[] rs = new CounterCell[n &lt;&lt; 1]; for (int i = 0; i &lt; n; ++i) rs[i] = as[i];// 迁移数据 counterCells = rs;// 重新赋值counterCells &#125; &#125; finally &#123; cellsBusy = 0; &#125; collide = false; continue; &#125; h = ThreadLocalRandom.advanceProbe(h);// 竞争还是太激烈，一直拿不到数组的锁，尝试修改线程的prode，进而修改该增量值的数组下标位置 &#125; else if (cellsBusy == 0 &amp;&amp; counterCells == as &amp;&amp; U.compareAndSwapInt(this, CELLSBUSY, 0, 1)) &#123;// 如果counterCell为null，加锁，进行初始化数组 boolean init = false; try &#123; if (counterCells == as) &#123; CounterCell[] rs = new CounterCell[2];// 创建一个新的CounterCell数组，初始长度是2 rs[h &amp; 1] = new CounterCell(x);// 计算线程应该放到数组哪个下标位置，然后在那个位置创建一个新的CounterCell counterCells = rs; init = true; &#125; &#125; finally &#123; cellsBusy = 0;// 释放数组锁 &#125; if (init)// 如果本线程拿到锁并初始化成功（顺带将新增数量保存了），任务完成，可以退出循环了 break; &#125; else if (U.compareAndSwapLong(this, BASECOUNT, v = baseCount, v + x))// 如果争抢数组锁一直失败，那就直接再去修改baseCount值，如果修改完成，那么任务也算完成 break; &#125;&#125; remove(key)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273public V remove(Object key) &#123; return replaceNode(key, null, null);&#125;final V replaceNode(Object key, V value, Object cv) &#123; int hash = spread(key.hashCode()); for (Node&lt;K,V&gt;[] tab = table;;) &#123; Node&lt;K,V&gt; f; int n, i, fh; if (tab == null || (n = tab.length) == 0 || (f = tabAt(tab, i = (n - 1) &amp; hash)) == null) break; else if ((fh = f.hash) == MOVED) tab = helpTransfer(tab, f); else &#123; V oldVal = null; boolean validated = false; synchronized (f) &#123;// 对数组下标节点加锁 if (tabAt(tab, i) == f) &#123; if (fh &gt;= 0) &#123; validated = true; for (Node&lt;K,V&gt; e = f, pred = null;;) &#123; K ek; if (e.hash == hash &amp;&amp; ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek)))) &#123; V ev = e.val; if (cv == null || cv == ev || (ev != null &amp;&amp; cv.equals(ev))) &#123; oldVal = ev; if (value != null) e.val = value; else if (pred != null) pred.next = e.next; else setTabAt(tab, i, e.next); &#125; break; &#125; pred = e; if ((e = e.next) == null) break; &#125; &#125; else if (f instanceof TreeBin) &#123; validated = true; TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f; TreeNode&lt;K,V&gt; r, p; if ((r = t.root) != null &amp;&amp; (p = r.findTreeNode(hash, key, null)) != null) &#123; V pv = p.val; if (cv == null || cv == pv || (pv != null &amp;&amp; cv.equals(pv))) &#123; oldVal = pv; if (value != null) p.val = value; else if (t.removeTreeNode(p)) setTabAt(tab, i, untreeify(t.first)); &#125; &#125; &#125; &#125; &#125; if (validated) &#123; if (oldVal != null) &#123; if (value == null) addCount(-1L, -1);// 不会进行数组扩容，也不会缩减数组长度，更不会进行数据迁移 return oldVal; &#125; break; &#125; &#125; &#125; return null;&#125; 总结：ConcurrentHashMap新增数据时，会对key计算hash值，再计算应放置到的数组下标位置，如果该数组下标下的链表小于等于1个，不会进行数组扩容，否则判断保存的节点个数是否超过阀值，如果超过，在addCount()的时候会对数组进行扩容。 修改ConcurrentHashMap的baseCount如果不成功，会保存在counterCells数组上，计算size的时候：baseCount+counterCells数组各个节点的value值 使用synchronized进行数组下标的头节点加锁操作 数组扩容不能超过1&lt;&lt;30 大量使用cas进行各个环节进行加锁解锁操作，保证线程安全]]></content>
      <categories>
        <category>jdk源码</category>
      </categories>
      <tags>
        <tag>HashMap</tag>
        <tag>Hashtable</tag>
        <tag>ConcurrentHashMap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java线程池源码解析]]></title>
    <url>%2F2018%2F01%2F09%2F2018-01-09Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%8A%80%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[线程池使用背景多线程任务获取线程的方法 new Thread() 使用线程池 众所周知，创建一个线程是需要消耗很多的系统资源，如果随意创建大量无用的执行短生命周期任务的线程，会占用过多系统资源导致死机或者OOM 相比直接创建线程，我们使用线程池的技术会有很多好处 重用线程，减少线程创建、消亡的开销，性能更佳 可以控制线程创建的数量，提高系统资源的使用率，同时可以避免更多线程运行时的资源竞争，避免堵塞 可以提供定时任务执行，定期执行，单线程执行，并发数控制等功能 通过Executors创建四种线程池Java通过Executors可以提供四种线程池的创建，分别是 newCachedThreadPool 创建一个可以缓存的线程池，如果线程池线程数量超过处理需要，可以灵活收回线程，若需要更多线程，则新建线程 newFixedThreadPool 创建一个确定线程数量的线程池，可以控制线程最大并发数，超出的线程就需要放入队列等待 newScheduledThreadPool 创建一个确定线程数量的线程池，支持定时及周期性的执行任务 newSingleThreadPool 创建一个单线程的线程池，单线程执行处理所有的任务，保证任务执行顺序是FIFO或LIFO。 newCachedThreadPool()创建线程池 1234567ExecutorService cachedThreadPool = Executors.newCachedThreadPool();// 实际创建对象ThreadPoolExecutor，最大线程数是Integer的最大值，相当于不限制线程数public static ExecutorService newCachedThreadPool() &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;());&#125; newFixedThreadPool(10) 1234567ExecutorService fixedThreadPool = Executors.newFixedThreadPool(10);// 实际创建对象也是ThreadPoolExecutor，创建一个指定大小的线程池，线程数不能改变，超出线程数的任务放入队列中等待public static ExecutorService newFixedThreadPool(int nThreads) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;());&#125; newSingleThreadExecutor() 创建一个单线程的线程池 12345678ExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor();// 实际创建对象是FinalizableDelegatedExecutorService，传递进去一个单线程的ThreadPoolExecutor,实际还是使用ThreadPoolExecutor处理任务public static ExecutorService newSingleThreadExecutor() &#123; return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()));&#125; newScheduledThreadPool() 创建可定期执行任务的线程池 123456789ExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(10);// 创建的是一个ScheduledThreadPoolExecutor，这个类继承自ThreadPoolExecutor,实际上创建的还是ThreadPoolExecutorpublic static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) &#123; return new ScheduledThreadPoolExecutor(corePoolSize);&#125;public ScheduledThreadPoolExecutor(int corePoolSize) &#123; super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS, new DelayedWorkQueue());&#125; 线程池实现类ThreadPoolExecutor ThreadPollExecutor（newCachedThreadPool/newFixedThreadPool/newSingleThreadExecutor/newScheduledThreadPool最后都会用这个）是如何启动线程的 我们来看看ThreadPoolExecutor到底是怎么实现任务执行的123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228public class ThreadPoolExecutor extends AbstractExecutorService &#123; public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,BlockingQueue&lt;Runnable&gt; workQueue) &#123; this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, Executors.defaultThreadFactory(), defaultHandler); &#125; public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,BlockingQueue&lt;Runnable&gt; workQueue,ThreadFactory threadFactory) &#123; this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory, defaultHandler); &#125; public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,BlockingQueue&lt;Runnable&gt; workQueue,RejectedExecutionHandler handler) &#123; this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, Executors.defaultThreadFactory(), handler); &#125; // 最终都会调用到这个构造方法 public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,BlockingQueue&lt;Runnable&gt; workQueue,ThreadFactory threadFactory,RejectedExecutionHandler handler) &#123; if (corePoolSize &lt; 0 || maximumPoolSize &lt;= 0 || maximumPoolSize &lt; corePoolSize || keepAliveTime &lt; 0) throw new IllegalArgumentException(); if (workQueue == null || threadFactory == null || handler == null) throw new NullPointerException(); this.corePoolSize = corePoolSize; this.maximumPoolSize = maximumPoolSize; this.workQueue = workQueue; this.keepAliveTime = unit.toNanos(keepAliveTime); this.threadFactory = threadFactory; this.handler = handler; &#125; //-536870912 // 11100000000000000000000000000000 // 需要运行00011111111111111111111111111111个线程才会超标 private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0)); private static final int COUNT_BITS = Integer.SIZE - 3; // CAPACITY===00011111111111111111111111111111 // ~CAPACITY===11100000000000000000000000000000 private static final int CAPACITY = (1 &lt;&lt; COUNT_BITS) - 1; // 11100000000000000000000000000000 private static final int RUNNING = -1 &lt;&lt; COUNT_BITS; // 00000000000000000000000000000000 private static final int SHUTDOWN = 0 &lt;&lt; COUNT_BITS; // 00100000000000000000000000000000 private static final int STOP = 1 &lt;&lt; COUNT_BITS; // 01000000000000000000000000000000 private static final int TIDYING = 2 &lt;&lt; COUNT_BITS; // 01100000000000000000000000000000 private static final int TERMINATED = 3 &lt;&lt; COUNT_BITS; private static int runStateOf(int c) &#123; // 运行状态 // 与11100000000000000000000000000000求与操作 // 除了RUNNING状态，其它求与出来的值都是大于等于0 return c &amp; ~CAPACITY; &#125; // 统计线程数数量 private static int workerCountOf(int c) &#123; // 11100000000000000000000000000000+n个worker // 与00011111111111111111111111111111求与操作 return c &amp; CAPACITY; &#125; private static int ctlOf(int rs, int wc) &#123; return rs | wc; &#125; private static boolean isRunning(int c) &#123; // 如果状态小于0，就是在运行中 return c &lt; SHUTDOWN; &#125; public void execute(Runnable command) &#123; // 不管是execute(Runnable)还是submit(Runnable/Callable)，最后都会调用到这里 if (command == null) throw new NullPointerException(); int c = ctl.get(); if (workerCountOf(c) &lt; corePoolSize) &#123;// 如果线程数小于初始线程数，直接创建线程执行任务就可以了 if (addWorker(command, true)) return; c = ctl.get(); &#125; if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;// 看看能不能放入队列或跟空闲线程匹配上 int recheck = ctl.get(); if (! isRunning(recheck) &amp;&amp; remove(command)) reject(command); else if (workerCountOf(recheck) == 0) addWorker(null, false); &#125; else if (!addWorker(command, false)) // 线程数创建多余初始线程数了，也不能放入队列了，也没有空闲线程匹配了，还是得创建新线程执行任务 reject(command); &#125; // 这就是大名鼎鼎的addWorker,创建线程包装类Worker，执行任务队列中的任务 private boolean addWorker(Runnable firstTask, boolean core) &#123; // 创建线程执行新任务 retry: for (;;) &#123; int c = ctl.get(); int rs = runStateOf(c);// 看线程数，超过了536870912个就不允许新建线程了，一开始值这个值是-536870912，有点夸张了 if (rs &gt;= SHUTDOWN &amp;&amp; ! (rs == SHUTDOWN &amp;&amp; firstTask == null &amp;&amp; ! workQueue.isEmpty())) return false; for (;;) &#123; int wc = workerCountOf(c); if (wc &gt;= CAPACITY ||// 如果创建的是初始线程（core=true）超过了初始线程数，或者创建的不是初始线程（core=fase）超过了线程池最大线程数，直接返回，不创建了 wc &gt;= (core ? corePoolSize : maximumPoolSize)) return false; if (compareAndIncrementWorkerCount(c))// 增加线程数统计 break retry; c = ctl.get(); // Re-read ctl if (runStateOf(c) != rs) continue retry; &#125; &#125; boolean workerStarted = false; boolean workerAdded = false; Worker w = null; try &#123; w = new Worker(firstTask);// 创建一个Worker，间接也创建里面的一个线程，将当前任务再传递进去，创建的线程会优先处理当前的任务 final Thread t = w.thread; if (t != null) &#123; final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try &#123; int rs = runStateOf(ctl.get()); if (rs &lt; SHUTDOWN || (rs == SHUTDOWN &amp;&amp; firstTask == null)) &#123; if (t.isAlive()) // precheck that t is startable throw new IllegalThreadStateException(); //HashSet&lt;Worker&gt; workers = new HashSet&lt;Worker&gt;();这个workers是ThreadPoolExecutor中的属性 workers.add(w);// 将工作线程添加到集合中统一管理 int s = workers.size(); if (s &gt; largestPoolSize)// 更新线程池创建之后的最大并发线程数数量 largestPoolSize = s; workerAdded = true; &#125; &#125; finally &#123; mainLock.unlock(); &#125; if (workerAdded) &#123; t.start(); // 启动worker中的线程，线程持有的正好是该Worker这个Runnable，运行的时候会调用该Worker的run()方法，进而会调用ThreadPoolExecutor类中的runWorker()方法，开启处理当前任务和之后匹配到的新任务中的任务 workerStarted = true; &#125; &#125; &#125; finally &#123; if (! workerStarted) addWorkerFailed(w); &#125; return workerStarted; &#125; // 我们再来看看大名鼎鼎的Worker，任务线程封装类 private final class Worker extends AbstractQueuedSynchronizer implements Runnable&#123; // ThreadPoolExecutor的私有类 private static final long serialVersionUID = 6138294804551838833L; final Thread thread; Runnable firstTask; volatile long completedTasks; Worker(Runnable firstTask) &#123; // 将新任务传递进来 setState(-1); // inhibit interrupts until runWorker this.firstTask = firstTask; this.thread = getThreadFactory().newThread(this); &#125; public void run() &#123;// Worker.thread.start()方法启动后就会调用到这个run方法 runWorker(this);// 这个runWorker(this)方法就是ThreadPoolExecutor中的 &#125; ... &#125; // 我们再来看看大名鼎鼎的runWorker()方法 final void runWorker(Worker w) &#123;// ThreadPoolExecutor中的 Thread wt = Thread.currentThread(); Runnable task = w.firstTask; w.firstTask = null; w.unlock(); // allow interrupts boolean completedAbruptly = true; try &#123; while (task != null || (task = getTask()) != null) &#123;// 这里才是获取线程的重要地方 w.lock(); if ((runStateAtLeast(ctl.get(), STOP) || (Thread.interrupted() &amp;&amp; runStateAtLeast(ctl.get(), STOP))) &amp;&amp; !wt.isInterrupted()) wt.interrupt(); try &#123; beforeExecute(wt, task); Throwable thrown = null; try &#123; task.run(); &#125; catch (RuntimeException x) &#123; thrown = x; throw x; &#125; catch (Error x) &#123; thrown = x; throw x; &#125; catch (Throwable x) &#123; thrown = x; throw new Error(x); &#125; finally &#123; afterExecute(task, thrown); &#125; &#125; finally &#123; task = null; w.completedTasks++; w.unlock(); &#125; &#125; completedAbruptly = false; &#125; finally &#123; processWorkerExit(w, completedAbruptly); &#125; &#125; // 我们再来看看大名鼎鼎的runWorker()-&gt;getTask()方法 private Runnable getTask() &#123; boolean timedOut = false; for (;;) &#123; int c = ctl.get(); int rs = runStateOf(c); if (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123; decrementWorkerCount(); return null; &#125; int wc = workerCountOf(c); boolean timed = allowCoreThreadTimeOut || wc &gt; corePoolSize; if ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut)) &amp;&amp; (wc &gt; 1 || workQueue.isEmpty())) &#123; if (compareAndDecrementWorkerCount(c)) return null; continue; &#125; try &#123; Runnable r = timed ? // 这下真相大白了，所有的任务(排除newCachedThreadPool的firstTask)都是通过不同线程池里的不同队列中获取到的，至于任务入队、任务出队的具体实现，下面我们会详细讲解 workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) : workQueue.take(); if (r != null) return r; timedOut = true; &#125; catch (InterruptedException retry) &#123; timedOut = false; &#125; &#125; &#125; 。。。&#125; newCachedThreadPoolexecute(Runnable)的任务封装和任务运行任务封装都是将Runnable原封不动的放入队列中，根本就不进行封装 任务运行直接调用传进来的Runnable.run()方法就可以了 submit(Runnable)的任务封装和任务运行任务封装123456789101112131415161718// 封装成FutureTaskpublic Future&lt;?&gt; submit(Runnable task) &#123; if (task == null) throw new NullPointerException(); RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, null); execute(ftask); return ftask;&#125;protected &lt;T&gt; RunnableFuture&lt;T&gt; newTaskFor(Runnable runnable, T value) &#123; return new FutureTask&lt;T&gt;(runnable, value);// 封装成FutureTask&#125;public FutureTask(Runnable runnable, V result) &#123; this.callable = Executors.callable(runnable, result);// 本质是要创建FutureTask中的一个callable，这样在FutureTask-&gt;run()方法中就可以调用callable.call()方法了/*public static &lt;T&gt; Callable&lt;T&gt; callable(Runnable task, T result) &#123; if (task == null) throw new NullPointerException(); return new RunnableAdapter&lt;T&gt;(task, result);// 封装一个RunnableAdapter当做FutureTask的callable，这样就在调用FutureTask-&gt;run()的时候callable.call()方法了&#125;*/ this.state = NEW; // ensure visibility of callable&#125; 任务运行执行FutureTask.run()方法1234567891011121314151617181920212223242526272829303132333435363738public void run() &#123; if (state != NEW || !UNSAFE.compareAndSwapObject(this, runnerOffset,null, Thread.currentThread())) return; try &#123; Callable&lt;V&gt; c = callable; if (c != null &amp;&amp; state == NEW) &#123; V result; boolean ran; try &#123; result = c.call();// 调用自己的callable属性值的call()方法，本质就是调用RunnableAdapter.call()方法/*static final class RunnableAdapter&lt;T&gt; implements Callable&lt;T&gt; &#123; final Runnable task; final T result; RunnableAdapter(Runnable task, T result) &#123; this.task = task; // 这个是传递进来的Runnable任务 this.result = result; // 这里可定设置的null或默认值 &#125; public T call() &#123; task.run();// 执行Runnable.run()方法 return result; &#125;&#125;*/ ran = true; &#125; catch (Throwable ex) &#123; result = null; ran = false; setException(ex); &#125; if (ran) set(result); &#125; &#125; finally &#123; runner = null; int s = state; if (s &gt;= INTERRUPTING) handlePossibleCancellationInterrupt(s); &#125; &#125; submit(Callable)的任务封装和任务运行任务封装1234567891011121314public &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task) &#123; if (task == null) throw new NullPointerException(); RunnableFuture&lt;T&gt; ftask = newTaskFor(task);// 这里同样也是要封装成FutureTask，只不过这次封装的是Callable类型的任务，那就更容易了 execute(ftask); return ftask;&#125;protected &lt;T&gt; RunnableFuture&lt;T&gt; newTaskFor(Callable&lt;T&gt; callable) &#123; return new FutureTask&lt;T&gt;(callable);&#125;public FutureTask(Callable&lt;V&gt; callable) &#123; if (callable == null) throw new NullPointerException(); this.callable = callable; // 都不用转换，直接赋值给callable属性就可以了 this.state = NEW; // ensure visibility of callable&#125; 任务运行因为封装成的FutureTask的属性callable就是传递进去的Callable任务，运行的时候直接调用到了Callable任务自己实现的业务逻辑了 FutureTask.run()-&gt;callable.call()&lt;==&gt;自己实现的Callable接口任务类.call()方法 任务入队和任务出队 execute(Runnable),submit(Runnable/Callable)入队、出队实现逻辑都是一样的 任务入队不管是execute()还是submit()，最后都会调用到execute(Runnable command)方法，如果是submit(Callable)，会将Callable转换成FutureTask，这个FutureTask也同样是一个Runnable类型的实现类，为什么要实现Runnable接口？完全可以实现Callable接口啊，拿到任务后RutureTask.call()就行了，估计场景不一样，FutureTask本来就不会立即运行的意思，就不要实现Callable接口了吧 123456789101112131415161718192021// 添加任务运行public void execute(Runnable command) &#123; if (command == null) throw new NullPointerException(); int c = ctl.get(); if (workerCountOf(c) &lt; corePoolSize) &#123;// 如果线程数小于初始线程数，直接创建线程执行任务就可以了，注意：newCachedThreadPool创建的线程池初始线程数为0，最大线程数数量没有限制，所以一直都不会走这个逻辑 if (addWorker(command, true)) return; c = ctl.get(); &#125; // 对newCachedThreadPool线程池来说，使用的是SynchronousQueue队列，必须有空闲线程的情况下才会走这个方法体 // 对于newFixedThreadPool(5)使用的队列是LinkedBlockingQueue，可以方Integer.MAX_VALUE个任务进去 if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123; int recheck = ctl.get(); if (! isRunning(recheck) &amp;&amp; remove(command)) reject(command); else if (workerCountOf(recheck) == 0) addWorker(null, false); &#125; else if (!addWorker(command, false)) // 没空闲线程的情况下走这里，如果新任务加入不了队列中，只能新建线程去处理这个任务了 reject(command);&#125; 我们先看看没空闲线程的情况下，任务怎么入队列，调用的是上面的这个代码块 12else if (!addWorker(command, false)) // 没空闲线程的情况下走这里，如果新任务加入不了队列中，只能新建线程去处理这个任务了 reject(command) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179private boolean addWorker(Runnable firstTask, boolean core) &#123; // 创建线程执行新任务 retry: for (;;) &#123; int c = ctl.get(); int rs = runStateOf(c);// 看线程数，超过了536870912个就不允许新建线程了，一开始值这个值是-536870912，有点夸张了 if (rs &gt;= SHUTDOWN &amp;&amp; ! (rs == SHUTDOWN &amp;&amp; firstTask == null &amp;&amp; ! workQueue.isEmpty())) return false; for (;;) &#123; int wc = workerCountOf(c); if (wc &gt;= CAPACITY ||// 如果创建的是初始线程（core=true）超过了初始线程数，或者创建的不是初始线程（core=fase）超过了线程池最大线程数，直接返回，不创建了 wc &gt;= (core ? corePoolSize : maximumPoolSize)) return false; if (compareAndIncrementWorkerCount(c))// 增加线程数统计 break retry; c = ctl.get(); // Re-read ctl if (runStateOf(c) != rs) continue retry; &#125; &#125; boolean workerStarted = false; boolean workerAdded = false; Worker w = null; try &#123; w = new Worker(firstTask);// 创建一个Worker，间接也创建里面的一个线程，将当前任务再传递进去，创建的线程会优先处理当前的任务 final Thread t = w.thread; if (t != null) &#123; final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try &#123; int rs = runStateOf(ctl.get()); if (rs &lt; SHUTDOWN || (rs == SHUTDOWN &amp;&amp; firstTask == null)) &#123; if (t.isAlive()) // precheck that t is startable throw new IllegalThreadStateException(); //HashSet&lt;Worker&gt; workers = new HashSet&lt;Worker&gt;();这个workers是ThreadPoolExecutor中的属性 workers.add(w);// 将工作线程添加到集合中统一管理 int s = workers.size(); if (s &gt; largestPoolSize)// 更新线程池创建之后的最大并发线程数数量 largestPoolSize = s; workerAdded = true; &#125; &#125; finally &#123; mainLock.unlock(); &#125; if (workerAdded) &#123; t.start(); // 启动worker中的线程，线程持有的正好是该Worker这个Runnable，运行的时候会调用该Worker的run()方法，进而会调用ThreadPoolExecutor类中的runWorker()方法，开启处理当前任务和之后匹配到的新任务中的任务 workerStarted = true; &#125; &#125; &#125; finally &#123; if (! workerStarted) addWorkerFailed(w); &#125; return workerStarted;&#125;// 创建Worker实例，就会创建一个新线程，在调用worker.thread.start()方法后就会调用该实例中的run()方法private final class Worker extends AbstractQueuedSynchronizer implements Runnable&#123; // ThreadPoolExecutor的私有类 private static final long serialVersionUID = 6138294804551838833L; final Thread thread; Runnable firstTask; volatile long completedTasks; Worker(Runnable firstTask) &#123; // 将新任务传递进来 setState(-1); // inhibit interrupts until runWorker this.firstTask = firstTask; this.thread = getThreadFactory().newThread(this); &#125; public void run() &#123;// Worker.thread.start()方法启动后就会调用到这个run方法 runWorker(this);// 这个runWorker(this)方法就是ThreadPoolExecutor中的 &#125; ...&#125;// 创建的线程开始工作了final void runWorker(Worker w) &#123; Thread wt = Thread.currentThread(); Runnable task = w.firstTask;// worker中的任务优先处理 w.firstTask = null;// 拿到firstTask后立刻清除firstTask属性的值 w.unlock(); // allow interrupts boolean completedAbruptly = true; try &#123; while (task != null || (task = getTask()) != null) &#123; // 首先会执行线程创建时的第一个任务，其次会不断查找队列中的新任务来执行/*private Runnable getTask() &#123;//这个getTask是线程获取任务的核心代码 boolean timedOut = false; // Did the last poll() time out? for (;;) &#123; int c = ctl.get(); // 看看是不是负数 int rs = runStateOf(c); // Check if queue empty only if necessary. if (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123; decrementWorkerCount(); return null; &#125; // 看看有多少个工作worker了 int wc = workerCountOf(c); // 会不会被淘汰，允许线程超时，或者工作线程大于初始线程数 boolean timed = allowCoreThreadTimeOut || wc &gt; corePoolSize; if ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut)) &amp;&amp; (wc &gt; 1 || workQueue.isEmpty())) &#123; if (compareAndDecrementWorkerCount(c)) return null; continue; &#125; try &#123; Runnable r = timed ? workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) : workQueue.take(); // 这是查找队列中的新任务的核心代码 if (r != null) return r; timedOut = true; &#125; catch (InterruptedException retry) &#123;timedOut = false;&#125; &#125;&#125;*/ w.lock(); if ((runStateAtLeast(ctl.get(), STOP) || (Thread.interrupted() &amp;&amp; runStateAtLeast(ctl.get(), STOP))) &amp;&amp; !wt.isInterrupted()) wt.interrupt();// 如果线程数过多，中断这个线程 try &#123; beforeExecute(wt, task); Throwable thrown = null; try &#123; task.run(); &#125; catch (RuntimeException x) &#123; thrown = x; throw x; &#125; catch (Error x) &#123; thrown = x; throw x; &#125; catch (Throwable x) &#123; thrown = x; throw new Error(x); &#125; finally &#123; afterExecute(task, thrown); &#125; &#125; finally &#123; task = null; w.completedTasks++; w.unlock(); &#125; &#125; completedAbruptly = false;// 突然结束了 &#125; finally &#123; processWorkerExit(w, completedAbruptly);/*private void processWorkerExit(Worker w, boolean completedAbruptly) &#123; if (completedAbruptly) // 如果是突然结束，线程数应该没有减一，现在需要减一操作 decrementWorkerCount(); final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try &#123; completedTaskCount += w.completedTasks;// 线程结束前执行任务数量进行统计 workers.remove(w);// 从线程池中将当前worker去掉 &#125; finally &#123; mainLock.unlock(); &#125; tryTerminate();// 尝试终止线程 int c = ctl.get(); if (runStateLessThan(c, STOP)) &#123; if (!completedAbruptly) &#123;// 如果不是突然结束 int min = allowCoreThreadTimeOut ? 0 : corePoolSize; // 是否允许初始线程一直保留 if (min == 0 &amp;&amp; ! workQueue.isEmpty())// 如果最小初始线程数是0，并且任务队列中不为空 min = 1;// 需要一个线程去消费任务队列 if (workerCountOf(c) &gt;= min)// 如果还有线程正在运行中，直接返回了 return; // replacement not needed &#125; addWorker(null, false);// 否则创建一个线程去处理任务吧，本线程是必须得收回了 &#125;&#125;*//*final void tryTerminate() &#123; for (;;) &#123; int c = ctl.get();// 查看执行任务数是否超标 if (isRunning(c) || // 如果仍让在运行中，直接返回 runStateAtLeast(c, TIDYING) || (runStateOf(c) == SHUTDOWN &amp;&amp; ! workQueue.isEmpty())) return;// 直接返回 ... &#125;&#125;*/ &#125;&#125; 我们再来看看有空闲线程的情况下，任务会如何入队列，这里入队列的意思就是跟空闲线程配对了，配上了直接让空闲线程执行任务，配不上还得创建线程（就像上面的addWorker）执行123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081public boolean offer(E runnable) &#123;//SynchronousQueue中的 if (e == null) throw new NullPointerException(); return transferer.transfer(runnable, true, 0) != null;&#125;//runnable, true, 0// 提交任务到空闲线程队列E transfer(E runnable, boolean timed, long nanos) &#123; //SynchronousQueue中的 SNode s = null; int mode = (runnable == null) ? REQUEST : DATA;// runnable不是null，表示要添加一个任务到空闲线程队列，runnable为null，表示获取新任务 for (;;) &#123; SNode h = head; if (h == null || h.mode == mode) &#123; // 查找有没有空闲线程，如果h为null，表示没有空闲线程，将任务添加到空闲线程队列肯定是失败的 if (timed &amp;&amp; nanos &lt;= 0) &#123; // 添加新任务的时候timed为true，nanos为0，那么就会走这里的逻辑 if (h != null &amp;&amp; h.isCancelled()) casHead(h, h.next); else return null;// 到这个地方还是没有空闲线程，只能返回null了，表示添加到空闲线程队列失败 &#125; else if (casHead(h, s = snode(s, runnable, h, mode))) &#123; 。。。//将任务添加到队列的时候这里肯定是不走的，timed=true,nanos=0 &#125; &#125; else if (!isFulfilling(h.mode)) &#123; // 添加新任务的时候head不为null并且head节点也不是DATA:1、FULFILLING:2类型节点（那么其它类型只有REQUEST:0、FULFILLING|mode:3），可以将新任务与head节点绑定，也就是将新任务与空闲线程绑定，意思就是添加到空闲线程队列成功 if (h.isCancelled()) // already cancelled casHead(h, h.next); // pop and retry else if (casHead(h, s=snode(s, runnable, h, FULFILLING|mode))) &#123;// 新增的节点模式是3（为什么不是DATA类型1？如果是DATA类型，就会走上面的if语句块中的逻辑了，这里要解决得是并发情况下前面有一个正在匹配中的新任务节点，本次新任务节点也得继续走这个逻辑块），请求的模式是DATA=1，再与FULFILLING取或预算后的值是3，也就是说所有添加到队列中的任务模式都是3/*static SNode snode(SNode s, Object e, SNode next, int mode) &#123; if (s == null) s = new SNode(e);// 创建一个新任务节点 s.mode = mode;// 模式是3 s.next = next;// 当前节点的下一个节点是头节点 return s;&#125;*/ for (;;) &#123; // loop until matched or waiters disappear SNode m = s.next; // m is s's match if (m == null) &#123; // all waiters are gone casHead(s, null); // pop fulfill node s = null; // use new node next time break; // restart main loop &#125; SNode mn = m.next; if (m.tryMatch(s)) &#123; // 这里才是真正的将新任务节点与空闲线程的head节点匹配的关键步骤/*boolean tryMatch(SNode s) &#123; if (match == null &amp;&amp; // 如果当前head节点的match属性为null UNSAFE.compareAndSwapObject(this, matchOffset, null, s)) &#123;// 将match属性设置成新添加进来的任务节点 Thread w = waiter; if (w != null) &#123; // waiters need at most one unpark waiter = null; LockSupport.unpark(w);// 将该head上等待的线程给唤醒 &#125; return true; &#125; return match == s;//看看match属性值和新添加进来的节点是否一样&#125;*/ casHead(s, mn); // pop both s and m，将head节点和对应的任务节点都删除掉 /* boolean casHead(SNode h, SNode nh) &#123; return h == head &amp;&amp; UNSAFE.compareAndSwapObject(this, headOffset, h, nh);//将第一个head节点和匹配上的任务节点都删除掉，新进来的任务节点只能与下一个head节点匹配了&#125;*/ return (E) ((mode == REQUEST) ? m.item : s.item);// 如果是请求任务数据?请求任务不走这个地方吧，就返回第一个head节点里面的Runnable，如果是新增新任务请求，就返回新任务数据 &#125; else // lost match s.casNext(m, mn); // 将新进来的任务匹配下一个空闲线程的head节点（如果有空闲线程的话），实现方案是把当前匹配到新任务的空闲线程对应的head节点剔除掉/*boolean casNext(SNode cmp, SNode val) &#123; return cmp == next &amp;&amp; UNSAFE.compareAndSwapObject(this, nextOffset, cmp, val);&#125;*/ &#125; &#125; &#125; else &#123; // 清理正在匹配中的任务节点和对应空闲线程head节点 SNode m = h.next; if (m == null) casHead(h, null); else &#123; SNode mn = m.next; if (m.tryMatch(h)) casHead(h, mn); // pop both h and m else // lost match h.casNext(m, mn); // help unlink &#125; &#125; &#125;&#125; 任务出队使用的队列是 SynchronousQueue，在线程消费完自己的第一个任务之后，会继续获取队列中的其它任务，队列SynchronousQueue获取其它任务的方法会调用到workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) 实现逻辑如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124public E poll(long timeout, TimeUnit unit) throws InterruptedException &#123; E e = transferer.transfer(null, true, unit.toNanos(timeout)); if (e != null || !Thread.interrupted()) return e; throw new InterruptedException();&#125;// null true 60000000// 从队列中获取一个Runnable的任务，不能超过规定的时间，如果超过规定的时间，就表示该线程空闲下来可以回收了E transfer(E runnable, boolean timed, long nanos) &#123; //SynchronousQueue中的 SNode s = null; // constructed/reused as needed int mode = (runnable == null) ? REQUEST : DATA;// 现在是空闲线程获取任务，这里的runnable就是null，对应的模式就是REQUEST for (;;) &#123; SNode h = head; if (h == null || h.mode == mode) &#123; // 如果没有其它空闲线程，或者头节点的模式也是REQUEST模式 if (timed &amp;&amp; nanos &lt;= 0) &#123; // 这里的代码块是肯定不会走的 。。。// 空闲线程获取任务的时候，这里肯定是走不到的，timed是true，nanos=60000000000 &#125; else if (casHead(h, s = snode(s, runnable, h, mode))) &#123;// 当前空闲线程会创建一个head节点，然后放入所有head节点的前面，优先匹配新任务，越活跃的线程就越有机会获得新任务，越不活跃的线程就越没机会获取新任务// static SNode snode(SNode s, Object e, SNode next, int mode) &#123;// if (s == null) s = new SNode(e);创建一个新的SNode节点，该节点中的任务为null// s.mode = mode;// 这个节点的类型是获取一个任务给线程// s.next = next;// 这个节点的下一个节点是h=null// return s;// 返回这个心创建的节点// &#125; SNode m = awaitFulfill(s, timed, nanos);// 这里会阻塞，直到节点中match属性不为null为止，match不为null的情况有两种，一种是超时情况下match赋值为自身，另一种是有任务时设置成任务节点// 等待任务中/*SNode awaitFulfill(SNode s, boolean timed, long nanos) &#123;//SynchronousQueue中的 final long deadline = timed ? System.nanoTime() + nanos : 0L;// 设置一个截止时间，到截止时间点了线程仍拿不到任务，就得把这个空闲线程搞掉了 Thread w = Thread.currentThread(); int spins = shouldSpin(s) ? (timed ? maxTimedSpins : maxUntimedSpins) : 0;// 是否需要自旋，如果需要自旋，判断是否需要等待时间，如果需要等待时间，就判断CPU是几核的，如果1核CPU，返回0，多核CPU返回32 //shouldSpin(s)&lt;====&gt;SNode h = head; return (h == s || h == null || isFulfilling(h.mode));// 如果头节点等于当前节点，或者头几点是空节点，或者该节点是自旋节点，都需要自旋 for (;;) &#123; if (w.isInterrupted())// 如果当前线程被中断了 s.tryCancel(); SNode m = s.match;// 获取匹配到的节点 if (m != null)// 如果拿到任务了，很顺利啊，就直接返回该任务吧 return m; if (timed) &#123;// 看看是不是需要判断是否超时 nanos = deadline - System.nanoTime(); if (nanos &lt;= 0L) &#123;// 超时了 s.tryCancel();// 将match设置成当前的Node节点 continue; &#125; &#125; if (spins &gt; 0)// 需要自旋多少次？32次 spins = shouldSpin(s) ? (spins-1) : 0; else if (s.waiter == null)// 如果这个头节点的waiter是空的，设置这个头节点的waiter为当前的线程 s.waiter = w; // establish waiter so can park next iter else if (!timed) LockSupport.park(this); else if (nanos &gt; spinForTimeoutThreshold)// 如果自旋了32次之后该线程还是没有空闲超时，就让该线程park掉剩下的空闲超时时间，默认是60秒，自旋32次，等着新任务进来main线程执行tryMatch()之后唤醒当前线程；超时后还是会在这个循环里，就会走到s.tryCancel()中的方法了 LockSupport.parkNanos(this, nanos); &#125;&#125;*/ if (m == s) &#123; // 如果拿到的节点是自身，表示线程超时了也没有新任务要处理/* void tryCancel() &#123; UNSAFE.compareAndSwapObject(this, matchOffset, null, this);//将头节点的match属性设置成自己&#125;*/ clean(s);// 超时后清理这个head节点/*void clean(SNode s) &#123; s.item = null; // forget item s.waiter = null; // forget thread SNode past = s.next; if (past != null &amp;&amp; past.isCancelled()) past = past.next; SNode p; while ((p = head) != null &amp;&amp; p != past &amp;&amp; p.isCancelled()) casHead(p, p.next); // Unsplice embedded nodes while (p != null &amp;&amp; p != past) &#123; SNode n = p.next; if (n != null &amp;&amp; n.isCancelled()) p.casNext(n, n.next); else p = n; &#125;&#125;*/ return null; &#125; if ((h = head) != null &amp;&amp; h.next == s)// 如果当前队列中的头节点是自己拿到的任务节点和对应的空闲线程head节点，将匹配成功的空闲线程head节点删除 casHead(h, s.next); // help s's fulfiller return (E) ((mode == REQUEST) ? m.item : s.item);// 如果是请求任务，就返回匹配到的任务，如果是添加任务，就返回本空闲线程head节点对应的任务（肯定是null） &#125; &#125; else if (!isFulfilling(h.mode)) &#123; // 如果有新任务正在匹配中，模式是FULFILLING|mode:3，这块逻辑也是走不到的// static boolean isFulfilling(int m) &#123; return (m &amp; FULFILLING) != 0; &#125; 。。。//getTask()的时候不会走到这个地方的逻辑 &#125; else &#123; // 清理正在匹配中的任务节点和对应空闲线程head节点 SNode m = h.next; if (m == null) casHead(h, null); else &#123; SNode mn = m.next; if (m.tryMatch(h)) casHead(h, mn); // pop both h and m else // lost match h.casNext(m, mn); // help unlink &#125; &#125; &#125;&#125;// 清理当前线程的头节点void clean(SNode s) &#123; s.item = null; // forget item s.waiter = null; // forget thread SNode past = s.next; if (past != null &amp;&amp; past.isCancelled()) past = past.next; // Absorb cancelled nodes at head SNode p; while ((p = head) != null &amp;&amp; p != past &amp;&amp; p.isCancelled()) casHead(p, p.next); // Unsplice embedded nodes while (p != null &amp;&amp; p != past) &#123; SNode n = p.next; if (n != null &amp;&amp; n.isCancelled()) p.casNext(n, n.next); else p = n; &#125;&#125; newFixedThreadPool任务封装与上面的newCachedThreadPool封装逻辑一样 任务运行与上面的newCachedThreadPool运行逻辑一样 任务入队和出队-execute(Runnable)，submit(Runnable/Callable)的入队出队逻辑都是一样的 任务入队 使用的队列是 LinkedBlockingQueue， 当创建的线程数量大于初始线程数时，执行到offer(runnalbe)的时候将新任务放入队列中去123456789101112131415161718192021222324252627282930313233343536public boolean offer(E e) &#123; if (e == null) throw new NullPointerException(); final AtomicInteger count = this.count; if (count.get() == capacity) return false; int c = -1; Node&lt;E&gt; node = new Node&lt;E&gt;(e); final ReentrantLock putLock = this.putLock; putLock.lock(); try &#123; if (count.get() &lt; capacity) &#123; enqueue(node);/*private void enqueue(Node&lt;E&gt; node) &#123; last = last.next = node;// 将当前节点放到链表的最后面&#125;*/ c = count.getAndIncrement(); if (c + 1 &lt; capacity) notFull.signal(); &#125; &#125; finally &#123; putLock.unlock(); &#125; if (c == 0) signalNotEmpty();// 通知一下别的线程，队列中有任务需要处理了/*private void signalNotEmpty() &#123; final ReentrantLock takeLock = this.takeLock; takeLock.lock(); try &#123; notEmpty.signal();// 这里是唤醒线程去执行任务 &#125; finally &#123; takeLock.unlock(); &#125;&#125;*/ return c &gt;= 0;&#125; 任务出队1234567891011121314151617181920212223242526272829303132333435boolean timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;//这个是falseRunnable r = timed ? workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) : workQueue.take();// LinkedBlockingQueue从队列中获取订单时使用这个方法 public E take() throws InterruptedException &#123; E x; int c = -1; final AtomicInteger count = this.count; final ReentrantLock takeLock = this.takeLock; takeLock.lockInterruptibly(); try &#123; while (count.get() == 0) &#123; notEmpty.await();// 空闲线程发现队列中没有任务可以执行，就await阻塞，直到被signal()为止 &#125; x = dequeue();/*private E dequeue() &#123;// 将head丢出去，垃圾回收，然后把Head后第一个节点上的任务取出来，然后把Head后第一个节点变成head节点 Node&lt;E&gt; h = head; Node&lt;E&gt; first = h.next; h.next = h; // help GC head = first; E x = first.item; first.item = null; return x;&#125;*/ c = count.getAndDecrement(); if (c &gt; 1) notEmpty.signal(); &#125; finally &#123; takeLock.unlock(); &#125; if (c == capacity) signalNotFull(); return x;&#125; newScheduledThreadPoolexecute(Runnable)的任务封装和任务运行execute(Runnable)任务封装1234567891011121314151617181920public void execute(Runnable command) &#123; schedule(command, 0, NANOSECONDS);&#125;public ScheduledFuture&lt;?&gt; schedule(Runnable command,long delay,TimeUnit unit) &#123; if (command == null || unit == null) throw new NullPointerException(); RunnableScheduledFuture&lt;?&gt; t = decorateTask(command,new ScheduledFutureTask&lt;Void&gt;(command, null,triggerTime(delay, unit)));// 返回的还是ScheduledFutureTask对象/*ScheduledFutureTask(Runnable r, V result, long ns) &#123;// 创建一个ScheduledFutureTask，其实也是FutureTask，里面会有一个callable的属性，调用call的时候就会调用runnable的run方法 super(r, result); this.time = ns; this.period = 0; this.sequenceNumber = sequencer.getAndIncrement();&#125;public FutureTask(Runnable runnable, V result) &#123; this.callable = Executors.callable(runnable, result);// return new RunnableAdapter&lt;T&gt;(task, result); 需要将runnable类型的任务转换成RunnableAdapter的类型 this.state = NEW;&#125;*/ delayedExecute(t);// 将任务放入队列中 return t;&#125; execute(Runnable) 任务运行调用ScheduledFutureTask.run()方法后 不管Runnable还是Callable，最后都会封装成ScheduledFutureTask，调用run方法的时候就是调用ScheduledFutureTask.run()方法， 最后都会调用其父类的FutureTask.run()-&gt;callable.call() 这里需要注意的是Callable类型的任务FutureTask中callable是Callable任务本身 而Runnable类型的任务FutureTask中callable是通过Executors.callable(runnable, result)创建出来的，是RunnableAdapter类型1234567891011121314151617181920212223242526272829303132333435363738394041public void run() &#123;//ScheduledThreadPoolExecutor.ScheduledFutureTask中的 boolean periodic = isPeriodic(); if (!canRunInCurrentRunState(periodic))// 如果是周期性任务返回false 如果不是周期性的任务，返回true，如果shutdown之后还是会继续运行 cancel(false); else if (!periodic) ScheduledFutureTask.super.run();// 最终会调用FutureTask.run()方法 else if (ScheduledFutureTask.super.runAndReset()) &#123; setNextRunTime(); reExecutePeriodic(outerTask); &#125;&#125;public void run() &#123; // FutureTask.run() if (state != NEW || !UNSAFE.compareAndSwapObject(this, runnerOffset, null, Thread.currentThread())) return; try &#123; Callable&lt;V&gt; c = callable; if (c != null &amp;&amp; state == NEW) &#123; V result; boolean ran; try &#123; result = c.call(); // RunnableAdapter.call() 其本质是调用这个/*public T call() &#123; task.run(); return result;&#125;*/ ran = true; &#125; catch (Throwable ex) &#123; result = null; ran = false; setException(ex); &#125; if (ran) set(result); &#125; &#125; finally &#123; runner = null; int s = state; if (s &gt;= INTERRUPTING) handlePossibleCancellationInterrupt(s); &#125;&#125; submit(Runnable)的任务封装和任务运行submit(Runnable)的任务封装12345678910public Future&lt;?&gt; submit(Runnable task) &#123; return schedule(task, 0, NANOSECONDS);&#125;public ScheduledFuture&lt;?&gt; schedule(Runnable command,long delay,TimeUnit unit) &#123;// 走到这个地方，就跟execute(Runnable)的逻辑一模一样了 if (command == null || unit == null) throw new NullPointerException(); RunnableScheduledFuture&lt;?&gt; t = decorateTask(command,new ScheduledFutureTask&lt;Void&gt;(command, null, triggerTime(delay, unit))); delayedExecute(t); return t;&#125; submit(Runnable)的任务运行既然与execute(Runnable)封装的对象都一样，那么运行时也是一样的 submit(Callable)的任务封装和任务运行submit(Callable)的任务封装123456789101112131415161718192021public Future&lt;?&gt; submit(Runnable task) &#123; // ScheduledThreadPoolExecutor中的 return schedule(task, 0, NANOSECONDS);&#125;public &lt;V&gt; ScheduledFuture&lt;V&gt; schedule(Callable&lt;V&gt; callable,long delay,TimeUnit unit) &#123; // ScheduledThreadPoolExecutor中的 if (callable == null || unit == null) throw new NullPointerException(); RunnableScheduledFuture&lt;V&gt; t = decorateTask(callable,new ScheduledFutureTask&lt;V&gt;(callable,triggerTime(delay, unit)));// 这里将会创建一个ScheduledFutureTask任务对象/*ScheduledFutureTask(Callable&lt;V&gt; callable, long ns) &#123;// ScheduledThreadPoolExecutor中的ScheduledFutureTask中的 super(callable); this.time = ns; this.period = 0; this.sequenceNumber = sequencer.getAndIncrement();&#125;public FutureTask(Callable&lt;V&gt; callable) &#123; // FutureTask中的 if (callable == null) throw new NullPointerException(); this.callable = callable;// 直接将Callable类型的任务赋值给callable属性了 this.state = NEW; &#125;*/ delayedExecute(t); return t;&#125; submit(Callable)的任务运行调用ScheduledFutureTask.run()方法后 不管Runnable还是Callable，最后都会封装成ScheduledFutureTask，调用run方法的时候就是调用ScheduledFutureTask.run()方法， 最后都会调用其父类的FutureTask.run()-&gt;callable.call() 这里需要注意的是Callable类型的任务FutureTask中callable是Callable任务本身 而Runnable类型的任务FutureTask中callable是通过Executors.callable(runnable, result)创建出来的，是RunnableAdapter类型12345678910111213141516171819202122232425262728293031323334353637public void run() &#123;//ScheduledThreadPoolExecutor.ScheduledFutureTask中的 boolean periodic = isPeriodic(); if (!canRunInCurrentRunState(periodic))// 如果是周期性任务返回false 如果不是周期性的任务，返回true，如果shutdown之后还是会继续运行 cancel(false); else if (!periodic) ScheduledFutureTask.super.run();// 最终会调用到FutureTask.run()方法 else if (ScheduledFutureTask.super.runAndReset()) &#123; setNextRunTime(); reExecutePeriodic(outerTask); &#125;&#125;public void run() &#123; if (state != NEW || !UNSAFE.compareAndSwapObject(this, runnerOffset, null, Thread.currentThread())) return; try &#123; Callable&lt;V&gt; c = callable; if (c != null &amp;&amp; state == NEW) &#123; V result; boolean ran; try &#123; result = c.call();// Callable.call()其本质是调用这个，然后返回结果 ran = true; &#125; catch (Throwable ex) &#123; result = null; ran = false; setException(ex); &#125; if (ran) set(result); &#125; &#125; finally &#123; runner = null; int s = state; if (s &gt;= INTERRUPTING) handlePossibleCancellationInterrupt(s); &#125;&#125; 任务入队和出队 execute(Runnable)、submit(Runnable/Callable)任务入队和出队逻辑都是一样的execute(Runnable)12345678910public void execute(Runnable command) &#123; schedule(command, 0, NANOSECONDS);&#125;public ScheduledFuture&lt;?&gt; schedule(Runnable command, long delay, TimeUnit unit) &#123; if (command == null || unit == null) throw new NullPointerException(); RunnableScheduledFuture&lt;?&gt; t = decorateTask(command,new ScheduledFutureTask&lt;Void&gt;(command, null, triggerTime(delay, unit))); delayedExecute(t);// 传递进去的对象都是ScheduledFutureTask return t;&#125; submit(Runnable)123456789public Future&lt;?&gt; submit(Runnable task) &#123; return schedule(task, 0, NANOSECONDS);&#125;public ScheduledFuture&lt;?&gt; schedule(Runnable command,long delay,TimeUnit unit) &#123; if (command == null || unit == null) throw new NullPointerException(); RunnableScheduledFuture&lt;?&gt; t = decorateTask(command,new ScheduledFutureTask&lt;Void&gt;(command, null,triggerTime(delay, unit))); delayedExecute(t);// 传递进去的对象都是ScheduledFutureTask return t;&#125; submit(Callable)123456789public &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task) &#123; return schedule(task, 0, NANOSECONDS);&#125;public &lt;V&gt; ScheduledFuture&lt;V&gt; schedule(Callable&lt;V&gt; callable,long delay,TimeUnit unit) &#123; if (callable == null || unit == null) throw new NullPointerException(); RunnableScheduledFuture&lt;V&gt; t = decorateTask(callable,new ScheduledFutureTask&lt;V&gt;(callable,triggerTime(delay, unit))); delayedExecute(t);// 传递进去的对象都是ScheduledFutureTask return t;&#125; 任务入队1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980private void delayedExecute(RunnableScheduledFuture&lt;?&gt; task) &#123; if (isShutdown()) reject(task); else &#123; super.getQueue().add(task);// 这里到了入队的和兴，队列类型是DelayedWorkQueue if (isShutdown() &amp;&amp; !canRunInCurrentRunState(task.isPeriodic()) &amp;&amp; remove(task)) task.cancel(false); else ensurePrestart(); &#125;&#125;// DelayedWorkQueue的add(task)是怎么处理的public boolean add(Runnable e) &#123; return offer(e);&#125;public boolean offer(Runnable x) &#123;//这里的任务是ScheduledFutureTask if (x == null) throw new NullPointerException(); RunnableScheduledFuture&lt;?&gt; e = (RunnableScheduledFuture&lt;?&gt;)x; final ReentrantLock lock = this.lock; lock.lock();// 这里插入新任务的时候需要加锁，如果不加锁的话，不停变换DelayedWorkQueue（本质是数组）的不同下标下的元素是有问题的 try &#123; int i = size; if (i &gt;= queue.length)// 这里是通过数组private RunnableScheduledFuture&lt;?&gt;[] queue = new RunnableScheduledFuture&lt;?&gt;[INITIAL_CAPACITY];来持有数据的 grow();// size = i + 1; if (i == 0) &#123;// 如果是数组的第一个任务，没什么好说的，直接摆在第一个下标位置就可以了 queue[0] = e; setIndex(e, 0);/*private void setIndex(RunnableScheduledFuture&lt;?&gt; f, int idx) &#123; if (f instanceof ScheduledFutureTask)((ScheduledFutureTask)f).heapIndex = idx;// 设置任务的heapIndex为0&#125;*/ &#125; else &#123; siftUp(i, e);// 如果数组中还有别的定时任务，那么还是排队执行吧，看谁执行时间最早，将它排在前面/*判断当前添加的任务运行时间是否比之前添加的任务早，如果需要先运行，就把这个任务跟那些后运行的任务调换位置private void siftUp(int k, RunnableScheduledFuture&lt;?&gt; key) &#123; while (k &gt; 0) &#123; int parent = (k - 1) &gt;&gt;&gt; 1; RunnableScheduledFuture&lt;?&gt; e = queue[parent]; if (key.compareTo(e) &gt;= 0) break; queue[k] = e; setIndex(e, k); k = parent; &#125; queue[k] = key; setIndex(key, k);&#125;public int compareTo(Delayed other) &#123;// 比较到底是谁需要先运行，谁需要后运行 if (other == this) // compare zero if same object return 0; if (other instanceof ScheduledFutureTask) &#123; ScheduledFutureTask&lt;?&gt; x = (ScheduledFutureTask&lt;?&gt;)other; long diff = time - x.time;// 当前任务的触发时间与上一个任务的触发时间比较 if (diff &lt; 0) return -1; else if (diff &gt; 0) return 1; else if (sequenceNumber &lt; x.sequenceNumber) return -1; else return 1; &#125; long diff = getDelay(NANOSECONDS) - other.getDelay(NANOSECONDS); return (diff &lt; 0) ? -1 : (diff &gt; 0) ? 1 : 0;&#125;*/ &#125; if (queue[0] == e) &#123;// 如果好长时间都没有任务，所有的线程都在await()状态，那么就得唤醒一个线程来执行任务 leader = null; available.signal(); &#125; &#125; finally &#123; lock.unlock(); &#125; return true;&#125; 任务出队123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137// 启动线程执行任务出队，之后就是任务执行了（暂且不管，上面有解释）void ensurePrestart() &#123; int wc = workerCountOf(ctl.get()); if (wc &lt; corePoolSize) // 如果线程数还不够初始线程数，啥也别说了，创建线程吧 addWorker(null, true); else if (wc == 0) addWorker(null, false);&#125;// 所有线程池类型的线程在拿任务的逻辑都是一样的，存活的执行生命周期中的绝大部分时间都是在运行runWorker()方法，拿任务，执行任务final void runWorker(Worker w) &#123;// ThreadPoolExecutor中的 Thread wt = Thread.currentThread(); Runnable task = w.firstTask; w.firstTask = null; w.unlock(); // allow interrupts boolean completedAbruptly = true; try &#123; while (task != null || (task = getTask()) != null) &#123;// 这里才是获取线程的重要地方 w.lock(); if ((runStateAtLeast(ctl.get(), STOP) || (Thread.interrupted() &amp;&amp; runStateAtLeast(ctl.get(), STOP))) &amp;&amp; !wt.isInterrupted()) wt.interrupt(); try &#123; beforeExecute(wt, task); Throwable thrown = null; try &#123; task.run(); &#125; catch (RuntimeException x) &#123; thrown = x; throw x; &#125; catch (Error x) &#123; thrown = x; throw x; &#125; catch (Throwable x) &#123; thrown = x; throw new Error(x); &#125; finally &#123; afterExecute(task, thrown); &#125; &#125; finally &#123; task = null; w.completedTasks++; w.unlock(); &#125; &#125; completedAbruptly = false; &#125; finally &#123; processWorkerExit(w, completedAbruptly); &#125;&#125;private Runnable getTask() &#123; boolean timedOut = false; // Did the last poll() time out? for (;;) &#123; int c = ctl.get(); int rs = runStateOf(c); if (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123; decrementWorkerCount(); return null; &#125; int wc = workerCountOf(c); boolean timed = allowCoreThreadTimeOut || wc &gt; corePoolSize; if ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut)) &amp;&amp; (wc &gt; 1 || workQueue.isEmpty())) &#123; if (compareAndDecrementWorkerCount(c)) return null; continue; &#125; try &#123; Runnable r = timed ? workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) : workQueue.take();// 最后会走到这个地方 if (r != null) return r; timedOut = true; &#125; catch (InterruptedException retry) &#123; timedOut = false; &#125; &#125;&#125;public RunnableScheduledFuture&lt;?&gt; take() throws InterruptedException &#123;// 这是DelayedWorkerQueue中的方法 final ReentrantLock lock = this.lock; lock.lockInterruptibly();// 所有线程在队列中拿任务的时候都得加锁 try &#123; for (;;) &#123; // 这里是需要不停的自旋来获取队列中的任务 RunnableScheduledFuture&lt;?&gt; first = queue[0];// 拿到第一个任务 if (first == null) available.await(); else &#123; long delay = first.getDelay(NANOSECONDS); if (delay &lt;= 0)// 看看第一个任务到运行时间了没有，到运行时间了就开始运行 return finishPoll(first);/*private RunnableScheduledFuture&lt;?&gt; finishPoll(RunnableScheduledFuture&lt;?&gt; f) &#123; int s = --size;// 队列大小 RunnableScheduledFuture&lt;?&gt; x = queue[s];// 拿到队列最后面的那个任务 queue[s] = null; if (s != 0)// 如果队列最后面的那个任务不为null，尝试将它放入队列首部（如果队列首部之后的任务都比这个最后面的任务执行时间晚的话），如果比它执行早，它还真不能放到队列首部，得按时间排队才行 siftDown(0, x); setIndex(f, -1);//设置第一个任务的heapIndex为-1 return f;// 返回第一个任务&#125;private void siftDown(int k, RunnableScheduledFuture&lt;?&gt; key) &#123;//0，和最后那个任务 尝试将最后那个任务放入队列首部（如果队列首部之后的任务都比这个最后面的任务执行时间晚的话），如果比它执行早，它还真不能放到队列首部，得按时间与队列首部之后的任务排队才行 int half = size &gt;&gt;&gt; 1;//取任务数量的半数 while (k &lt; half) &#123;// 从0开始找 int child = (k &lt;&lt; 1) + 1;// 找到子节点 RunnableScheduledFuture&lt;?&gt; c = queue[child];// 拿到子节点 int right = child + 1;// 拿到子节点相邻右边的子节点 if (right &lt; size &amp;&amp; c.compareTo(queue[right]) &gt; 0)// 比较这两个子节点，拿到最先执行的那个节点任务 c = queue[child = right]; if (key.compareTo(c) &lt;= 0)// 将队列最后那个节点与最小子节点进行比较，如果比子节点执行时间还早，就不用将子节点挪动了，直接将最后的那个队列任务放入队列中的下标是0的位置 break; queue[k] = c;// 如果队列最后的那个节点比最小子节点执行时间晚，就将最小子节点移动到0下标 setIndex(c, k); k = child;// 腾出来的下标就是刚才移走的最小子节点下标，再看看队列最后节点能否放入这个腾出来的下标下面 &#125; queue[k] = key;// 最后总会拿到一个空闲的位置（如果拿不到比最后节点执行时间还早的子节点，直接放入下标是0的位置上就可以了），将队列最后节点放到这个位置上 setIndex(key, k);// 设置heapIndex，感觉没卵用&#125;*/ first = null; if (leader != null)// 如果leader不是自己，那么我就得等待了 available.await(); else &#123; // 如果第一个任务需要等一段时间才能执行，那么这个线程在这等着吧（因为是leader嘛），其它线程可以休息了，至于等完这段时间后，这个任务会不会被自己领到，那就说不好了，因为自己已经把锁释放掉了，其它线程就可以加锁来获取任务了，在任务到执行期的前一瞬间，有个线程拿到锁了，也就理所当然的拿走了这个刚到执行期的任务 Thread thisThread = Thread.currentThread(); leader = thisThread; try &#123; available.awaitNanos(delay); &#125; finally &#123; if (leader == thisThread) leader = null; &#125; &#125; &#125; &#125; &#125; finally &#123; // 没有等待第一个任务到执行期的线程，那怎么行，得通知别的一个线程才行（本线程有可能被中断啊） if (leader == null &amp;&amp; queue[0] != null) available.signal(); lock.unlock(); &#125;&#125; 固定时间间隔执行任务1234567891011cachedExecutors.scheduleAtFixedRate(new Runnable() &#123; @Override public void run() &#123; try &#123; Thread.sleep(500); System.out.println("线程1执行完任务..."); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125;,3,1,TimeUnit.SECONDS); 相对时间间隔执行任务1234567891011cachedExecutors.scheduleWithFixedDelay(new Runnable() &#123; @Override public void run() &#123; try &#123; Thread.sleep(500); System.out.println("线程2执行完任务..."); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125;,3,1,TimeUnit.SECONDS);]]></content>
      <categories>
        <category>整理</category>
      </categories>
      <tags>
        <tag>线程池</tag>
        <tag>定时任务</tag>
      </tags>
  </entry>
</search>
